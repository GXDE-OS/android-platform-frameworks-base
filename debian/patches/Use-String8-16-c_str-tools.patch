From: Tomasz Wasilczyk <twasilczyk@google.com>
Date: Thu, 10 Aug 2023 23:54:44 +0000
Subject: [PATCH 1/1] Use String8/16 c_str [tools]

Change-Id: I82d6899d8c15a10b15399c39177290012bb5f13b
Forwarded: https://android.googlesource.com/platform/frameworks/base/+/d2a698351d13901b95f836df09e9463344f6ab0e
---
 cmds/idmap2/libidmap2/XmlParser.cpp           |   2 +-
 core/jni/android_content_res_ObbScanner.cpp   |   2 +-
 core/jni/android_util_AssetManager.cpp        |   4 +-
 libs/androidfw/AssetManager.cpp               | 134 ++---
 libs/androidfw/BackupData.cpp                 |   6 +-
 libs/androidfw/BackupHelpers.cpp              |  76 +--
 libs/androidfw/ConfigDescription.cpp          |   2 +-
 libs/androidfw/CursorWindow.cpp               |   2 +-
 libs/androidfw/ObbFile.cpp                    |   4 +-
 libs/androidfw/ResourceTypes.cpp              | 128 ++---
 libs/androidfw/include/androidfw/Asset.h      |   2 +-
 .../include/androidfw/ConfigDescription.h     |   2 +-
 libs/androidfw/tests/BackupData_test.cpp      |  34 +-
 libs/androidfw/tests/CommonHelpers.cpp        |   2 +-
 .../tests/ConfigDescription_test.cpp          |  26 +-
 libs/androidfw/tests/ObbFile_test.cpp         |  10 +-
 libs/androidfw/tests/ResTable_test.cpp        |   6 +-
 libs/androidfw/tests/Split_test.cpp           |   4 +-
 libs/androidfw/tests/TestHelpers.cpp          |   4 +-
 tools/aapt/AaptAssets.cpp                     | 146 ++---
 tools/aapt/AaptAssets.h                       |   2 +-
 tools/aapt/AaptConfig.cpp                     |  60 +--
 tools/aapt/AaptUtil.cpp                       |   4 +-
 tools/aapt/ApkBuilder.cpp                     |   6 +-
 tools/aapt/CacheUpdater.h                     |  12 +-
 tools/aapt/Command.cpp                        | 260 ++++-----
 tools/aapt/CrunchCache.cpp                    |   2 +-
 tools/aapt/DirectoryWalker.h                  |   4 +-
 tools/aapt/FileFinder.cpp                     |   4 +-
 tools/aapt/Images.cpp                         |  42 +-
 tools/aapt/Package.cpp                        |  68 +--
 tools/aapt/Resource.cpp                       | 372 ++++++-------
 tools/aapt/ResourceFilter.cpp                 |   6 +-
 tools/aapt/ResourceIdCache.cpp                |   2 +-
 tools/aapt/ResourceTable.cpp                  | 502 +++++++++---------
 tools/aapt/SourcePos.cpp                      |   6 +-
 tools/aapt/StringPool.cpp                     |  28 +-
 tools/aapt/Symbol.h                           |   6 +-
 tools/aapt/XMLNode.cpp                        | 160 +++---
 tools/aapt/pseudolocalize.cpp                 |   8 +-
 tools/aapt2/Debug.cpp                         |   2 +-
 tools/aapt2/cmd/Util.cpp                      |   2 +-
 .../format/binary/BinaryResourceParser.cpp    |   2 +-
 tools/split-select/Grouper_test.cpp           |   2 +-
 tools/split-select/Main.cpp                   |  38 +-
 tools/split-select/Rule_test.cpp              |   2 +-
 tools/split-select/SplitDescription.cpp       |   4 +-
 tools/split-select/TestRules.cpp              |   5 +-
 48 files changed, 1101 insertions(+), 1106 deletions(-)

diff --git a/cmds/idmap2/libidmap2/XmlParser.cpp b/cmds/idmap2/libidmap2/XmlParser.cpp
index 70822c890288..f71e6b95ba32 100644
--- a/cmds/idmap2/libidmap2/XmlParser.cpp
+++ b/cmds/idmap2/libidmap2/XmlParser.cpp
@@ -111,7 +111,7 @@ Result<std::string> GetStringValue(const ResXMLParser& parser, const Res_value&
   switch (value.dataType) {
     case Res_value::TYPE_STRING: {
       if (auto str = parser.getStrings().string8ObjectAt(value.data); str.ok()) {
-        return std::string(str->string());
+        return std::string(str->c_str());
       }
       break;
     }
diff --git a/core/jni/android_content_res_ObbScanner.cpp b/core/jni/android_content_res_ObbScanner.cpp
index de429a07d0f6..760037f63195 100644
--- a/core/jni/android_content_res_ObbScanner.cpp
+++ b/core/jni/android_content_res_ObbScanner.cpp
@@ -52,7 +52,7 @@ static void android_content_res_ObbScanner_getObbInfo(JNIEnv* env, jobject clazz
 
     env->ReleaseStringUTFChars(file, filePath);
 
-    const char* packageNameStr = obb->getPackageName().string();
+    const char* packageNameStr = obb->getPackageName().c_str();
 
     jstring packageName = env->NewStringUTF(packageNameStr);
     if (packageName == NULL) {
diff --git a/core/jni/android_util_AssetManager.cpp b/core/jni/android_util_AssetManager.cpp
index 206ad17e3c4b..971848d24c38 100644
--- a/core/jni/android_util_AssetManager.cpp
+++ b/core/jni/android_util_AssetManager.cpp
@@ -272,7 +272,7 @@ static jobject NativeGetAssetAllocations(JNIEnv* env, jobject /*clazz*/) {
   if (alloc.length() <= 0) {
     return nullptr;
   }
-  return env->NewStringUTF(alloc.string());
+  return env->NewStringUTF(alloc.c_str());
 }
 
 static jint NativeGetGlobalAssetManagerCount(JNIEnv* /*env*/, jobject /*clazz*/) {
@@ -427,7 +427,7 @@ static jobjectArray NativeList(JNIEnv* env, jclass /*clazz*/, jlong ptr, jstring
   }
 
   for (size_t i = 0; i < file_count; i++) {
-    jstring java_string = env->NewStringUTF(asset_dir->getFileName(i).string());
+    jstring java_string = env->NewStringUTF(asset_dir->getFileName(i).c_str());
 
     // Check for errors creating the strings (if malformed or no memory).
     if (env->ExceptionCheck()) {
diff --git a/libs/androidfw/AssetManager.cpp b/libs/androidfw/AssetManager.cpp
index fb2b57193b83..795bb3c716d1 100644
--- a/libs/androidfw/AssetManager.cpp
+++ b/libs/androidfw/AssetManager.cpp
@@ -91,7 +91,7 @@ String8 idmapPathForPackagePath(const String8& pkgPath) {
     path.appendPath(kResourceCache);
 
     char buf[256]; // 256 chars should be enough for anyone...
-    strncpy(buf, pkgPath.string(), 255);
+    strncpy(buf, pkgPath.c_str(), 255);
     buf[255] = '\0';
     char* filename = buf;
     while (*filename && *filename == '/') {
@@ -183,15 +183,15 @@ bool AssetManager::addAssetPath(
     if (kAppZipName) {
         realPath.appendPath(kAppZipName);
     }
-    ap.type = ::getFileType(realPath.string());
+    ap.type = ::getFileType(realPath.c_str());
     if (ap.type == kFileTypeRegular) {
         ap.path = realPath;
     } else {
         ap.path = path;
-        ap.type = ::getFileType(path.string());
+        ap.type = ::getFileType(path.c_str());
         if (ap.type != kFileTypeDirectory && ap.type != kFileTypeRegular) {
             ALOGW("Asset path %s is neither a directory nor file (type=%d).",
-                 path.string(), (int)ap.type);
+                 path.c_str(), (int)ap.type);
             return false;
         }
     }
@@ -207,7 +207,7 @@ bool AssetManager::addAssetPath(
     }
 
     ALOGV("In %p Asset %s path: %s", this,
-         ap.type == kFileTypeDirectory ? "dir" : "zip", ap.path.string());
+         ap.type == kFileTypeDirectory ? "dir" : "zip", ap.path.c_str());
 
     ap.isSystemAsset = isSystemAsset;
     ssize_t apPos = mAssetPaths.add(ap);
@@ -248,7 +248,7 @@ bool AssetManager::addOverlayPath(const String8& packagePath, int32_t* cookie)
 
     Asset* idmap = NULL;
     if ((idmap = openAssetFromFileLocked(idmapPath, Asset::ACCESS_BUFFER)) == NULL) {
-        ALOGW("failed to open idmap file %s\n", idmapPath.string());
+        ALOGW("failed to open idmap file %s\n", idmapPath.c_str());
         return false;
     }
 
@@ -256,7 +256,7 @@ bool AssetManager::addOverlayPath(const String8& packagePath, int32_t* cookie)
     String8 overlayPath;
     if (!ResTable::getIdmapInfo(idmap->getBuffer(false), idmap->getLength(),
                 NULL, NULL, NULL, &targetPath, &overlayPath)) {
-        ALOGW("failed to read idmap file %s\n", idmapPath.string());
+        ALOGW("failed to read idmap file %s\n", idmapPath.c_str());
         delete idmap;
         return false;
     }
@@ -264,29 +264,29 @@ bool AssetManager::addOverlayPath(const String8& packagePath, int32_t* cookie)
 
     if (overlayPath != packagePath) {
         ALOGW("idmap file %s inconcistent: expected path %s does not match actual path %s\n",
-                idmapPath.string(), packagePath.string(), overlayPath.string());
+                idmapPath.c_str(), packagePath.c_str(), overlayPath.c_str());
         return false;
     }
-    if (access(targetPath.string(), R_OK) != 0) {
-        ALOGW("failed to access file %s: %s\n", targetPath.string(), strerror(errno));
+    if (access(targetPath.c_str(), R_OK) != 0) {
+        ALOGW("failed to access file %s: %s\n", targetPath.c_str(), strerror(errno));
         return false;
     }
-    if (access(idmapPath.string(), R_OK) != 0) {
-        ALOGW("failed to access file %s: %s\n", idmapPath.string(), strerror(errno));
+    if (access(idmapPath.c_str(), R_OK) != 0) {
+        ALOGW("failed to access file %s: %s\n", idmapPath.c_str(), strerror(errno));
         return false;
     }
-    if (access(overlayPath.string(), R_OK) != 0) {
-        ALOGW("failed to access file %s: %s\n", overlayPath.string(), strerror(errno));
+    if (access(overlayPath.c_str(), R_OK) != 0) {
+        ALOGW("failed to access file %s: %s\n", overlayPath.c_str(), strerror(errno));
         return false;
     }
 
     asset_path oap;
     oap.path = overlayPath;
-    oap.type = ::getFileType(overlayPath.string());
+    oap.type = ::getFileType(overlayPath.c_str());
     oap.idmap = idmapPath;
 #if 0
     ALOGD("Overlay added: targetPath=%s overlayPath=%s idmapPath=%s\n",
-            targetPath.string(), overlayPath.string(), idmapPath.string());
+            targetPath.c_str(), overlayPath.c_str(), idmapPath.c_str());
 #endif
     mAssetPaths.add(oap);
     *cookie = static_cast<int32_t>(mAssetPaths.size());
@@ -310,7 +310,7 @@ bool AssetManager::addAssetFd(
     ap.type = kFileTypeRegular;
     ap.assumeOwnership = assume_ownership;
 
-    ALOGV("In %p Asset fd %d name: %s", this, fd, ap.path.string());
+    ALOGV("In %p Asset fd %d name: %s", this, fd, ap.path.c_str());
 
     ssize_t apPos = mAssetPaths.add(ap);
 
@@ -343,11 +343,11 @@ bool AssetManager::createIdmap(const char* targetApkPath, const char* overlayApk
             assets[i] = openNonAssetInPathLocked("resources.arsc",
                     Asset::ACCESS_BUFFER, ap);
             if (assets[i] == NULL) {
-                ALOGW("failed to find resources.arsc in %s\n", ap.path.string());
+                ALOGW("failed to find resources.arsc in %s\n", ap.path.c_str());
                 goto exit;
             }
             if (tables[i].add(assets[i]) != NO_ERROR) {
-                ALOGW("failed to add %s to resource table", paths[i].string());
+                ALOGW("failed to add %s to resource table", paths[i].c_str());
                 goto exit;
             }
         }
@@ -449,8 +449,8 @@ Asset* AssetManager::open(const char* fileName, AccessMode mode)
     while (i > 0) {
         i--;
         ALOGV("Looking for asset '%s' in '%s'\n",
-                assetName.string(), mAssetPaths.itemAt(i).path.string());
-        Asset* pAsset = openNonAssetInPathLocked(assetName.string(), mode,
+                assetName.c_str(), mAssetPaths.itemAt(i).path.c_str());
+        Asset* pAsset = openNonAssetInPathLocked(assetName.c_str(), mode,
                 mAssetPaths.editItemAt(i));
         if (pAsset != NULL) {
             return pAsset != kExcludedAsset ? pAsset : NULL;
@@ -478,7 +478,7 @@ Asset* AssetManager::openNonAsset(const char* fileName, AccessMode mode, int32_t
     size_t i = mAssetPaths.size();
     while (i > 0) {
         i--;
-        ALOGV("Looking for non-asset '%s' in '%s'\n", fileName, mAssetPaths.itemAt(i).path.string());
+        ALOGV("Looking for non-asset '%s' in '%s'\n", fileName, mAssetPaths.itemAt(i).path.c_str());
         Asset* pAsset = openNonAssetInPathLocked(
             fileName, mode, mAssetPaths.editItemAt(i));
         if (pAsset != NULL) {
@@ -500,7 +500,7 @@ Asset* AssetManager::openNonAsset(const int32_t cookie, const char* fileName, Ac
 
     if (which < mAssetPaths.size()) {
         ALOGV("Looking for non-asset '%s' in '%s'\n", fileName,
-                mAssetPaths.itemAt(which).path.string());
+                mAssetPaths.itemAt(which).path.c_str());
         Asset* pAsset = openNonAssetInPathLocked(
             fileName, mode, mAssetPaths.editItemAt(which));
         if (pAsset != NULL) {
@@ -546,10 +546,10 @@ bool AssetManager::appendPathToResTable(asset_path& ap, bool appAsLib) const {
     ResTable* sharedRes = NULL;
     bool shared = true;
     bool onlyEmptyResources = true;
-    ATRACE_NAME(ap.path.string());
+    ATRACE_NAME(ap.path.c_str());
     Asset* idmap = openIdmapLocked(ap);
     size_t nextEntryIdx = mResources->getTableCount();
-    ALOGV("Looking for resource asset in '%s'\n", ap.path.string());
+    ALOGV("Looking for resource asset in '%s'\n", ap.path.c_str());
     if (ap.type != kFileTypeDirectory && ap.rawFd < 0) {
         if (nextEntryIdx == 0) {
             // The first item is typically the framework resources,
@@ -565,7 +565,7 @@ bool AssetManager::appendPathToResTable(asset_path& ap, bool appAsLib) const {
             ass = const_cast<AssetManager*>(this)->
                 mZipSet.getZipResourceTableAsset(ap.path);
             if (ass == NULL) {
-                ALOGV("loading resource table %s\n", ap.path.string());
+                ALOGV("loading resource table %s\n", ap.path.c_str());
                 ass = const_cast<AssetManager*>(this)->
                     openNonAssetInPathLocked("resources.arsc",
                                              Asset::ACCESS_BUFFER,
@@ -580,7 +580,7 @@ bool AssetManager::appendPathToResTable(asset_path& ap, bool appAsLib) const {
                 // If this is the first resource table in the asset
                 // manager, then we are going to cache it so that we
                 // can quickly copy it out for others.
-                ALOGV("Creating shared resources for %s", ap.path.string());
+                ALOGV("Creating shared resources for %s", ap.path.c_str());
                 sharedRes = new ResTable();
                 sharedRes->add(ass, idmap, nextEntryIdx + 1, false);
 #ifdef __ANDROID__
@@ -589,14 +589,14 @@ bool AssetManager::appendPathToResTable(asset_path& ap, bool appAsLib) const {
                 String8 overlaysListPath(data);
                 overlaysListPath.appendPath(kResourceCache);
                 overlaysListPath.appendPath("overlays.list");
-                addSystemOverlays(overlaysListPath.string(), ap.path, sharedRes, nextEntryIdx);
+                addSystemOverlays(overlaysListPath.c_str(), ap.path, sharedRes, nextEntryIdx);
 #endif
                 sharedRes = const_cast<AssetManager*>(this)->
                     mZipSet.setZipResourceTable(ap.path, sharedRes);
             }
         }
     } else {
-        ALOGV("loading resource table %s\n", ap.path.string());
+        ALOGV("loading resource table %s\n", ap.path.c_str());
         ass = const_cast<AssetManager*>(this)->
             openNonAssetInPathLocked("resources.arsc",
                                      Asset::ACCESS_BUFFER,
@@ -607,10 +607,10 @@ bool AssetManager::appendPathToResTable(asset_path& ap, bool appAsLib) const {
     if ((ass != NULL || sharedRes != NULL) && ass != kExcludedAsset) {
         ALOGV("Installing resource asset %p in to table %p\n", ass, mResources);
         if (sharedRes != NULL) {
-            ALOGV("Copying existing resources for %s", ap.path.string());
+            ALOGV("Copying existing resources for %s", ap.path.c_str());
             mResources->add(sharedRes, ap.isSystemAsset);
         } else {
-            ALOGV("Parsing resources for %s", ap.path.string());
+            ALOGV("Parsing resources for %s", ap.path.c_str());
             mResources->add(ass, idmap, nextEntryIdx + 1, !shared, appAsLib, ap.isSystemAsset);
         }
         onlyEmptyResources = false;
@@ -692,9 +692,9 @@ Asset* AssetManager::openIdmapLocked(const struct asset_path& ap) const
         ass = const_cast<AssetManager*>(this)->
             openAssetFromFileLocked(ap.idmap, Asset::ACCESS_BUFFER);
         if (ass) {
-            ALOGV("loading idmap %s\n", ap.idmap.string());
+            ALOGV("loading idmap %s\n", ap.idmap.c_str());
         } else {
-            ALOGW("failed to load idmap %s\n", ap.idmap.string());
+            ALOGW("failed to load idmap %s\n", ap.idmap.c_str());
         }
     }
     return ass;
@@ -812,7 +812,7 @@ Asset* AssetManager::openNonAssetInPathLocked(const char* fileName, AccessMode m
         ZipFileRO* pZip = getZipFileLocked(ap);
         if (pZip != NULL) {
             ALOGV("GOT zip, checking NA '%s'", (const char*) path);
-            ZipEntryRO entry = pZip->findEntryByName(path.string());
+            ZipEntryRO entry = pZip->findEntryByName(path.c_str());
             if (entry != NULL) {
                 ALOGV("FOUND NA in Zip file for %s", (const char*) path);
                 pAsset = openAssetFromZipLocked(pZip, entry, mode, path);
@@ -823,7 +823,7 @@ Asset* AssetManager::openNonAssetInPathLocked(const char* fileName, AccessMode m
         if (pAsset != NULL) {
             /* create a "source" name, for debug/display */
             pAsset->setAssetSource(
-                    createZipSourceNameLocked(ZipSet::getPathName(ap.path.string()), String8(""),
+                    createZipSourceNameLocked(ZipSet::getPathName(ap.path.c_str()), String8(""),
                                                 String8(fileName)));
         }
     }
@@ -870,7 +870,7 @@ ZipFileRO* AssetManager::getZipFileLocked(asset_path& ap)
     }
 
     if (ap.rawFd < 0) {
-        ALOGV("getZipFileLocked: Creating new zip from path %s", ap.path.string());
+        ALOGV("getZipFileLocked: Creating new zip from path %s", ap.path.c_str());
         ap.zip = mZipSet.getSharedZip(ap.path);
     } else {
         ALOGV("getZipFileLocked: Creating new zip from fd %d", ap.rawFd);
@@ -897,12 +897,12 @@ Asset* AssetManager::openAssetFromFileLocked(const String8& pathName,
 {
     Asset* pAsset = NULL;
 
-    if (strcasecmp(pathName.getPathExtension().string(), ".gz") == 0) {
+    if (strcasecmp(pathName.getPathExtension().c_str(), ".gz") == 0) {
         //printf("TRYING '%s'\n", (const char*) pathName);
-        pAsset = Asset::createFromCompressedFile(pathName.string(), mode);
+        pAsset = Asset::createFromCompressedFile(pathName.c_str(), mode);
     } else {
         //printf("TRYING '%s'\n", (const char*) pathName);
-        pAsset = Asset::createFromFile(pathName.string(), mode);
+        pAsset = Asset::createFromFile(pathName.c_str(), mode);
     }
 
     return pAsset;
@@ -940,12 +940,12 @@ Asset* AssetManager::openAssetFromZipLocked(const ZipFileRO* pZipFile,
 
     if (method == ZipFileRO::kCompressStored) {
         pAsset = Asset::createFromUncompressedMap(std::move(*dataMap), mode);
-        ALOGV("Opened uncompressed entry %s in zip %s mode %d: %p", entryName.string(),
+        ALOGV("Opened uncompressed entry %s in zip %s mode %d: %p", entryName.c_str(),
                 dataMap->file_name(), mode, pAsset.get());
     } else {
         pAsset = Asset::createFromCompressedMap(std::move(*dataMap),
             static_cast<size_t>(uncompressedLen), mode);
-        ALOGV("Opened compressed entry %s in zip %s mode %d: %p", entryName.string(),
+        ALOGV("Opened compressed entry %s in zip %s mode %d: %p", entryName.c_str(),
                 dataMap->file_name(), mode, pAsset.get());
     }
     if (pAsset == NULL) {
@@ -993,10 +993,10 @@ AssetDir* AssetManager::openDir(const char* dirName)
         i--;
         const asset_path& ap = mAssetPaths.itemAt(i);
         if (ap.type == kFileTypeRegular) {
-            ALOGV("Adding directory %s from zip %s", dirName, ap.path.string());
+            ALOGV("Adding directory %s from zip %s", dirName, ap.path.c_str());
             scanAndMergeZipLocked(pMergedInfo, ap, kAssetsRoot, dirName);
         } else {
-            ALOGV("Adding directory %s from dir %s", dirName, ap.path.string());
+            ALOGV("Adding directory %s from dir %s", dirName, ap.path.c_str());
             scanAndMergeDirLocked(pMergedInfo, ap, kAssetsRoot, dirName);
         }
     }
@@ -1042,10 +1042,10 @@ AssetDir* AssetManager::openNonAssetDir(const int32_t cookie, const char* dirNam
     if (which < mAssetPaths.size()) {
         const asset_path& ap = mAssetPaths.itemAt(which);
         if (ap.type == kFileTypeRegular) {
-            ALOGV("Adding directory %s from zip %s", dirName, ap.path.string());
+            ALOGV("Adding directory %s from zip %s", dirName, ap.path.c_str());
             scanAndMergeZipLocked(pMergedInfo, ap, NULL, dirName);
         } else {
-            ALOGV("Adding directory %s from dir %s", dirName, ap.path.string());
+            ALOGV("Adding directory %s from dir %s", dirName, ap.path.c_str());
             scanAndMergeDirLocked(pMergedInfo, ap, NULL, dirName);
         }
     }
@@ -1075,7 +1075,7 @@ bool AssetManager::scanAndMergeDirLocked(SortedVector<AssetDir::FileInfo>* pMerg
 {
     assert(pMergedInfo != NULL);
 
-    //printf("scanAndMergeDir: %s %s %s\n", ap.path.string(), rootDir, dirName);
+    //printf("scanAndMergeDir: %s %s %s\n", ap.path.c_str(), rootDir, dirName);
 
     String8 path = createPathNameLocked(ap, rootDir);
     if (dirName[0] != '\0')
@@ -1100,7 +1100,7 @@ bool AssetManager::scanAndMergeDirLocked(SortedVector<AssetDir::FileInfo>* pMerg
         const char* name;
         int nameLen;
 
-        name = pContents->itemAt(i).getFileName().string();
+        name = pContents->itemAt(i).getFileName().c_str();
         nameLen = strlen(name);
         if (nameLen > exclExtLen &&
             strcmp(name + (nameLen - exclExtLen), kExcludeExtension) == 0)
@@ -1111,8 +1111,8 @@ bool AssetManager::scanAndMergeDirLocked(SortedVector<AssetDir::FileInfo>* pMerg
             matchIdx = AssetDir::FileInfo::findEntry(pMergedInfo, match);
             if (matchIdx > 0) {
                 ALOGV("Excluding '%s' [%s]\n",
-                    pMergedInfo->itemAt(matchIdx).getFileName().string(),
-                    pMergedInfo->itemAt(matchIdx).getSourceName().string());
+                    pMergedInfo->itemAt(matchIdx).getFileName().c_str(),
+                    pMergedInfo->itemAt(matchIdx).getSourceName().c_str());
                 pMergedInfo->removeAt(matchIdx);
             } else {
                 //printf("+++ no match on '%s'\n", (const char*) match);
@@ -1150,9 +1150,9 @@ SortedVector<AssetDir::FileInfo>* AssetManager::scanDirLocked(const String8& pat
     struct dirent* entry;
     FileType fileType;
 
-    ALOGV("Scanning dir '%s'\n", path.string());
+    ALOGV("Scanning dir '%s'\n", path.c_str());
 
-    dir = opendir(path.string());
+    dir = opendir(path.c_str());
     if (dir == NULL)
         return NULL;
 
@@ -1176,7 +1176,7 @@ SortedVector<AssetDir::FileInfo>* AssetManager::scanDirLocked(const String8& pat
             fileType = kFileTypeUnknown;
 #else
         // stat the file
-        fileType = ::getFileType(path.appendPathCopy(entry->d_name).string());
+        fileType = ::getFileType(path.appendPathCopy(entry->d_name).c_str());
 #endif
 
         if (fileType != kFileTypeRegular && fileType != kFileTypeDirectory)
@@ -1184,7 +1184,7 @@ SortedVector<AssetDir::FileInfo>* AssetManager::scanDirLocked(const String8& pat
 
         AssetDir::FileInfo info;
         info.set(String8(entry->d_name), fileType);
-        if (strcasecmp(info.getFileName().getPathExtension().string(), ".gz") == 0)
+        if (strcasecmp(info.getFileName().getPathExtension().c_str(), ".gz") == 0)
             info.setFileName(info.getFileName().getBasePath());
         info.setSourceName(path.appendPathCopy(info.getFileName()));
         pContents->add(info);
@@ -1212,11 +1212,11 @@ bool AssetManager::scanAndMergeZipLocked(SortedVector<AssetDir::FileInfo>* pMerg
 
     pZip = mZipSet.getZip(ap.path);
     if (pZip == NULL) {
-        ALOGW("Failure opening zip %s\n", ap.path.string());
+        ALOGW("Failure opening zip %s\n", ap.path.c_str());
         return false;
     }
 
-    zipName = ZipSet::getPathName(ap.path.string());
+    zipName = ZipSet::getPathName(ap.path.c_str());
 
     /* convert "sounds" to "rootDir/sounds" */
     if (rootDir != NULL) dirName = rootDir;
@@ -1240,7 +1240,7 @@ bool AssetManager::scanAndMergeZipLocked(SortedVector<AssetDir::FileInfo>* pMerg
      */
     int dirNameLen = dirName.length();
     void *iterationCookie;
-    if (!pZip->startIteration(&iterationCookie, dirName.string(), NULL)) {
+    if (!pZip->startIteration(&iterationCookie, dirName.c_str(), NULL)) {
         ALOGW("ZipFileRO::startIteration returned false");
         return false;
     }
@@ -1254,7 +1254,7 @@ bool AssetManager::scanAndMergeZipLocked(SortedVector<AssetDir::FileInfo>* pMerg
             ALOGE("ARGH: name too long?\n");
             continue;
         }
-        //printf("Comparing %s in %s?\n", nameBuf, dirName.string());
+        //printf("Comparing %s in %s?\n", nameBuf, dirName.c_str());
         if (dirNameLen == 0 || nameBuf[dirNameLen] == '/')
         {
             const char* cp;
@@ -1275,7 +1275,7 @@ bool AssetManager::scanAndMergeZipLocked(SortedVector<AssetDir::FileInfo>* pMerg
                     createZipSourceNameLocked(zipName, dirName, info.getFileName()));
 
                 contents.add(info);
-                //printf("FOUND: file '%s'\n", info.getFileName().string());
+                //printf("FOUND: file '%s'\n", info.getFileName().c_str());
             } else {
                 /* this is a subdir; add it if we don't already have it*/
                 String8 subdirName(cp, nextSlash - cp);
@@ -1291,7 +1291,7 @@ bool AssetManager::scanAndMergeZipLocked(SortedVector<AssetDir::FileInfo>* pMerg
                     dirs.add(subdirName);
                 }
 
-                //printf("FOUND: dir '%s'\n", subdirName.string());
+                //printf("FOUND: dir '%s'\n", subdirName.c_str());
             }
         }
     }
@@ -1427,10 +1427,10 @@ AssetManager::SharedZip::SharedZip(const String8& path, time_t modWhen)
     if (kIsDebug) {
         ALOGI("Creating SharedZip %p %s\n", this, (const char*)mPath);
     }
-    ALOGV("+++ opening zip '%s'\n", mPath.string());
-    mZipFile = ZipFileRO::open(mPath.string());
+    ALOGV("+++ opening zip '%s'\n", mPath.c_str());
+    mZipFile = ZipFileRO::open(mPath.c_str());
     if (mZipFile == NULL) {
-        ALOGD("failed to open Zip archive '%s'\n", mPath.string());
+        ALOGD("failed to open Zip archive '%s'\n", mPath.c_str());
     }
 }
 
@@ -1441,11 +1441,11 @@ AssetManager::SharedZip::SharedZip(int fd, const String8& path)
     if (kIsDebug) {
         ALOGI("Creating SharedZip %p fd=%d %s\n", this, fd, (const char*)mPath);
     }
-    ALOGV("+++ opening zip fd=%d '%s'\n", fd, mPath.string());
-    mZipFile = ZipFileRO::openFd(fd, mPath.string());
+    ALOGV("+++ opening zip fd=%d '%s'\n", fd, mPath.c_str());
+    mZipFile = ZipFileRO::openFd(fd, mPath.c_str());
     if (mZipFile == NULL) {
         ::close(fd);
-        ALOGD("failed to open Zip archive fd=%d '%s'\n", fd, mPath.string());
+        ALOGD("failed to open Zip archive fd=%d '%s'\n", fd, mPath.c_str());
     }
 }
 
@@ -1520,7 +1520,7 @@ ResTable* AssetManager::SharedZip::setResourceTable(ResTable* res)
 
 bool AssetManager::SharedZip::isUpToDate()
 {
-    time_t modWhen = getFileModDate(mPath.string());
+    time_t modWhen = getFileModDate(mPath.c_str());
     return mModWhen == modWhen;
 }
 
@@ -1551,7 +1551,7 @@ AssetManager::SharedZip::~SharedZip()
     }
     if (mZipFile != NULL) {
         delete mZipFile;
-        ALOGV("Closed '%s'\n", mPath.string());
+        ALOGV("Closed '%s'\n", mPath.c_str());
     }
 }
 
diff --git a/libs/androidfw/BackupData.cpp b/libs/androidfw/BackupData.cpp
index 76a430ee9f0e..fec0e772674d 100644
--- a/libs/androidfw/BackupData.cpp
+++ b/libs/androidfw/BackupData.cpp
@@ -106,8 +106,8 @@ BackupDataWriter::WriteEntityHeader(const String8& key, size_t dataSize)
         k = key;
     }
     if (kIsDebug) {
-        ALOGD("Writing header: prefix='%s' key='%s' dataSize=%zu", m_keyPrefix.string(),
-                key.string(), dataSize);
+        ALOGD("Writing header: prefix='%s' key='%s' dataSize=%zu", m_keyPrefix.c_str(),
+                key.c_str(), dataSize);
     }
 
     entity_header_v1 header;
@@ -128,7 +128,7 @@ BackupDataWriter::WriteEntityHeader(const String8& key, size_t dataSize)
     m_pos += amt;
 
     if (kIsDebug) ALOGI("writing entity header key, %zd bytes", keyLen+1);
-    amt = write(m_fd, k.string(), keyLen+1);
+    amt = write(m_fd, k.c_str(), keyLen+1);
     if (amt != keyLen+1) {
         m_status = errno;
         return m_status;
diff --git a/libs/androidfw/BackupHelpers.cpp b/libs/androidfw/BackupHelpers.cpp
index e80e9486c8b2..35826090d6e5 100644
--- a/libs/androidfw/BackupHelpers.cpp
+++ b/libs/androidfw/BackupHelpers.cpp
@@ -179,7 +179,7 @@ write_snapshot_file(int fd, const KeyedVector<String8,FileRec>& snapshot)
             }
 
             // filename is not NULL terminated, but it is padded
-            amt = write(fd, name.string(), nameLen);
+            amt = write(fd, name.c_str(), nameLen);
             if (amt != nameLen) {
                 ALOGW("write_snapshot_file error writing filename %s", strerror(errno));
                 return 1;
@@ -203,7 +203,7 @@ write_snapshot_file(int fd, const KeyedVector<String8,FileRec>& snapshot)
 static int
 write_delete_file(BackupDataWriter* dataStream, const String8& key)
 {
-    LOGP("write_delete_file %s\n", key.string());
+    LOGP("write_delete_file %s\n", key.c_str());
     return dataStream->WriteEntityHeader(key, -1);
 }
 
@@ -211,7 +211,7 @@ static int
 write_update_file(BackupDataWriter* dataStream, int fd, int mode, const String8& key,
         char const* realFilename)
 {
-    LOGP("write_update_file %s (%s) : mode 0%o\n", realFilename, key.string(), mode);
+    LOGP("write_update_file %s (%s) : mode 0%o\n", realFilename, key.c_str(), mode);
 
     const int bufsize = 4*1024;
     int err;
@@ -365,7 +365,7 @@ back_up_files(int oldSnapshotFD, BackupDataWriter* dataStream, int newSnapshotFD
             r.s.size = st.st_size;
 
             if (newSnapshot.indexOfKey(key) >= 0) {
-                LOGP("back_up_files key already in use '%s'", key.string());
+                LOGP("back_up_files key already in use '%s'", key.c_str());
                 return -1;
             }
 
@@ -390,30 +390,30 @@ back_up_files(int oldSnapshotFD, BackupDataWriter* dataStream, int newSnapshotFD
         int cmp = p.compare(q);
         if (cmp < 0) {
             // file present in oldSnapshot, but not present in newSnapshot
-            LOGP("file removed: %s", p.string());
+            LOGP("file removed: %s", p.c_str());
             write_delete_file(dataStream, p);
             n++;
         } else if (cmp > 0) {
             // file added
-            LOGP("file added: %s crc=0x%08x", g.file.string(), g.s.crc32);
-            write_update_file(dataStream, q, g.file.string());
+            LOGP("file added: %s crc=0x%08x", g.file.c_str(), g.s.crc32);
+            write_update_file(dataStream, q, g.file.c_str());
             m++;
         } else {
             // same file exists in both old and new; check whether to update
             const FileState& f = oldSnapshot.valueAt(n);
 
-            LOGP("%s", q.string());
+            LOGP("%s", q.c_str());
             LOGP("  old: modTime=%d,%d mode=%04o size=%-3d crc32=0x%08x",
                     f.modTime_sec, f.modTime_nsec, f.mode, f.size, f.crc32);
             LOGP("  new: modTime=%d,%d mode=%04o size=%-3d crc32=0x%08x",
                     g.s.modTime_sec, g.s.modTime_nsec, g.s.mode, g.s.size, g.s.crc32);
             if (f.modTime_sec != g.s.modTime_sec || f.modTime_nsec != g.s.modTime_nsec
                     || f.mode != g.s.mode || f.size != g.s.size || f.crc32 != g.s.crc32) {
-                int fd = open(g.file.string(), O_RDONLY);
+                int fd = open(g.file.c_str(), O_RDONLY);
                 if (fd < 0) {
-                    ALOGE("Unable to read file for backup: %s", g.file.string());
+                    ALOGE("Unable to read file for backup: %s", g.file.c_str());
                 } else {
-                    write_update_file(dataStream, fd, g.s.mode, p, g.file.string());
+                    write_update_file(dataStream, fd, g.s.mode, p, g.file.c_str());
                     close(fd);
                 }
             }
@@ -432,7 +432,7 @@ back_up_files(int oldSnapshotFD, BackupDataWriter* dataStream, int newSnapshotFD
     while (m<M) {
         const String8& q = newSnapshot.keyAt(m);
         FileRec& g = newSnapshot.editValueAt(m);
-        write_update_file(dataStream, q, g.file.string());
+        write_update_file(dataStream, q, g.file.c_str());
         m++;
     }
 
@@ -483,7 +483,7 @@ int write_tarfile(const String8& packageName, const String8& domain,
         BackupDataWriter* writer)
 {
     // In the output stream everything is stored relative to the root
-    const char* relstart = filepath.string() + rootpath.length();
+    const char* relstart = filepath.c_str() + rootpath.length();
     if (*relstart == '/') relstart++;     // won't be true when path == rootpath
     String8 relpath(relstart);
 
@@ -514,9 +514,9 @@ int write_tarfile(const String8& packageName, const String8& domain,
 
     int err = 0;
     struct stat64 s;
-    if (lstat64(filepath.string(), &s) != 0) {
+    if (lstat64(filepath.c_str(), &s) != 0) {
         err = errno;
-        ALOGE("Error %d (%s) from lstat64(%s)", err, strerror(err), filepath.string());
+        ALOGE("Error %d (%s) from lstat64(%s)", err, strerror(err), filepath.c_str());
         return err;
     }
 
@@ -541,10 +541,10 @@ int write_tarfile(const String8& packageName, const String8& domain,
 
     // !!! TODO: use mmap when possible to avoid churning the buffer cache
     // !!! TODO: this will break with symlinks; need to use readlink(2)
-    int fd = open(filepath.string(), O_RDONLY);
+    int fd = open(filepath.c_str(), O_RDONLY);
     if (fd < 0) {
         err = errno;
-        ALOGE("Error %d (%s) from open(%s)", err, strerror(err), filepath.string());
+        ALOGE("Error %d (%s) from open(%s)", err, strerror(err), filepath.c_str());
         return err;
     }
 
@@ -592,7 +592,7 @@ int write_tarfile(const String8& packageName, const String8& domain,
     } else if (S_ISREG(s.st_mode)) {
         type = '0';     // tar magic: '0' == normal file
     } else {
-        ALOGW("Error: unknown file mode 0%o [%s]", s.st_mode, filepath.string());
+        ALOGW("Error: unknown file mode 0%o [%s]", s.st_mode, filepath.c_str());
         goto cleanup;
     }
     buf[156] = type;
@@ -620,16 +620,16 @@ int write_tarfile(const String8& packageName, const String8& domain,
         //    [ 345 : 155 ] filename path prefix
         // We only use the prefix area if fullname won't fit in the path
         if (fullname.length() > 100) {
-            strncpy(buf, relpath.string(), 100);
-            strncpy(buf + 345, prefix.string(), 155);
+            strncpy(buf, relpath.c_str(), 100);
+            strncpy(buf + 345, prefix.c_str(), 155);
         } else {
-            strncpy(buf, fullname.string(), 100);
+            strncpy(buf, fullname.c_str(), 100);
         }
     }
 
     // [ 329 : 8 ] and [ 337 : 8 ] devmajor/devminor, not used
 
-    ALOGI("   Name: %s", fullname.string());
+    ALOGI("   Name: %s", fullname.c_str());
 
     // If we're using a pax extended header, build & write that here; lengths are
     // already preflighted
@@ -647,7 +647,7 @@ int write_tarfile(const String8& packageName, const String8& domain,
 
         // fullname was generated above with the ustar paths
         paxLen += write_pax_header_entry(paxData + paxLen, PAXDATA_SIZE - paxLen,
-                "path", fullname.string());
+                "path", fullname.c_str());
 
         // Now we know how big the pax data is
 
@@ -656,9 +656,9 @@ int write_tarfile(const String8& packageName, const String8& domain,
 
         String8 leaf = fullname.getPathLeaf();
         memset(paxHeader, 0, 100);                  // rewrite the name area
-        snprintf(paxHeader, 100, "PaxHeader/%s", leaf.string());
+        snprintf(paxHeader, 100, "PaxHeader/%s", leaf.c_str());
         memset(paxHeader + 345, 0, 155);            // rewrite the prefix area
-        strncpy(paxHeader + 345, prefix.string(), 155);
+        strncpy(paxHeader + 345, prefix.c_str(), 155);
 
         paxHeader[156] = 'x';                       // mark it as a pax extended header
 
@@ -691,12 +691,12 @@ int write_tarfile(const String8& packageName, const String8& domain,
             ssize_t nRead = read(fd, buf, toRead);
             if (nRead < 0) {
                 err = errno;
-                ALOGE("Unable to read file [%s], err=%d (%s)", filepath.string(),
+                ALOGE("Unable to read file [%s], err=%d (%s)", filepath.c_str(),
                         err, strerror(err));
                 break;
             } else if (nRead == 0) {
                 ALOGE("EOF but expect %lld more bytes in [%s]", (long long) toWrite,
-                        filepath.string());
+                        filepath.c_str());
                 err = EIO;
                 break;
             }
@@ -762,7 +762,7 @@ RestoreHelperBase::WriteFile(const String8& filename, BackupDataReader* in)
     file_metadata_v1 metadata;
     amt = in->ReadEntityData(&metadata, sizeof(metadata));
     if (amt != sizeof(metadata)) {
-        ALOGW("Could not read metadata for %s -- %ld / %s", filename.string(),
+        ALOGW("Could not read metadata for %s -- %ld / %s", filename.c_str(),
                 (long)amt, strerror(errno));
         return EIO;
     }
@@ -779,9 +779,9 @@ RestoreHelperBase::WriteFile(const String8& filename, BackupDataReader* in)
 
     // Write the file and compute the crc
     crc = crc32(0L, Z_NULL, 0);
-    fd = open(filename.string(), O_CREAT|O_RDWR|O_TRUNC, mode);
+    fd = open(filename.c_str(), O_CREAT|O_RDWR|O_TRUNC, mode);
     if (fd == -1) {
-        ALOGW("Could not open file %s -- %s", filename.string(), strerror(errno));
+        ALOGW("Could not open file %s -- %s", filename.c_str(), strerror(errno));
         return errno;
     }
 
@@ -789,7 +789,7 @@ RestoreHelperBase::WriteFile(const String8& filename, BackupDataReader* in)
         err = write(fd, buf, amt);
         if (err != amt) {
             close(fd);
-            ALOGW("Error '%s' writing '%s'", strerror(errno), filename.string());
+            ALOGW("Error '%s' writing '%s'", strerror(errno), filename.c_str());
             return errno;
         }
         crc = crc32(crc, (Bytef*)buf, amt);
@@ -798,9 +798,9 @@ RestoreHelperBase::WriteFile(const String8& filename, BackupDataReader* in)
     close(fd);
 
     // Record for the snapshot
-    err = stat(filename.string(), &st);
+    err = stat(filename.c_str(), &st);
     if (err != 0) {
-        ALOGW("Error stating file that we just created %s", filename.string());
+        ALOGW("Error stating file that we just created %s", filename.c_str());
         return errno;
     }
 
@@ -1104,9 +1104,9 @@ backup_helper_test_four()
             fprintf(stderr, "state %zu expected={%d/%d, %04o, 0x%08x, 0x%08x, %3zu} '%s'\n"
                             "          actual={%d/%d, %04o, 0x%08x, 0x%08x, %3d} '%s'\n", i,
                     states[i].modTime_sec, states[i].modTime_nsec, states[i].mode, states[i].size,
-                    states[i].crc32, name.length(), filenames[i].string(),
+                    states[i].crc32, name.length(), filenames[i].c_str(),
                     state.modTime_sec, state.modTime_nsec, state.mode, state.size, state.crc32,
-                    state.nameLen, name.string());
+                    state.nameLen, name.c_str());
             matched = false;
         }
     }
@@ -1152,9 +1152,9 @@ test_write_header_and_entity(BackupDataWriter& writer, const char* str)
         return err;
     }
 
-    err = writer.WriteEntityData(text.string(), text.length()+1);
+    err = writer.WriteEntityData(text.c_str(), text.length()+1);
     if (err != 0) {
-        fprintf(stderr, "write failed for data '%s'\n", text.string());
+        fprintf(stderr, "write failed for data '%s'\n", text.c_str());
         return errno;
     }
 
@@ -1230,7 +1230,7 @@ test_read_header_and_entity(BackupDataReader& reader, const char* str)
         goto finished;
     }
     if (string != str) {
-        fprintf(stderr, "ReadEntityHeader expected key '%s' got '%s'\n", str, string.string());
+        fprintf(stderr, "ReadEntityHeader expected key '%s' got '%s'\n", str, string.c_str());
         err = EINVAL;
         goto finished;
     }
diff --git a/libs/androidfw/ConfigDescription.cpp b/libs/androidfw/ConfigDescription.cpp
index 19ead9583eb2..952101b1952c 100644
--- a/libs/androidfw/ConfigDescription.cpp
+++ b/libs/androidfw/ConfigDescription.cpp
@@ -878,7 +878,7 @@ std::string ConfigDescription::GetBcp47LanguageTag(bool canonicalize) const {
 
 std::string ConfigDescription::to_string() const {
   const String8 str = toString();
-  return std::string(str.string(), str.size());
+  return std::string(str.c_str(), str.size());
 }
 
 bool ConfigDescription::Dominates(const ConfigDescription& o) const {
diff --git a/libs/androidfw/CursorWindow.cpp b/libs/androidfw/CursorWindow.cpp
index 3527eeead1d5..5aa8e7006abb 100644
--- a/libs/androidfw/CursorWindow.cpp
+++ b/libs/androidfw/CursorWindow.cpp
@@ -84,7 +84,7 @@ status_t CursorWindow::maybeInflate() {
     String8 ashmemName("CursorWindow: ");
     ashmemName.append(mName);
 
-    ashmemFd = ashmem_create_region(ashmemName.string(), mInflatedSize);
+    ashmemFd = ashmem_create_region(ashmemName.c_str(), mInflatedSize);
     if (ashmemFd < 0) {
         PLOG(ERROR) << "Failed ashmem_create_region";
         goto fail_silent;
diff --git a/libs/androidfw/ObbFile.cpp b/libs/androidfw/ObbFile.cpp
index 95332a35eb7d..c6a9632ee7b7 100644
--- a/libs/androidfw/ObbFile.cpp
+++ b/libs/androidfw/ObbFile.cpp
@@ -217,7 +217,7 @@ bool ObbFile::parseObbFile(int fd)
     free(scanBuf);
 
 #ifdef DEBUG
-    ALOGI("Obb scan succeeded: packageName=%s, version=%d\n", mPackageName.string(), mVersion);
+    ALOGI("Obb scan succeeded: packageName=%s, version=%d\n", mPackageName.c_str(), mVersion);
 #endif
 
     return true;
@@ -288,7 +288,7 @@ bool ObbFile::writeTo(int fd)
         return false;
     }
 
-    if (write(fd, mPackageName.string(), packageNameLen) != (ssize_t)packageNameLen) {
+    if (write(fd, mPackageName.c_str(), packageNameLen) != (ssize_t)packageNameLen) {
         ALOGW("couldn't write package name: %s\n", strerror(errno));
         return false;
     }
diff --git a/libs/androidfw/ResourceTypes.cpp b/libs/androidfw/ResourceTypes.cpp
index 5e8a623d4205..0e7d8412e615 100644
--- a/libs/androidfw/ResourceTypes.cpp
+++ b/libs/androidfw/ResourceTypes.cpp
@@ -1029,7 +1029,7 @@ base::expected<size_t, NullOrIOError> ResStringPool::indexOfString(const char16_
 
     if ((mHeader->flags&ResStringPool_header::UTF8_FLAG) != 0) {
         if (kDebugStringPoolNoisy) {
-            ALOGI("indexOfString UTF-8: %s", String8(str, strLen).string());
+            ALOGI("indexOfString UTF-8: %s", String8(str, strLen).c_str());
         }
 
         // The string pool contains UTF 8 strings; we don't want to cause
@@ -1090,7 +1090,7 @@ base::expected<size_t, NullOrIOError> ResStringPool::indexOfString(const char16_
                         ALOGI("Looking at %s, i=%d\n", s->data(), i);
                     }
                     if (str8Len == s->size()
-                            && memcmp(s->data(), str8.string(), str8Len) == 0) {
+                            && memcmp(s->data(), str8.c_str(), str8Len) == 0) {
                         if (kDebugStringPoolNoisy) {
                             ALOGI("MATCH!");
                         }
@@ -1102,7 +1102,7 @@ base::expected<size_t, NullOrIOError> ResStringPool::indexOfString(const char16_
 
     } else {
         if (kDebugStringPoolNoisy) {
-            ALOGI("indexOfString UTF-16: %s", String8(str, strLen).string());
+            ALOGI("indexOfString UTF-16: %s", String8(str, strLen).c_str());
         }
 
         if (mHeader->flags&ResStringPool_header::SORTED_FLAG) {
@@ -1120,7 +1120,7 @@ base::expected<size_t, NullOrIOError> ResStringPool::indexOfString(const char16_
                 int c = s.has_value() ? strzcmp16(s->data(), s->size(), str, strLen) : -1;
                 if (kDebugStringPoolNoisy) {
                     ALOGI("Looking at %s, cmp=%d, l/mid/h=%d/%d/%d\n",
-                          String8(s->data(), s->size()).string(), c, (int)l, (int)mid, (int)h);
+                          String8(s->data(), s->size()).c_str(), c, (int)l, (int)mid, (int)h);
                 }
                 if (c == 0) {
                     if (kDebugStringPoolNoisy) {
@@ -1144,7 +1144,7 @@ base::expected<size_t, NullOrIOError> ResStringPool::indexOfString(const char16_
                     return base::unexpected(s.error());
                 }
                 if (kDebugStringPoolNoisy) {
-                    ALOGI("Looking at %s, i=%d\n", String8(s->data(), s->size()).string(), i);
+                    ALOGI("Looking at %s, i=%d\n", String8(s->data(), s->size()).c_str(), i);
                 }
                 if (s.has_value() && strLen == s->size() &&
                         strzcmp16(s->data(), s->size(), str, strLen) == 0) {
@@ -1512,8 +1512,8 @@ ssize_t ResXMLParser::indexOfAttribute(const char* ns, const char* attr) const
 {
     String16 nsStr(ns != NULL ? ns : "");
     String16 attrStr(attr);
-    return indexOfAttribute(ns ? nsStr.string() : NULL, ns ? nsStr.size() : 0,
-                            attrStr.string(), attrStr.size());
+    return indexOfAttribute(ns ? nsStr.c_str() : NULL, ns ? nsStr.size() : 0,
+                            attrStr.c_str(), attrStr.size());
 }
 
 ssize_t ResXMLParser::indexOfAttribute(const char16_t* ns, size_t nsLen,
@@ -1531,8 +1531,8 @@ ssize_t ResXMLParser::indexOfAttribute(const char16_t* ns, size_t nsLen,
             }
             attr8 = String8(attr, attrLen);
             if (kDebugStringPoolNoisy) {
-                ALOGI("indexOfAttribute UTF8 %s (%zu) / %s (%zu)", ns8.string(), nsLen,
-                        attr8.string(), attrLen);
+                ALOGI("indexOfAttribute UTF8 %s (%zu) / %s (%zu)", ns8.c_str(), nsLen,
+                        attr8.c_str(), attrLen);
             }
             for (size_t i=0; i<N; i++) {
                 size_t curNsLen = 0, curAttrLen = 0;
@@ -1542,7 +1542,7 @@ ssize_t ResXMLParser::indexOfAttribute(const char16_t* ns, size_t nsLen,
                     ALOGI("  curNs=%s (%zu), curAttr=%s (%zu)", curNs, curNsLen, curAttr, curAttrLen);
                 }
                 if (curAttr != NULL && curNsLen == nsLen && curAttrLen == attrLen
-                        && memcmp(attr8.string(), curAttr, attrLen) == 0) {
+                        && memcmp(attr8.c_str(), curAttr, attrLen) == 0) {
                     if (ns == NULL) {
                         if (curNs == NULL) {
                             if (kDebugStringPoolNoisy) {
@@ -1552,8 +1552,8 @@ ssize_t ResXMLParser::indexOfAttribute(const char16_t* ns, size_t nsLen,
                         }
                     } else if (curNs != NULL) {
                         //printf(" --> ns=%s, curNs=%s\n",
-                        //       String8(ns).string(), String8(curNs).string());
-                        if (memcmp(ns8.string(), curNs, nsLen) == 0) {
+                        //       String8(ns).c_str(), String8(curNs).c_str());
+                        if (memcmp(ns8.c_str(), curNs, nsLen) == 0) {
                             if (kDebugStringPoolNoisy) {
                                 ALOGI("  FOUND!");
                             }
@@ -1565,8 +1565,8 @@ ssize_t ResXMLParser::indexOfAttribute(const char16_t* ns, size_t nsLen,
         } else {
             if (kDebugStringPoolNoisy) {
                 ALOGI("indexOfAttribute UTF16 %s (%zu) / %s (%zu)",
-                        String8(ns, nsLen).string(), nsLen,
-                        String8(attr, attrLen).string(), attrLen);
+                        String8(ns, nsLen).c_str(), nsLen,
+                        String8(attr, attrLen).c_str(), attrLen);
             }
             for (size_t i=0; i<N; i++) {
                 size_t curNsLen = 0, curAttrLen = 0;
@@ -1574,8 +1574,8 @@ ssize_t ResXMLParser::indexOfAttribute(const char16_t* ns, size_t nsLen,
                 const char16_t* curAttr = getAttributeName(i, &curAttrLen);
                 if (kDebugStringPoolNoisy) {
                     ALOGI("  curNs=%s (%zu), curAttr=%s (%zu)",
-                            String8(curNs, curNsLen).string(), curNsLen,
-                            String8(curAttr, curAttrLen).string(), curAttrLen);
+                            String8(curNs, curNsLen).c_str(), curNsLen,
+                            String8(curAttr, curAttrLen).c_str(), curAttrLen);
                 }
                 if (curAttr != NULL && curNsLen == nsLen && curAttrLen == attrLen
                         && (memcmp(attr, curAttr, attrLen*sizeof(char16_t)) == 0)) {
@@ -1588,7 +1588,7 @@ ssize_t ResXMLParser::indexOfAttribute(const char16_t* ns, size_t nsLen,
                         }
                     } else if (curNs != NULL) {
                         //printf(" --> ns=%s, curNs=%s\n",
-                        //       String8(ns).string(), String8(curNs).string());
+                        //       String8(ns).c_str(), String8(curNs).c_str());
                         if (memcmp(ns, curNs, nsLen*sizeof(char16_t)) == 0) {
                             if (kDebugStringPoolNoisy) {
                                 ALOGI("  FOUND!");
@@ -4412,7 +4412,7 @@ bool ResTable::getResourceName(uint32_t resID, bool allowUtf8, resource_name* ou
         return false;
     }
 
-    outName->package = grp->name.string();
+    outName->package = grp->name.c_str();
     outName->packageLen = grp->name.size();
     if (allowUtf8) {
         outName->type8 = UnpackOptionalString(entry.typeStr.string8(), &outName->typeLen);
@@ -4518,7 +4518,7 @@ ssize_t ResTable::getResource(uint32_t resID, Res_value* outValue, bool mayBeBag
                 outValue->dataType,
                 outValue->dataType == Res_value::TYPE_STRING ?
                     String8(UnpackOptionalString(
-                        entry.package->header->values.stringAt(outValue->data), &len)).string() :
+                        entry.package->header->values.stringAt(outValue->data), &len)).c_str() :
                     "",
                 outValue->data);
     }
@@ -4888,7 +4888,7 @@ void ResTable::setParameters(const ResTable_config* params)
     AutoMutex _lock2(mFilteredConfigLock);
 
     if (kDebugTableGetEntry) {
-        ALOGI("Setting parameters: %s\n", params->toString().string());
+        ALOGI("Setting parameters: %s\n", params->toString().c_str());
     }
     mParams = *params;
     for (size_t p = 0; p < mPackageGroups.size(); p++) {
@@ -4999,7 +4999,7 @@ nope:
             if (name[1] == 'i' && name[2] == 'n'
                 && name[3] == 'd' && name[4] == 'e' && name[5] == 'x'
                 && name[6] == '_') {
-                int index = atoi(String8(name + 7, nameLen - 7).string());
+                int index = atoi(String8(name + 7, nameLen - 7).c_str());
                 if (Res_CHECKID(index)) {
                     ALOGW("Array resource index: %d is too large.",
                          index);
@@ -5065,9 +5065,9 @@ nope:
 
     if (kDebugTableNoisy) {
         printf("Looking for identifier: type=%s, name=%s, package=%s\n",
-                String8(type, typeLen).string(),
-                String8(name, nameLen).string(),
-                String8(package, packageLen).string());
+                String8(type, typeLen).c_str(),
+                String8(name, nameLen).c_str(),
+                String8(package, packageLen).c_str());
     }
 
     const String16 attr("attr");
@@ -5078,9 +5078,9 @@ nope:
         const PackageGroup* group = mPackageGroups[ig];
 
         if (strzcmp16(package, packageLen,
-                      group->name.string(), group->name.size())) {
+                      group->name.c_str(), group->name.size())) {
             if (kDebugTableNoisy) {
-                printf("Skipping package group: %s\n", String8(group->name).string());
+                printf("Skipping package group: %s\n", String8(group->name).c_str());
             }
             continue;
         }
@@ -5105,8 +5105,8 @@ nope:
                     }
                     return identifier;
                 }
-            } while (strzcmp16(attr.string(), attr.size(), targetType, targetTypeLen) == 0
-                    && (targetType = attrPrivate.string())
+            } while (strzcmp16(attr.c_str(), attr.size(), targetType, targetTypeLen) == 0
+                    && (targetType = attrPrivate.c_str())
                     && (targetTypeLen = attrPrivate.size())
             );
         }
@@ -5525,7 +5525,7 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
         }
     }
 
-    //printf("Value for: %s\n", String8(s, len).string());
+    //printf("Value for: %s\n", String8(s, len).c_str());
 
     uint32_t l10nReq = ResTable_map::L10N_NOT_REQUIRED;
     uint32_t attrMin = 0x80000000, attrMax = 0x7fffffff;
@@ -5580,7 +5580,7 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
         // be to any other type; we just need to count on the client making
         // sure the referenced type is correct.
 
-        //printf("Looking up ref: %s\n", String8(s, len).string());
+        //printf("Looking up ref: %s\n", String8(s, len).c_str());
 
         // It's a reference!
         if (len == 5 && s[1]=='n' && s[2]=='u' && s[3]=='l' && s[4]=='l') {
@@ -5620,8 +5620,8 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
             }
 
             uint32_t specFlags = 0;
-            uint32_t rid = identifierForName(name.string(), name.size(), type.string(),
-                    type.size(), package.string(), package.size(), &specFlags);
+            uint32_t rid = identifierForName(name.c_str(), name.size(), type.c_str(),
+                    type.size(), package.c_str(), package.size(), &specFlags);
             if (rid != 0) {
                 if (enforcePrivate) {
                     if (accessor == NULL || accessor->getAssetsPackage() != package) {
@@ -5640,8 +5640,8 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
                         Res_GETTYPE(rid), Res_GETENTRY(rid));
                     if (kDebugTableNoisy) {
                         ALOGI("Incl %s:%s/%s: 0x%08x\n",
-                                String8(package).string(), String8(type).string(),
-                                String8(name).string(), rid);
+                                String8(package).c_str(), String8(type).c_str(),
+                                String8(name).c_str(), rid);
                     }
                 }
 
@@ -5659,8 +5659,8 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
                 if (rid != 0) {
                     if (kDebugTableNoisy) {
                         ALOGI("Pckg %s:%s/%s: 0x%08x\n",
-                                String8(package).string(), String8(type).string(),
-                                String8(name).string(), rid);
+                                String8(package).c_str(), String8(type).c_str(),
+                                String8(name).c_str(), rid);
                     }
                     uint32_t packageId = Res_GETPACKAGE(rid) + 1;
                     if (packageId == 0x00) {
@@ -5749,7 +5749,7 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
                 }
             } else {
                 outValue->data = color;
-                //printf("Color input=%s, output=0x%x\n", String8(s, len).string(), color);
+                //printf("Color input=%s, output=0x%x\n", String8(s, len).c_str(), color);
                 return true;
             }
         } else {
@@ -5761,8 +5761,8 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
                 #if 0
                 fprintf(stderr, "%s: Color ID %s value %s is not valid\n",
                         "Resource File", //(const char*)in->getPrintableSource(),
-                        String8(*curTag).string(),
-                        String8(s, len).string());
+                        String8(*curTag).c_str(),
+                        String8(s, len).c_str());
                 #endif
                 return false;
             }
@@ -5776,7 +5776,7 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
         // be to any other type; we just need to count on the client making
         // sure the referenced type is correct.
 
-        //printf("Looking up attr: %s\n", String8(s, len).string());
+        //printf("Looking up attr: %s\n", String8(s, len).c_str());
 
         static const String16 attr16("attr");
         String16 package, type, name;
@@ -5789,13 +5789,13 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
         }
 
         //printf("Pkg: %s, Type: %s, Name: %s\n",
-        //       String8(package).string(), String8(type).string(),
-        //       String8(name).string());
+        //       String8(package).c_str(), String8(type).c_str(),
+        //       String8(name).c_str());
         uint32_t specFlags = 0;
         uint32_t rid =
-            identifierForName(name.string(), name.size(),
-                              type.string(), type.size(),
-                              package.string(), package.size(), &specFlags);
+            identifierForName(name.c_str(), name.size(),
+                              type.c_str(), type.size(),
+                              package.c_str(), package.size(), &specFlags);
         if (rid != 0) {
             if (enforcePrivate) {
                 if ((specFlags&ResTable_typeSpec::SPEC_PUBLIC) == 0) {
@@ -5953,8 +5953,8 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
                     if (getResourceName(bag->map.name.ident, false, &rname)) {
                         #if 0
                         printf("Matching %s against %s (0x%08x)\n",
-                               String8(s, len).string(),
-                               String8(rname.name, rname.nameLen).string(),
+                               String8(s, len).c_str(),
+                               String8(rname.name, rname.nameLen).c_str(),
                                bag->map.name.ident);
                         #endif
                         if (strzcmp16(s, len, rname.name, rname.nameLen) == 0) {
@@ -5997,7 +5997,7 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
                 while (pos < end && *pos != '|') {
                     pos++;
                 }
-                //printf("Looking for: %s\n", String8(start, pos-start).string());
+                //printf("Looking for: %s\n", String8(start, pos-start).c_str());
                 const bag_entry* bagi = bag;
                 ssize_t i;
                 for (i=0; i<cnt; i++, bagi++) {
@@ -6006,8 +6006,8 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
                         if (getResourceName(bagi->map.name.ident, false, &rname)) {
                             #if 0
                             printf("Matching %s against %s (0x%08x)\n",
-                                   String8(start,pos-start).string(),
-                                   String8(rname.name, rname.nameLen).string(),
+                                   String8(start,pos-start).c_str(),
+                                   String8(rname.name, rname.nameLen).c_str(),
                                    bagi->map.name.ident);
                             #endif
                             if (strzcmp16(start, pos-start, rname.name, rname.nameLen) == 0) {
@@ -6334,7 +6334,7 @@ void ResTable::getConfigurations(Vector<ResTable_config>* configs, bool ignoreMi
 }
 
 static bool compareString8AndCString(const String8& str, const char* cStr) {
-    return strcmp(str.string(), cStr) < 0;
+    return strcmp(str.c_str(), cStr) < 0;
 }
 
 void ResTable::getLocales(Vector<String8>* locales, bool includeSystemLocales,
@@ -6348,7 +6348,7 @@ void ResTable::getLocales(Vector<String8>* locales, bool includeSystemLocales,
         const auto endIter = locales->end();
 
         auto iter = std::lower_bound(beginIter, endIter, locale, compareString8AndCString);
-        if (iter == endIter || strcmp(iter->string(), locale) != 0) {
+        if (iter == endIter || strcmp(iter->c_str(), locale) != 0) {
             locales->insertAt(String8(locale), std::distance(beginIter, iter));
         }
     });
@@ -6940,7 +6940,7 @@ status_t ResTable::parsePackage(const ResTable_package* const pkg,
                         ResTable_config thisConfig;
                         thisConfig.copyFromDtoH(type->config);
                         ALOGI("Adding config to type %d: %s\n", type->id,
-                                thisConfig.toString().string());
+                                thisConfig.toString().c_str());
                     }
                 }
             } else {
@@ -7018,7 +7018,7 @@ status_t DynamicRefTable::load(const ResTable_lib_header* const header)
         char16_t tmpName[sizeof(entry->packageName) / sizeof(char16_t)];
         strcpy16_dtoh(tmpName, entry->packageName, sizeof(entry->packageName) / sizeof(char16_t));
         if (kDebugLibNoisy) {
-            ALOGV("Found lib entry %s with id %d\n", String8(tmpName).string(),
+            ALOGV("Found lib entry %s with id %d\n", String8(tmpName).c_str(),
                     dtohl(entry->packageId));
         }
         if (packageId >= 256) {
@@ -7300,7 +7300,7 @@ status_t ResTable::createIdmap(const ResTable& targetResTable,
                     current_res.nameLen,
                     current_res.type,
                     current_res.typeLen,
-                    targetPackageName.string(),
+                    targetPackageName.c_str(),
                     targetPackageName.size(),
                     &typeSpecFlags);
 
@@ -7407,7 +7407,7 @@ bool ResTable::getIdmapInfo(const void* idmap, size_t sizeBytes,
 }
 
 
-#define CHAR16_TO_CSTR(c16, len) (String8(String16(c16,len)).string())
+#define CHAR16_TO_CSTR(c16, len) (String8(String16(c16,len)).c_str())
 
 #define CHAR16_ARRAY_EQ(constant, var, len) \
         (((len) == (sizeof(constant)/sizeof((constant)[0]))) && (0 == memcmp((var), (constant), (len))))
@@ -7502,13 +7502,13 @@ void ResTable::print_value(const Package* pkg, const Res_value& value) const
         const char* str8 = UnpackOptionalString(pkg->header->values.string8At(
                 value.data), &len);
         if (str8 != NULL) {
-            printf("(string8) \"%s\"\n", normalizeForOutput(str8).string());
+            printf("(string8) \"%s\"\n", normalizeForOutput(str8).c_str());
         } else {
             const char16_t* str16 = UnpackOptionalString(pkg->header->values.stringAt(
                     value.data), &len);
             if (str16 != NULL) {
                 printf("(string16) \"%s\"\n",
-                    normalizeForOutput(String8(str16, len).string()).string());
+                    normalizeForOutput(String8(str16, len).c_str()).c_str());
             } else {
                 printf("(string) null\n");
             }
@@ -7549,7 +7549,7 @@ void ResTable::print(bool inclValues) const
         const PackageGroup* pg = mPackageGroups[pgIndex];
         printf("Package Group %d id=0x%02x packageCount=%d name=%s\n",
                 (int)pgIndex, pg->id, (int)pg->packages.size(),
-                String8(pg->name).string());
+                String8(pg->name).c_str());
 
         const KeyedVector<String16, uint8_t>& refEntries = pg->dynamicRefTable.entries();
         const size_t refEntryCount = refEntries.size();
@@ -7558,7 +7558,7 @@ void ResTable::print(bool inclValues) const
             for (size_t refIndex = 0; refIndex < refEntryCount; refIndex++) {
                 printf("    0x%02x -> %s\n",
                         refEntries.valueAt(refIndex),
-                        String8(refEntries.keyAt(refIndex)).string());
+                        String8(refEntries.keyAt(refIndex)).c_str());
             }
             printf("\n");
         }
@@ -7584,7 +7584,7 @@ void ResTable::print(bool inclValues) const
                 strcpy16_dtoh(tmpName, pkg->package->name,
                               sizeof(pkg->package->name)/sizeof(pkg->package->name[0]));
                 printf("  Package %d id=0x%02x name=%s\n", (int)pkgIndex,
-                        pkg->package->id, String8(tmpName).string());
+                        pkg->package->id, String8(tmpName).c_str());
             }
 
             for (size_t typeIndex = 0; typeIndex < pg->types.size(); typeIndex++) {
@@ -7626,7 +7626,7 @@ void ResTable::print(bool inclValues) const
                             printf("      spec resource 0x%08x %s:%s/%s: flags=0x%08x\n",
                                 resID,
                                 CHAR16_TO_CSTR(resName.package, resName.packageLen),
-                                type8.string(), name8.string(),
+                                type8.c_str(), name8.c_str(),
                                 dtohl(typeConfigs->typeSpecFlags[entryIndex]));
                         } else {
                             printf("      INVALID TYPE CONFIG FOR RESOURCE 0x%08x\n", resID);
@@ -7647,7 +7647,7 @@ void ResTable::print(bool inclValues) const
 
                     String8 configStr = thisConfig.toString();
                     printf("      config %s", configStr.size() > 0
-                            ? configStr.string() : "(default)");
+                            ? configStr.c_str() : "(default)");
                     if (type->flags != 0u) {
                         printf(" flags=0x%02x", type->flags);
                         if (type->flags & ResTable_type::FLAG_SPARSE) {
@@ -7712,7 +7712,7 @@ void ResTable::print(bool inclValues) const
                             }
                             printf("        resource 0x%08x %s:%s/%s: ", resID,
                                     CHAR16_TO_CSTR(resName.package, resName.packageLen),
-                                    type8.string(), name8.string());
+                                    type8.c_str(), name8.c_str());
                         } else {
                             printf("        INVALID RESOURCE 0x%08x: ", resID);
                         }
diff --git a/libs/androidfw/include/androidfw/Asset.h b/libs/androidfw/include/androidfw/Asset.h
index 19febcdee77e..f3776b5401f3 100644
--- a/libs/androidfw/include/androidfw/Asset.h
+++ b/libs/androidfw/include/androidfw/Asset.h
@@ -135,7 +135,7 @@ public:
      * This is NOT intended to be used for anything except debug output.
      * DO NOT try to parse this or use it to open a file.
      */
-    const char* getAssetSource(void) const { return mAssetSource.string(); }
+    const char* getAssetSource(void) const { return mAssetSource.c_str(); }
 
     /*
      * Create the asset from a file descriptor.
diff --git a/libs/androidfw/include/androidfw/ConfigDescription.h b/libs/androidfw/include/androidfw/ConfigDescription.h
index 61d10cd4e55b..1701f1b8bc0d 100644
--- a/libs/androidfw/include/androidfw/ConfigDescription.h
+++ b/libs/androidfw/include/androidfw/ConfigDescription.h
@@ -207,7 +207,7 @@ inline bool ConfigDescription::operator>(const ConfigDescription& o) const {
 
 inline ::std::ostream& operator<<(::std::ostream& out,
                                   const ConfigDescription& o) {
-  return out << o.toString().string();
+  return out << o.toString().c_str();
 }
 
 }  // namespace android
diff --git a/libs/androidfw/tests/BackupData_test.cpp b/libs/androidfw/tests/BackupData_test.cpp
index e25b616dcbd9..7d3a3411d81d 100644
--- a/libs/androidfw/tests/BackupData_test.cpp
+++ b/libs/androidfw/tests/BackupData_test.cpp
@@ -56,10 +56,10 @@ protected:
         mFilename.append(m_external_storage);
         mFilename.append(TEST_FILENAME);
 
-        ::unlink(mFilename.string());
-        int fd = ::open(mFilename.string(), O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
+        ::unlink(mFilename.c_str());
+        int fd = ::open(mFilename.c_str(), O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
         if (fd < 0) {
-            FAIL() << "Couldn't create " << mFilename.string() << " for writing";
+            FAIL() << "Couldn't create " << mFilename.c_str() << " for writing";
         }
         mKey1 = String8(KEY1);
         mKey2 = String8(KEY2);
@@ -72,7 +72,7 @@ protected:
 };
 
 TEST_F(BackupDataTest, WriteAndReadSingle) {
-  int fd = ::open(mFilename.string(), O_WRONLY);
+  int fd = ::open(mFilename.c_str(), O_WRONLY);
   BackupDataWriter* writer = new BackupDataWriter(fd);
 
   EXPECT_EQ(NO_ERROR, writer->WriteEntityHeader(mKey1, sizeof(DATA1)))
@@ -81,7 +81,7 @@ TEST_F(BackupDataTest, WriteAndReadSingle) {
           << "WriteEntityData returned an error";
 
   ::close(fd);
-  fd = ::open(mFilename.string(), O_RDONLY);
+  fd = ::open(mFilename.c_str(), O_RDONLY);
   BackupDataReader* reader = new BackupDataReader(fd);
   EXPECT_EQ(NO_ERROR, reader->Status())
           << "Reader ctor failed";
@@ -114,7 +114,7 @@ TEST_F(BackupDataTest, WriteAndReadSingle) {
 }
 
 TEST_F(BackupDataTest, WriteAndReadMultiple) {
-  int fd = ::open(mFilename.string(), O_WRONLY);
+  int fd = ::open(mFilename.c_str(), O_WRONLY);
   BackupDataWriter* writer = new BackupDataWriter(fd);
   writer->WriteEntityHeader(mKey1, sizeof(DATA1));
   writer->WriteEntityData(DATA1, sizeof(DATA1));
@@ -122,7 +122,7 @@ TEST_F(BackupDataTest, WriteAndReadMultiple) {
   writer->WriteEntityData(DATA2, sizeof(DATA2));
 
   ::close(fd);
-  fd = ::open(mFilename.string(), O_RDONLY);
+  fd = ::open(mFilename.c_str(), O_RDONLY);
   BackupDataReader* reader = new BackupDataReader(fd);
 
   bool done;
@@ -162,7 +162,7 @@ TEST_F(BackupDataTest, WriteAndReadMultiple) {
 }
 
 TEST_F(BackupDataTest, SkipEntity) {
-  int fd = ::open(mFilename.string(), O_WRONLY);
+  int fd = ::open(mFilename.c_str(), O_WRONLY);
   BackupDataWriter* writer = new BackupDataWriter(fd);
   writer->WriteEntityHeader(mKey1, sizeof(DATA1));
   writer->WriteEntityData(DATA1, sizeof(DATA1));
@@ -172,7 +172,7 @@ TEST_F(BackupDataTest, SkipEntity) {
   writer->WriteEntityData(DATA3, sizeof(DATA3));
 
   ::close(fd);
-  fd = ::open(mFilename.string(), O_RDONLY);
+  fd = ::open(mFilename.c_str(), O_RDONLY);
   BackupDataReader* reader = new BackupDataReader(fd);
 
   bool done;
@@ -217,14 +217,14 @@ TEST_F(BackupDataTest, SkipEntity) {
 }
 
 TEST_F(BackupDataTest, DeleteEntity) {
-  int fd = ::open(mFilename.string(), O_WRONLY);
+  int fd = ::open(mFilename.c_str(), O_WRONLY);
   BackupDataWriter* writer = new BackupDataWriter(fd);
   writer->WriteEntityHeader(mKey1, sizeof(DATA1));
   writer->WriteEntityData(DATA1, sizeof(DATA1));
   writer->WriteEntityHeader(mKey2, -1);
 
   ::close(fd);
-  fd = ::open(mFilename.string(), O_RDONLY);
+  fd = ::open(mFilename.c_str(), O_RDONLY);
   BackupDataReader* reader = new BackupDataReader(fd);
 
   bool done;
@@ -256,7 +256,7 @@ TEST_F(BackupDataTest, DeleteEntity) {
 }
 
 TEST_F(BackupDataTest, EneityAfterDelete) {
-  int fd = ::open(mFilename.string(), O_WRONLY);
+  int fd = ::open(mFilename.c_str(), O_WRONLY);
   BackupDataWriter* writer = new BackupDataWriter(fd);
   writer->WriteEntityHeader(mKey1, sizeof(DATA1));
   writer->WriteEntityData(DATA1, sizeof(DATA1));
@@ -265,7 +265,7 @@ TEST_F(BackupDataTest, EneityAfterDelete) {
   writer->WriteEntityData(DATA3, sizeof(DATA3));
 
   ::close(fd);
-  fd = ::open(mFilename.string(), O_RDONLY);
+  fd = ::open(mFilename.c_str(), O_RDONLY);
   BackupDataReader* reader = new BackupDataReader(fd);
 
   bool done;
@@ -317,7 +317,7 @@ TEST_F(BackupDataTest, EneityAfterDelete) {
 }
 
 TEST_F(BackupDataTest, OnlyDeleteEntities) {
-  int fd = ::open(mFilename.string(), O_WRONLY);
+  int fd = ::open(mFilename.c_str(), O_WRONLY);
   BackupDataWriter* writer = new BackupDataWriter(fd);
   writer->WriteEntityHeader(mKey1, -1);
   writer->WriteEntityHeader(mKey2, -1);
@@ -325,7 +325,7 @@ TEST_F(BackupDataTest, OnlyDeleteEntities) {
   writer->WriteEntityHeader(mKey4, -1);
 
   ::close(fd);
-  fd = ::open(mFilename.string(), O_RDONLY);
+  fd = ::open(mFilename.c_str(), O_RDONLY);
   BackupDataReader* reader = new BackupDataReader(fd);
 
   bool done;
@@ -385,13 +385,13 @@ TEST_F(BackupDataTest, OnlyDeleteEntities) {
 }
 
 TEST_F(BackupDataTest, ReadDeletedEntityData) {
-  int fd = ::open(mFilename.string(), O_WRONLY);
+  int fd = ::open(mFilename.c_str(), O_WRONLY);
   BackupDataWriter* writer = new BackupDataWriter(fd);
   writer->WriteEntityHeader(mKey1, -1);
   writer->WriteEntityHeader(mKey2, -1);
 
   ::close(fd);
-  fd = ::open(mFilename.string(), O_RDONLY);
+  fd = ::open(mFilename.c_str(), O_RDONLY);
   BackupDataReader* reader = new BackupDataReader(fd);
 
   bool done;
diff --git a/libs/androidfw/tests/CommonHelpers.cpp b/libs/androidfw/tests/CommonHelpers.cpp
index 3396729536a4..10138de0843c 100644
--- a/libs/androidfw/tests/CommonHelpers.cpp
+++ b/libs/androidfw/tests/CommonHelpers.cpp
@@ -60,7 +60,7 @@ const std::string& GetTestDataPath() {
 std::string GetStringFromPool(const ResStringPool* pool, uint32_t idx) {
   auto str = pool->string8ObjectAt(idx);
   CHECK(str.has_value()) << "failed to find string entry";
-  return std::string(str->string(), str->length());
+  return std::string(str->c_str(), str->length());
 }
 
 }  // namespace android
diff --git a/libs/androidfw/tests/ConfigDescription_test.cpp b/libs/androidfw/tests/ConfigDescription_test.cpp
index ce7f8054e2ca..727035714df3 100644
--- a/libs/androidfw/tests/ConfigDescription_test.cpp
+++ b/libs/androidfw/tests/ConfigDescription_test.cpp
@@ -50,10 +50,10 @@ TEST(ConfigDescriptionTest, ParseFailWhenQualifiersHaveTrailingDash) {
 TEST(ConfigDescriptionTest, ParseBasicQualifiers) {
   ConfigDescription config;
   EXPECT_TRUE(TestParse("", &config));
-  EXPECT_EQ(std::string(""), config.toString().string());
+  EXPECT_EQ(std::string(""), config.toString().c_str());
 
   EXPECT_TRUE(TestParse("fr-land", &config));
-  EXPECT_EQ(std::string("fr-land"), config.toString().string());
+  EXPECT_EQ(std::string("fr-land"), config.toString().c_str());
 
   EXPECT_TRUE(
       TestParse("mcc310-pl-sw720dp-normal-long-port-night-"
@@ -61,22 +61,22 @@ TEST(ConfigDescriptionTest, ParseBasicQualifiers) {
                 &config));
   EXPECT_EQ(std::string("mcc310-pl-sw720dp-normal-long-port-night-"
                         "xhdpi-keyssoft-qwerty-navexposed-nonav-v13"),
-            config.toString().string());
+            config.toString().c_str());
 }
 
 TEST(ConfigDescriptionTest, ParseLocales) {
   ConfigDescription config;
   EXPECT_TRUE(TestParse("en-rUS", &config));
-  EXPECT_EQ(std::string("en-rUS"), config.toString().string());
+  EXPECT_EQ(std::string("en-rUS"), config.toString().c_str());
 }
 
 TEST(ConfigDescriptionTest, ParseQualifierAddedInApi13) {
   ConfigDescription config;
   EXPECT_TRUE(TestParse("sw600dp", &config));
-  EXPECT_EQ(std::string("sw600dp-v13"), config.toString().string());
+  EXPECT_EQ(std::string("sw600dp-v13"), config.toString().c_str());
 
   EXPECT_TRUE(TestParse("sw600dp-v8", &config));
-  EXPECT_EQ(std::string("sw600dp-v13"), config.toString().string());
+  EXPECT_EQ(std::string("sw600dp-v13"), config.toString().c_str());
 }
 
 TEST(ConfigDescriptionTest, ParseCarAttribute) {
@@ -91,13 +91,13 @@ TEST(ConfigDescriptionTest, TestParsingRoundQualifier) {
   EXPECT_EQ(android::ResTable_config::SCREENROUND_YES,
             config.screenLayout2 & android::ResTable_config::MASK_SCREENROUND);
   EXPECT_EQ(SDK_MARSHMALLOW, config.sdkVersion);
-  EXPECT_EQ(std::string("round-v23"), config.toString().string());
+  EXPECT_EQ(std::string("round-v23"), config.toString().c_str());
 
   EXPECT_TRUE(TestParse("notround", &config));
   EXPECT_EQ(android::ResTable_config::SCREENROUND_NO,
             config.screenLayout2 & android::ResTable_config::MASK_SCREENROUND);
   EXPECT_EQ(SDK_MARSHMALLOW, config.sdkVersion);
-  EXPECT_EQ(std::string("notround-v23"), config.toString().string());
+  EXPECT_EQ(std::string("notround-v23"), config.toString().c_str());
 }
 
 TEST(ConfigDescriptionTest, TestWideColorGamutQualifier) {
@@ -106,13 +106,13 @@ TEST(ConfigDescriptionTest, TestWideColorGamutQualifier) {
   EXPECT_EQ(android::ResTable_config::WIDE_COLOR_GAMUT_YES,
             config.colorMode & android::ResTable_config::MASK_WIDE_COLOR_GAMUT);
   EXPECT_EQ(SDK_O, config.sdkVersion);
-  EXPECT_EQ(std::string("widecg-v26"), config.toString().string());
+  EXPECT_EQ(std::string("widecg-v26"), config.toString().c_str());
 
   EXPECT_TRUE(TestParse("nowidecg", &config));
   EXPECT_EQ(android::ResTable_config::WIDE_COLOR_GAMUT_NO,
             config.colorMode & android::ResTable_config::MASK_WIDE_COLOR_GAMUT);
   EXPECT_EQ(SDK_O, config.sdkVersion);
-  EXPECT_EQ(std::string("nowidecg-v26"), config.toString().string());
+  EXPECT_EQ(std::string("nowidecg-v26"), config.toString().c_str());
 }
 
 TEST(ConfigDescriptionTest, TestHdrQualifier) {
@@ -121,13 +121,13 @@ TEST(ConfigDescriptionTest, TestHdrQualifier) {
   EXPECT_EQ(android::ResTable_config::HDR_YES,
             config.colorMode & android::ResTable_config::MASK_HDR);
   EXPECT_EQ(SDK_O, config.sdkVersion);
-  EXPECT_EQ(std::string("highdr-v26"), config.toString().string());
+  EXPECT_EQ(std::string("highdr-v26"), config.toString().c_str());
 
   EXPECT_TRUE(TestParse("lowdr", &config));
   EXPECT_EQ(android::ResTable_config::HDR_NO,
             config.colorMode & android::ResTable_config::MASK_HDR);
   EXPECT_EQ(SDK_O, config.sdkVersion);
-  EXPECT_EQ(std::string("lowdr-v26"), config.toString().string());
+  EXPECT_EQ(std::string("lowdr-v26"), config.toString().c_str());
 }
 
 TEST(ConfigDescriptionTest, ParseVrAttribute) {
@@ -135,7 +135,7 @@ TEST(ConfigDescriptionTest, ParseVrAttribute) {
   EXPECT_TRUE(TestParse("vrheadset", &config));
   EXPECT_EQ(android::ResTable_config::UI_MODE_TYPE_VR_HEADSET, config.uiMode);
   EXPECT_EQ(SDK_O, config.sdkVersion);
-  EXPECT_EQ(std::string("vrheadset-v26"), config.toString().string());
+  EXPECT_EQ(std::string("vrheadset-v26"), config.toString().c_str());
 }
 
 static inline ConfigDescription ParseConfigOrDie(const android::StringPiece& str) {
diff --git a/libs/androidfw/tests/ObbFile_test.cpp b/libs/androidfw/tests/ObbFile_test.cpp
index 115112128636..ba818c4d7645 100644
--- a/libs/androidfw/tests/ObbFile_test.cpp
+++ b/libs/androidfw/tests/ObbFile_test.cpp
@@ -43,9 +43,9 @@ protected:
         mFileName.append(externalStorage);
         mFileName.append(TEST_FILENAME);
 
-        int fd = ::open(mFileName.string(), O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
+        int fd = ::open(mFileName.c_str(), O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
         if (fd < 0) {
-            FAIL() << "Couldn't create " << mFileName.string() << " for tests";
+            FAIL() << "Couldn't create " << mFileName.c_str() << " for tests";
         }
     }
 
@@ -69,17 +69,17 @@ TEST_F(ObbFileTest, WriteThenRead) {
     EXPECT_TRUE(mObbFile->setSalt(salt, SALT_SIZE))
             << "Salt should be successfully set";
 
-    EXPECT_TRUE(mObbFile->writeTo(mFileName.string()))
+    EXPECT_TRUE(mObbFile->writeTo(mFileName.c_str()))
             << "couldn't write to fake .obb file";
 
     mObbFile = new ObbFile();
 
-    EXPECT_TRUE(mObbFile->readFrom(mFileName.string()))
+    EXPECT_TRUE(mObbFile->readFrom(mFileName.c_str()))
             << "couldn't read from fake .obb file";
 
     EXPECT_EQ(versionNum, mObbFile->getVersion())
             << "version didn't come out the same as it went in";
-    const char* currentPackageName = mObbFile->getPackageName().string();
+    const char* currentPackageName = mObbFile->getPackageName().c_str();
     EXPECT_STREQ(packageName, currentPackageName)
             << "package name didn't come out the same as it went in";
 
diff --git a/libs/androidfw/tests/ResTable_test.cpp b/libs/androidfw/tests/ResTable_test.cpp
index 9aeb00c47e63..dc6dea9fe69c 100644
--- a/libs/androidfw/tests/ResTable_test.cpp
+++ b/libs/androidfw/tests/ResTable_test.cpp
@@ -57,7 +57,7 @@ TEST(ResTableTest, ShouldLoadSparseEntriesSuccessfully) {
   String16 name(u"com.android.sparse:integer/foo_9");
   uint32_t flags;
   uint32_t resid =
-      table.identifierForName(name.string(), name.size(), nullptr, 0, nullptr, 0, &flags);
+      table.identifierForName(name.c_str(), name.size(), nullptr, 0, nullptr, 0, &flags);
   ASSERT_NE(0u, resid);
 
   Res_value val;
@@ -91,8 +91,8 @@ TEST(ResTableTest, ResourceNameIsResolved) {
   String16 defPackage("com.android.basic");
   String16 testName("@string/test1");
   uint32_t resID =
-      table.identifierForName(testName.string(), testName.size(), 0, 0,
-                              defPackage.string(), defPackage.size());
+      table.identifierForName(testName.c_str(), testName.size(), 0, 0,
+                              defPackage.c_str(), defPackage.size());
   ASSERT_NE(uint32_t(0x00000000), resID);
   ASSERT_EQ(basic::R::string::test1, resID);
 }
diff --git a/libs/androidfw/tests/Split_test.cpp b/libs/androidfw/tests/Split_test.cpp
index 2c242dbd3e28..3d88577c078f 100644
--- a/libs/androidfw/tests/Split_test.cpp
+++ b/libs/androidfw/tests/Split_test.cpp
@@ -261,8 +261,8 @@ TEST_F(SplitTest, TestNewResourceIsAccessibleByName) {
   const String16 package("com.android.basic");
   ASSERT_EQ(
       R::string::test3,
-      table.identifierForName(name.string(), name.size(), type.string(),
-                              type.size(), package.string(), package.size()));
+      table.identifierForName(name.c_str(), name.size(), type.c_str(),
+                              type.size(), package.c_str(), package.size()));
 }
 
 }  // namespace
diff --git a/libs/androidfw/tests/TestHelpers.cpp b/libs/androidfw/tests/TestHelpers.cpp
index 10c0a4fc8316..c6f657c5d9a8 100644
--- a/libs/androidfw/tests/TestHelpers.cpp
+++ b/libs/androidfw/tests/TestHelpers.cpp
@@ -79,9 +79,9 @@ AssertionResult IsStringEqual(const ResTable& table, uint32_t resource_id,
   }
 
   if (String8(expected_str) != *actual_str) {
-    return AssertionFailure() << actual_str->string();
+    return AssertionFailure() << actual_str->c_str();
   }
-  return AssertionSuccess() << actual_str->string();
+  return AssertionSuccess() << actual_str->c_str();
 }
 
 }  // namespace android
diff --git a/tools/aapt/AaptAssets.cpp b/tools/aapt/AaptAssets.cpp
index 899d26818548..b94d14fd4b75 100644
--- a/tools/aapt/AaptAssets.cpp
+++ b/tools/aapt/AaptAssets.cpp
@@ -219,7 +219,7 @@ bool AaptLocaleValue::initFromFilterString(const String8& str) {
      if (numTags >= 1) {
          const String8& lang = parts[0];
          if (isAlpha(lang) && (lang.length() == 2 || lang.length() == 3)) {
-             setLanguage(lang.string());
+             setLanguage(lang.c_str());
              valid = true;
          }
      }
@@ -232,11 +232,11 @@ bool AaptLocaleValue::initFromFilterString(const String8& str) {
      const String8& part2 = parts[1];
      if ((part2.length() == 2 && isAlpha(part2)) ||
          (part2.length() == 3 && isNumber(part2))) {
-         setRegion(part2.string());
+         setRegion(part2.c_str());
      } else if (part2.length() == 4 && isAlpha(part2)) {
-         setScript(part2.string());
+         setScript(part2.c_str());
      } else if (part2.length() >= 4 && part2.length() <= 8) {
-         setVariant(part2.string());
+         setVariant(part2.c_str());
      } else {
          valid = false;
      }
@@ -249,9 +249,9 @@ bool AaptLocaleValue::initFromFilterString(const String8& str) {
      const String8& part3 = parts[2];
      if (((part3.length() == 2 && isAlpha(part3)) ||
          (part3.length() == 3 && isNumber(part3))) && script[0]) {
-         setRegion(part3.string());
+         setRegion(part3.c_str());
      } else if (part3.length() >= 4 && part3.length() <= 8) {
-         setVariant(part3.string());
+         setVariant(part3.c_str());
      } else {
          valid = false;
      }
@@ -262,7 +262,7 @@ bool AaptLocaleValue::initFromFilterString(const String8& str) {
 
      const String8& part4 = parts[3];
      if (part4.length() >= 4 && part4.length() <= 8) {
-         setVariant(part4.string());
+         setVariant(part4.c_str());
      } else {
          valid = false;
      }
@@ -310,7 +310,7 @@ int AaptLocaleValue::initFromDirName(const Vector<String8>& parts, const int sta
                     break;
                 default:
                     fprintf(stderr, "ERROR: Invalid BCP 47 tag in directory name %s\n",
-                            part.string());
+                            part.c_str());
                     return -1;
             }
         } else if (subtags.size() == 3) {
@@ -324,7 +324,7 @@ int AaptLocaleValue::initFromDirName(const Vector<String8>& parts, const int sta
             } else if (subtags[1].size() == 2 || subtags[1].size() == 3) {
                 setRegion(subtags[1]);
             } else {
-                fprintf(stderr, "ERROR: Invalid BCP 47 tag in directory name %s\n", part.string());
+                fprintf(stderr, "ERROR: Invalid BCP 47 tag in directory name %s\n", part.c_str());
                 return -1;
             }
 
@@ -341,14 +341,14 @@ int AaptLocaleValue::initFromDirName(const Vector<String8>& parts, const int sta
             setRegion(subtags[2]);
             setVariant(subtags[3]);
         } else {
-            fprintf(stderr, "ERROR: Invalid BCP 47 tag in directory name: %s\n", part.string());
+            fprintf(stderr, "ERROR: Invalid BCP 47 tag in directory name: %s\n", part.c_str());
             return -1;
         }
 
         return ++currentIndex;
     } else {
         if ((part.length() == 2 || part.length() == 3)
-               && isAlpha(part) && strcmp("car", part.string())) {
+               && isAlpha(part) && strcmp("car", part.c_str())) {
             setLanguage(part);
             if (++currentIndex == size) {
                 return size;
@@ -358,8 +358,8 @@ int AaptLocaleValue::initFromDirName(const Vector<String8>& parts, const int sta
         }
 
         part = parts[currentIndex];
-        if (part.string()[0] == 'r' && part.length() == 3) {
-            setRegion(part.string() + 1);
+        if (part.c_str()[0] == 'r' && part.length() == 3) {
+            setRegion(part.c_str() + 1);
             if (++currentIndex == size) {
                 return size;
             }
@@ -524,8 +524,8 @@ status_t AaptGroup::addFile(const sp<AaptFile>& file, const bool overwriteDuplic
     ssize_t index = mFiles.indexOfKey(file->getGroupEntry());
     if (index >= 0 && overwriteDuplicate) {
         fprintf(stderr, "warning: overwriting '%s' with '%s'\n",
-                mFiles[index]->getSourceFile().string(),
-                file->getSourceFile().string());
+                mFiles[index]->getSourceFile().c_str(),
+                file->getSourceFile().c_str());
         removeFile(index);
         index = -1;
     }
@@ -545,7 +545,7 @@ status_t AaptGroup::addFile(const sp<AaptFile>& file, const bool overwriteDuplic
     const sp<AaptFile>& originalFile = mFiles.valueAt(index);
     SourcePos(file->getSourceFile(), -1)
             .error("Duplicate file.\n%s: Original is here. %s",
-                   originalFile->getPrintableSource().string(),
+                   originalFile->getPrintableSource().c_str(),
                    (withoutVersion.version != 0) ? "The version qualifier may be implied." : "");
     return UNKNOWN_ERROR;
 }
@@ -557,21 +557,21 @@ void AaptGroup::removeFile(size_t index)
 
 void AaptGroup::print(const String8& prefix) const
 {
-    printf("%s%s\n", prefix.string(), getPath().string());
+    printf("%s%s\n", prefix.c_str(), getPath().c_str());
     const size_t N=mFiles.size();
     size_t i;
     for (i=0; i<N; i++) {
         sp<AaptFile> file = mFiles.valueAt(i);
         const AaptGroupEntry& e = file->getGroupEntry();
         if (file->hasData()) {
-            printf("%s  Gen: (%s) %d bytes\n", prefix.string(), e.toDirName(String8()).string(),
+            printf("%s  Gen: (%s) %d bytes\n", prefix.c_str(), e.toDirName(String8()).c_str(),
                     (int)file->getSize());
         } else {
-            printf("%s  Src: (%s) %s\n", prefix.string(), e.toDirName(String8()).string(),
-                    file->getPrintableSource().string());
+            printf("%s  Src: (%s) %s\n", prefix.c_str(), e.toDirName(String8()).c_str(),
+                    file->getPrintableSource().c_str());
         }
-        //printf("%s  File Group Entry: %s\n", prefix.string(),
-        //        file->getGroupEntry().toDirName(String8()).string());
+        //printf("%s  File Group Entry: %s\n", prefix.c_str(),
+        //        file->getGroupEntry().toDirName(String8()).c_str());
     }
 }
 
@@ -660,9 +660,9 @@ ssize_t AaptDir::slurpFullTree(Bundle* bundle, const String8& srcDir,
     {
         DIR* dir = NULL;
 
-        dir = opendir(srcDir.string());
+        dir = opendir(srcDir.c_str());
         if (dir == NULL) {
-            fprintf(stderr, "ERROR: opendir(%s): %s\n", srcDir.string(), strerror(errno));
+            fprintf(stderr, "ERROR: opendir(%s): %s\n", srcDir.c_str(), strerror(errno));
             return UNKNOWN_ERROR;
         }
 
@@ -676,7 +676,7 @@ ssize_t AaptDir::slurpFullTree(Bundle* bundle, const String8& srcDir,
             if (entry == NULL)
                 break;
 
-            if (isHidden(srcDir.string(), entry->d_name))
+            if (isHidden(srcDir.c_str(), entry->d_name))
                 continue;
 
             String8 name(entry->d_name);
@@ -701,8 +701,8 @@ ssize_t AaptDir::slurpFullTree(Bundle* bundle, const String8& srcDir,
         String8 pathName(srcDir);
         FileType type;
 
-        pathName.appendPath(fileNames[i].string());
-        type = getFileType(pathName.string());
+        pathName.appendPath(fileNames[i].c_str());
+        type = getFileType(pathName.c_str());
         if (type == kFileTypeDirectory) {
             sp<AaptDir> subdir;
             bool notAdded = false;
@@ -732,7 +732,7 @@ ssize_t AaptDir::slurpFullTree(Bundle* bundle, const String8& srcDir,
 
         } else {
             if (bundle->getVerbose())
-                printf("   (ignoring non-file/dir '%s')\n", pathName.string());
+                printf("   (ignoring non-file/dir '%s')\n", pathName.c_str());
         }
     }
 
@@ -745,7 +745,7 @@ status_t AaptDir::validate() const
     const size_t ND = mDirs.size();
     size_t i;
     for (i = 0; i < NF; i++) {
-        if (!validateFileName(mFiles.valueAt(i)->getLeaf().string())) {
+        if (!validateFileName(mFiles.valueAt(i)->getLeaf().c_str())) {
             SourcePos(mFiles.valueAt(i)->getPrintableSource(), -1).error(
                     "Invalid filename.  Unable to add.");
             return UNKNOWN_ERROR;
@@ -753,11 +753,11 @@ status_t AaptDir::validate() const
 
         size_t j;
         for (j = i+1; j < NF; j++) {
-            if (strcasecmp(mFiles.valueAt(i)->getLeaf().string(),
-                           mFiles.valueAt(j)->getLeaf().string()) == 0) {
+            if (strcasecmp(mFiles.valueAt(i)->getLeaf().c_str(),
+                           mFiles.valueAt(j)->getLeaf().c_str()) == 0) {
                 SourcePos(mFiles.valueAt(i)->getPrintableSource(), -1).error(
                         "File is case-insensitive equivalent to: %s",
-                        mFiles.valueAt(j)->getPrintableSource().string());
+                        mFiles.valueAt(j)->getPrintableSource().c_str());
                 return UNKNOWN_ERROR;
             }
 
@@ -766,18 +766,18 @@ status_t AaptDir::validate() const
         }
 
         for (j = 0; j < ND; j++) {
-            if (strcasecmp(mFiles.valueAt(i)->getLeaf().string(),
-                           mDirs.valueAt(j)->getLeaf().string()) == 0) {
+            if (strcasecmp(mFiles.valueAt(i)->getLeaf().c_str(),
+                           mDirs.valueAt(j)->getLeaf().c_str()) == 0) {
                 SourcePos(mFiles.valueAt(i)->getPrintableSource(), -1).error(
                         "File conflicts with dir from: %s",
-                        mDirs.valueAt(j)->getPrintableSource().string());
+                        mDirs.valueAt(j)->getPrintableSource().c_str());
                 return UNKNOWN_ERROR;
             }
         }
     }
 
     for (i = 0; i < ND; i++) {
-        if (!validateFileName(mDirs.valueAt(i)->getLeaf().string())) {
+        if (!validateFileName(mDirs.valueAt(i)->getLeaf().c_str())) {
             SourcePos(mDirs.valueAt(i)->getPrintableSource(), -1).error(
                     "Invalid directory name, unable to add.");
             return UNKNOWN_ERROR;
@@ -785,11 +785,11 @@ status_t AaptDir::validate() const
 
         size_t j;
         for (j = i+1; j < ND; j++) {
-            if (strcasecmp(mDirs.valueAt(i)->getLeaf().string(),
-                           mDirs.valueAt(j)->getLeaf().string()) == 0) {
+            if (strcasecmp(mDirs.valueAt(i)->getLeaf().c_str(),
+                           mDirs.valueAt(j)->getLeaf().c_str()) == 0) {
                 SourcePos(mDirs.valueAt(i)->getPrintableSource(), -1).error(
                         "Directory is case-insensitive equivalent to: %s",
-                        mDirs.valueAt(j)->getPrintableSource().string());
+                        mDirs.valueAt(j)->getPrintableSource().c_str());
                 return UNKNOWN_ERROR;
             }
         }
@@ -846,12 +846,12 @@ status_t AaptSymbols::applyJavaSymbols(const sp<AaptSymbols>& javaSymbols)
         const AaptSymbolEntry& entry = javaSymbols->mSymbols.valueAt(i);
         ssize_t pos = mSymbols.indexOfKey(name);
         if (pos < 0) {
-            entry.sourcePos.error("Symbol '%s' declared with <java-symbol> not defined\n", name.string());
+            entry.sourcePos.error("Symbol '%s' declared with <java-symbol> not defined\n", name.c_str());
             err = UNKNOWN_ERROR;
             continue;
         }
         //printf("**** setting symbol #%d/%d %s to isJavaSymbol=%d\n",
-        //        i, N, name.string(), entry.isJavaSymbol ? 1 : 0);
+        //        i, N, name.c_str(), entry.isJavaSymbol ? 1 : 0);
         mSymbols.editValueAt(pos).isJavaSymbol = entry.isJavaSymbol;
     }
 
@@ -862,11 +862,11 @@ status_t AaptSymbols::applyJavaSymbols(const sp<AaptSymbols>& javaSymbols)
         ssize_t pos = mNestedSymbols.indexOfKey(name);
         if (pos < 0) {
             SourcePos pos;
-            pos.error("Java symbol dir %s not defined\n", name.string());
+            pos.error("Java symbol dir %s not defined\n", name.c_str());
             err = UNKNOWN_ERROR;
             continue;
         }
-        //printf("**** applying java symbols in dir %s\n", name.string());
+        //printf("**** applying java symbols in dir %s\n", name.c_str());
         status_t myerr = mNestedSymbols.valueAt(pos)->applyJavaSymbols(symbols);
         if (myerr != NO_ERROR) {
             err = myerr;
@@ -1131,9 +1131,9 @@ ssize_t AaptAssets::slurpResourceTree(Bundle* bundle, const String8& srcDir)
 {
     ssize_t err = 0;
 
-    DIR* dir = opendir(srcDir.string());
+    DIR* dir = opendir(srcDir.c_str());
     if (dir == NULL) {
-        fprintf(stderr, "ERROR: opendir(%s): %s\n", srcDir.string(), strerror(errno));
+        fprintf(stderr, "ERROR: opendir(%s): %s\n", srcDir.c_str(), strerror(errno));
         return UNKNOWN_ERROR;
     }
 
@@ -1149,7 +1149,7 @@ ssize_t AaptAssets::slurpResourceTree(Bundle* bundle, const String8& srcDir)
             break;
         }
 
-        if (isHidden(srcDir.string(), entry->d_name)) {
+        if (isHidden(srcDir.c_str(), entry->d_name)) {
             continue;
         }
 
@@ -1160,7 +1160,7 @@ ssize_t AaptAssets::slurpResourceTree(Bundle* bundle, const String8& srcDir)
         String8 resType;
         bool b = group.initFromDirName(entry->d_name, &resType);
         if (!b) {
-            fprintf(stderr, "invalid resource directory name: %s %s\n", srcDir.string(),
+            fprintf(stderr, "invalid resource directory name: %s %s\n", srcDir.c_str(),
                     entry->d_name);
             err = -1;
             continue;
@@ -1168,7 +1168,7 @@ ssize_t AaptAssets::slurpResourceTree(Bundle* bundle, const String8& srcDir)
 
         if (bundle->getMaxResVersion() != NULL && group.getVersionString().length() != 0) {
             int maxResInt = atoi(bundle->getMaxResVersion());
-            const char *verString = group.getVersionString().string();
+            const char *verString = group.getVersionString().c_str();
             int dirVersionInt = atoi(verString + 1); // skip 'v' in version name
             if (dirVersionInt > maxResInt) {
               fprintf(stderr, "max res %d, skipping %s\n", maxResInt, entry->d_name);
@@ -1176,7 +1176,7 @@ ssize_t AaptAssets::slurpResourceTree(Bundle* bundle, const String8& srcDir)
             }
         }
 
-        FileType type = getFileType(subdirName.string());
+        FileType type = getFileType(subdirName.c_str());
 
         if (type == kFileTypeDirectory) {
             sp<AaptDir> dir = makeDir(resType);
@@ -1200,7 +1200,7 @@ ssize_t AaptAssets::slurpResourceTree(Bundle* bundle, const String8& srcDir)
             }
         } else {
             if (bundle->getVerbose()) {
-                fprintf(stderr, "   (ignoring file '%s')\n", subdirName.string());
+                fprintf(stderr, "   (ignoring file '%s')\n", subdirName.c_str());
             }
         }
     }
@@ -1248,7 +1248,7 @@ AaptAssets::slurpResourceZip(Bundle* /* bundle */, const char* filename)
         String8 remain;
         if (entryName.walkPath(&remain) == kResourceDir) {
             // these are the resources, pull their type out of the directory name
-            kind.initFromDirName(remain.walkPath().string(), &resType);
+            kind.initFromDirName(remain.walkPath().c_str(), &resType);
         } else {
             // these are untyped and don't have an AaptGroupEntry
         }
@@ -1263,7 +1263,7 @@ AaptAssets::slurpResourceZip(Bundle* /* bundle */, const char* filename)
         sp<AaptFile> file = new AaptFile(entryName, kind, resType);
         status_t err = dir->addLeafFile(entryName.getPathLeaf(), file);
         if (err != NO_ERROR) {
-            fprintf(stderr, "err=%s entryName=%s\n", strerror(err), entryName.string());
+            fprintf(stderr, "err=%s entryName=%s\n", strerror(err), entryName.c_str());
             count = err;
             goto bail;
         }
@@ -1273,7 +1273,7 @@ AaptAssets::slurpResourceZip(Bundle* /* bundle */, const char* filename)
         if (entryName == "AndroidManifest.xml") {
             printf("AndroidManifest.xml\n");
         }
-        printf("\n\nfile: %s\n", entryName.string());
+        printf("\n\nfile: %s\n", entryName.c_str());
 #endif
 
         size_t len = entry->getUncompressedLen();
@@ -1317,9 +1317,9 @@ status_t AaptAssets::filter(Bundle* bundle)
     uint32_t preferredDensity = 0;
     if (bundle->getPreferredDensity().size() > 0) {
         ResTable_config preferredConfig;
-        if (!AaptConfig::parseDensity(bundle->getPreferredDensity().string(), &preferredConfig)) {
+        if (!AaptConfig::parseDensity(bundle->getPreferredDensity().c_str(), &preferredConfig)) {
             fprintf(stderr, "Error parsing preferred density: %s\n",
-                    bundle->getPreferredDensity().string());
+                    bundle->getPreferredDensity().c_str());
             return UNKNOWN_ERROR;
         }
         preferredDensity = preferredConfig.density;
@@ -1332,11 +1332,11 @@ status_t AaptAssets::filter(Bundle* bundle)
     if (bundle->getVerbose()) {
         if (!reqFilter->isEmpty()) {
             printf("Applying required filter: %s\n",
-                    bundle->getConfigurations().string());
+                    bundle->getConfigurations().c_str());
         }
         if (preferredDensity > 0) {
             printf("Applying preferred density filter: %s\n",
-                    bundle->getPreferredDensity().string());
+                    bundle->getPreferredDensity().c_str());
         }
     }
 
@@ -1385,7 +1385,7 @@ status_t AaptAssets::filter(Bundle* bundle)
                 if (!reqFilter->match(config)) {
                     if (bundle->getVerbose()) {
                         printf("Pruning unneeded resource: %s\n",
-                                file->getPrintableSource().string());
+                                file->getPrintableSource().c_str());
                     }
                     grp->removeFile(k);
                     k--;
@@ -1453,7 +1453,7 @@ status_t AaptAssets::filter(Bundle* bundle)
                     if (bestDensity != config.density) {
                         if (bundle->getVerbose()) {
                             printf("Pruning unneeded resource: %s\n",
-                                    file->getPrintableSource().string());
+                                    file->getPrintableSource().c_str());
                         }
                         grp->removeFile(k);
                         k--;
@@ -1495,10 +1495,10 @@ status_t AaptAssets::applyJavaSymbols()
         ssize_t pos = mSymbols.indexOfKey(name);
         if (pos < 0) {
             SourcePos pos;
-            pos.error("Java symbol dir %s not defined\n", name.string());
+            pos.error("Java symbol dir %s not defined\n", name.c_str());
             return UNKNOWN_ERROR;
         }
-        //printf("**** applying java symbols in dir %s\n", name.string());
+        //printf("**** applying java symbols in dir %s\n", name.c_str());
         status_t err = mSymbols.valueAt(pos)->applyJavaSymbols(symbols);
         if (err != NO_ERROR) {
             return err;
@@ -1510,7 +1510,7 @@ status_t AaptAssets::applyJavaSymbols()
 
 bool AaptAssets::isJavaSymbol(const AaptSymbolEntry& sym, bool includePrivate) const {
     //printf("isJavaSymbol %s: public=%d, includePrivate=%d, isJavaSymbol=%d\n",
-    //        sym.name.string(), sym.isPublic ? 1 : 0, includePrivate ? 1 : 0,
+    //        sym.name.c_str(), sym.isPublic ? 1 : 0, includePrivate ? 1 : 0,
     //        sym.isJavaSymbol ? 1 : 0);
     if (!mHavePrivateSymbols) return true;
     if (sym.isPublic) return true;
@@ -1529,12 +1529,12 @@ status_t AaptAssets::buildIncludedResources(Bundle* bundle)
     const size_t packageIncludeCount = includes.size();
     for (size_t i = 0; i < packageIncludeCount; i++) {
         if (bundle->getVerbose()) {
-            printf("Including resources from package: %s\n", includes[i].string());
+            printf("Including resources from package: %s\n", includes[i].c_str());
         }
 
         if (!mIncludedAssets.addAssetPath(includes[i], NULL)) {
             fprintf(stderr, "ERROR: Asset package include '%s' not found.\n",
-                    includes[i].string());
+                    includes[i].c_str());
             return UNKNOWN_ERROR;
         }
     }
@@ -1543,12 +1543,12 @@ status_t AaptAssets::buildIncludedResources(Bundle* bundle)
     if (!featureOfBase.isEmpty()) {
         if (bundle->getVerbose()) {
             printf("Including base feature resources from package: %s\n",
-                    featureOfBase.string());
+                    featureOfBase.c_str());
         }
 
         if (!mIncludedAssets.addAssetPath(featureOfBase, NULL)) {
             fprintf(stderr, "ERROR: base feature package '%s' not found.\n",
-                    featureOfBase.string());
+                    featureOfBase.c_str());
             return UNKNOWN_ERROR;
         }
     }
@@ -1581,23 +1581,23 @@ void AaptAssets::print(const String8& prefix) const
     innerPrefix.append("  ");
     String8 innerInnerPrefix(innerPrefix);
     innerInnerPrefix.append("  ");
-    printf("%sConfigurations:\n", prefix.string());
+    printf("%sConfigurations:\n", prefix.c_str());
     const size_t N=mGroupEntries.size();
     for (size_t i=0; i<N; i++) {
         String8 cname = mGroupEntries.itemAt(i).toDirName(String8());
-        printf("%s %s\n", prefix.string(),
-                cname != "" ? cname.string() : "(default)");
+        printf("%s %s\n", prefix.c_str(),
+                cname != "" ? cname.c_str() : "(default)");
     }
 
-    printf("\n%sFiles:\n", prefix.string());
+    printf("\n%sFiles:\n", prefix.c_str());
     AaptDir::print(innerPrefix);
 
-    printf("\n%sResource Dirs:\n", prefix.string());
+    printf("\n%sResource Dirs:\n", prefix.c_str());
     const Vector<sp<AaptDir> >& resdirs = mResDirs;
     const size_t NR = resdirs.size();
     for (size_t i=0; i<NR; i++) {
         const sp<AaptDir>& d = resdirs.itemAt(i);
-        printf("%s  Type %s\n", prefix.string(), d->getLeaf().string());
+        printf("%s  Type %s\n", prefix.c_str(), d->getLeaf().c_str());
         d->print(innerInnerPrefix);
     }
 }
@@ -1631,7 +1631,7 @@ valid_symbol_name(const String8& symbol)
         NULL
     };
     const char*const* k = KEYWORDS;
-    const char*const s = symbol.string();
+    const char*const s = symbol.c_str();
     while (*k) {
         if (0 == strcmp(s, *k)) {
             return false;
diff --git a/tools/aapt/AaptAssets.h b/tools/aapt/AaptAssets.h
index eadd48a6c261..498fc4e38c8c 100644
--- a/tools/aapt/AaptAssets.h
+++ b/tools/aapt/AaptAssets.h
@@ -463,7 +463,7 @@ private:
         if (valid_symbol_name(symbol)) {
             return true;
         }
-        pos.error("invalid %s: '%s'\n", label, symbol.string());
+        pos.error("invalid %s: '%s'\n", label, symbol.c_str());
         return false;
     }
     AaptSymbolEntry& edit_symbol(const String8& symbol, const SourcePos* pos) {
diff --git a/tools/aapt/AaptConfig.cpp b/tools/aapt/AaptConfig.cpp
index 0aca45ea8d60..7578f79f792e 100644
--- a/tools/aapt/AaptConfig.cpp
+++ b/tools/aapt/AaptConfig.cpp
@@ -39,7 +39,7 @@ bool parse(const String8& str, ConfigDescription* out) {
     ssize_t index = 0;
     ssize_t localeIndex = 0;
     const ssize_t N = parts.size();
-    const char* part = parts[index].string();
+    const char* part = parts[index].c_str();
 
     if (str.length() == 0) {
         goto success;
@@ -50,7 +50,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseMnc(part, &config)) {
@@ -58,7 +58,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     // Locale spans a few '-' separators, so we let it
@@ -72,7 +72,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index >= N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseLayoutDirection(part, &config)) {
@@ -80,7 +80,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseSmallestScreenWidthDp(part, &config)) {
@@ -88,7 +88,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseScreenWidthDp(part, &config)) {
@@ -96,7 +96,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseScreenHeightDp(part, &config)) {
@@ -104,7 +104,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseScreenLayoutSize(part, &config)) {
@@ -112,7 +112,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseScreenLayoutLong(part, &config)) {
@@ -120,7 +120,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseScreenRound(part, &config)) {
@@ -128,7 +128,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseWideColorGamut(part, &config)) {
@@ -136,7 +136,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseHdr(part, &config)) {
@@ -144,7 +144,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseOrientation(part, &config)) {
@@ -152,7 +152,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseUiModeType(part, &config)) {
@@ -160,7 +160,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseUiModeNight(part, &config)) {
@@ -168,7 +168,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseDensity(part, &config)) {
@@ -176,7 +176,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseTouchscreen(part, &config)) {
@@ -184,7 +184,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseKeysHidden(part, &config)) {
@@ -192,7 +192,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseKeyboard(part, &config)) {
@@ -200,7 +200,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseNavHidden(part, &config)) {
@@ -208,7 +208,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseNavigation(part, &config)) {
@@ -216,7 +216,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseScreenSize(part, &config)) {
@@ -224,7 +224,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     if (parseVersion(part, &config)) {
@@ -232,7 +232,7 @@ bool parse(const String8& str, ConfigDescription* out) {
         if (index == N) {
             goto success;
         }
-        part = parts[index].string();
+        part = parts[index].c_str();
     }
 
     // Unrecognized.
@@ -773,8 +773,8 @@ bool parseScreenSize(const char* name, ResTable_config* out) {
     if (y == name || *y != 0) return false;
     String8 yName(x, y-x);
 
-    uint16_t w = (uint16_t)atoi(xName.string());
-    uint16_t h = (uint16_t)atoi(yName.string());
+    uint16_t w = (uint16_t)atoi(xName.c_str());
+    uint16_t h = (uint16_t)atoi(yName.c_str());
     if (w < h) {
         return false;
     }
@@ -805,7 +805,7 @@ bool parseSmallestScreenWidthDp(const char* name, ResTable_config* out) {
     String8 xName(name, x-name);
 
     if (out) {
-        out->smallestScreenWidthDp = (uint16_t)atoi(xName.string());
+        out->smallestScreenWidthDp = (uint16_t)atoi(xName.c_str());
     }
 
     return true;
@@ -827,7 +827,7 @@ bool parseScreenWidthDp(const char* name, ResTable_config* out) {
     String8 xName(name, x-name);
 
     if (out) {
-        out->screenWidthDp = (uint16_t)atoi(xName.string());
+        out->screenWidthDp = (uint16_t)atoi(xName.c_str());
     }
 
     return true;
@@ -849,7 +849,7 @@ bool parseScreenHeightDp(const char* name, ResTable_config* out) {
     String8 xName(name, x-name);
 
     if (out) {
-        out->screenHeightDp = (uint16_t)atoi(xName.string());
+        out->screenHeightDp = (uint16_t)atoi(xName.c_str());
     }
 
     return true;
@@ -875,7 +875,7 @@ bool parseVersion(const char* name, ResTable_config* out) {
     String8 sdkName(name, s-name);
 
     if (out) {
-        out->sdkVersion = (uint16_t)atoi(sdkName.string());
+        out->sdkVersion = (uint16_t)atoi(sdkName.c_str());
         out->minorVersion = 0;
     }
 
diff --git a/tools/aapt/AaptUtil.cpp b/tools/aapt/AaptUtil.cpp
index 293e144b71fe..e82860de578a 100644
--- a/tools/aapt/AaptUtil.cpp
+++ b/tools/aapt/AaptUtil.cpp
@@ -23,7 +23,7 @@ namespace AaptUtil {
 
 Vector<String8> split(const String8& str, const char sep) {
     Vector<String8> parts;
-    const char* p = str.string();
+    const char* p = str.c_str();
     const char* q;
 
     while (true) {
@@ -41,7 +41,7 @@ Vector<String8> split(const String8& str, const char sep) {
 
 Vector<String8> splitAndLowerCase(const String8& str, const char sep) {
     Vector<String8> parts;
-    const char* p = str.string();
+    const char* p = str.c_str();
     const char* q;
 
     while (true) {
diff --git a/tools/aapt/ApkBuilder.cpp b/tools/aapt/ApkBuilder.cpp
index 01e02e270b63..335c43b96599 100644
--- a/tools/aapt/ApkBuilder.cpp
+++ b/tools/aapt/ApkBuilder.cpp
@@ -36,7 +36,7 @@ status_t ApkBuilder::createSplitForConfigs(const std::set<ConfigDescription>& co
             if (splitConfigs.count(*iter) > 0) {
                 // Can't have overlapping configurations.
                 fprintf(stderr, "ERROR: Split configuration '%s' is already defined "
-                        "in another split.\n", iter->toString().string());
+                        "in another split.\n", iter->toString().c_str());
                 return ALREADY_EXISTS;
             }
         }
@@ -115,10 +115,10 @@ status_t ApkSplit::addEntry(const String8& path, const sp<AaptFile>& file) {
 }
 
 void ApkSplit::print() const {
-    fprintf(stderr, "APK Split '%s'\n", mName.string());
+    fprintf(stderr, "APK Split '%s'\n", mName.c_str());
 
     std::set<OutputEntry>::const_iterator iter = mFiles.begin();
     for (; iter != mFiles.end(); iter++) {
-        fprintf(stderr, "  %s (%s)\n", iter->getPath().string(), iter->getFile()->getSourceFile().string());
+        fprintf(stderr, "  %s (%s)\n", iter->getPath().c_str(), iter->getFile()->getSourceFile().c_str());
     }
 }
diff --git a/tools/aapt/CacheUpdater.h b/tools/aapt/CacheUpdater.h
index 6fa96d67e6a3..2dc143c6a66d 100644
--- a/tools/aapt/CacheUpdater.h
+++ b/tools/aapt/CacheUpdater.h
@@ -66,7 +66,7 @@ public:
         // Check optomistically to see if all directories exist.
         // If something in the path doesn't exist, then walk the path backwards
         // and find the place to start creating directories forward.
-        if (stat(path.string(),&s) == -1) {
+        if (stat(path.c_str(),&s) == -1) {
             // Walk backwards to find place to start creating directories
             existsPath = path;
             do {
@@ -74,7 +74,7 @@ public:
                 // the string of paths to create.
                 toCreate = existsPath.getPathLeaf().appendPath(toCreate);
                 existsPath = existsPath.getPathDir();
-            } while (stat(existsPath.string(),&s) == -1);
+            } while (stat(existsPath.c_str(),&s) == -1);
 
             // Walk forwards and build directories as we go
             do {
@@ -82,9 +82,9 @@ public:
                 existsPath.appendPath(toCreate.walkPath(&remains));
                 toCreate = remains;
 #ifdef _WIN32
-                _mkdir(existsPath.string());
+                _mkdir(existsPath.c_str());
 #else
-                mkdir(existsPath.string(), S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP);
+                mkdir(existsPath.c_str(), S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP);
 #endif
             } while (remains.length() > 0);
         } //if
@@ -93,8 +93,8 @@ public:
     // Delete a file
     virtual void deleteFile(String8 path)
     {
-        if (remove(path.string()) != 0)
-            fprintf(stderr,"ERROR DELETING %s\n",path.string());
+        if (remove(path.c_str()) != 0)
+            fprintf(stderr,"ERROR DELETING %s\n",path.c_str());
     };
 
     // Process an image from source out to dest
diff --git a/tools/aapt/Command.cpp b/tools/aapt/Command.cpp
index 51cf38bce64e..5a06b102592a 100644
--- a/tools/aapt/Command.cpp
+++ b/tools/aapt/Command.cpp
@@ -240,13 +240,13 @@ static void printResolvedResourceAttribute(const ResTable& resTable, const ResXM
     }
     if (value.dataType == Res_value::TYPE_STRING) {
         String8 result = AaptXml::getResolvedAttribute(resTable, tree, attrRes, outError);
-        printf("%s='%s'", attrLabel.string(),
-                ResTable::normalizeForOutput(result.string()).string());
+        printf("%s='%s'", attrLabel.c_str(),
+                ResTable::normalizeForOutput(result.c_str()).c_str());
     } else if (Res_value::TYPE_FIRST_INT <= value.dataType &&
             value.dataType <= Res_value::TYPE_LAST_INT) {
-        printf("%s='%d'", attrLabel.string(), value.data);
+        printf("%s='%d'", attrLabel.c_str(), value.data);
     } else {
-        printf("%s='0x%x'", attrLabel.string(), (int)value.data);
+        printf("%s='0x%x'", attrLabel.c_str(), (int)value.data);
     }
 }
 
@@ -355,21 +355,21 @@ static void printCompatibleScreens(ResXMLTree& tree, String8* outError) {
 static void printUsesPermission(const String8& name, bool optional=false, int maxSdkVersion=-1,
         const String8& requiredFeature = String8::empty(),
         const String8& requiredNotFeature = String8::empty()) {
-    printf("uses-permission: name='%s'", ResTable::normalizeForOutput(name.string()).string());
+    printf("uses-permission: name='%s'", ResTable::normalizeForOutput(name.c_str()).c_str());
     if (maxSdkVersion != -1) {
          printf(" maxSdkVersion='%d'", maxSdkVersion);
     }
     if (requiredFeature.length() > 0) {
-         printf(" requiredFeature='%s'", requiredFeature.string());
+         printf(" requiredFeature='%s'", requiredFeature.c_str());
     }
     if (requiredNotFeature.length() > 0) {
-         printf(" requiredNotFeature='%s'", requiredNotFeature.string());
+         printf(" requiredNotFeature='%s'", requiredNotFeature.c_str());
     }
     printf("\n");
 
     if (optional) {
         printf("optional-permission: name='%s'",
-                ResTable::normalizeForOutput(name.string()).string());
+                ResTable::normalizeForOutput(name.c_str()).c_str());
         if (maxSdkVersion != -1) {
             printf(" maxSdkVersion='%d'", maxSdkVersion);
         }
@@ -380,7 +380,7 @@ static void printUsesPermission(const String8& name, bool optional=false, int ma
 static void printUsesPermissionSdk23(const String8& name, int maxSdkVersion=-1) {
     printf("uses-permission-sdk-23: ");
 
-    printf("name='%s'", ResTable::normalizeForOutput(name.string()).string());
+    printf("name='%s'", ResTable::normalizeForOutput(name.c_str()).c_str());
     if (maxSdkVersion != -1) {
         printf(" maxSdkVersion='%d'", maxSdkVersion);
     }
@@ -390,11 +390,11 @@ static void printUsesPermissionSdk23(const String8& name, int maxSdkVersion=-1)
 static void printUsesImpliedPermission(const String8& name, const String8& reason,
         const int32_t maxSdkVersion = -1) {
     printf("uses-implied-permission: name='%s'",
-            ResTable::normalizeForOutput(name.string()).string());
+            ResTable::normalizeForOutput(name.c_str()).c_str());
     if (maxSdkVersion != -1) {
         printf(" maxSdkVersion='%d'", maxSdkVersion);
     }
-    printf(" reason='%s'\n", ResTable::normalizeForOutput(reason.string()).string());
+    printf(" reason='%s'\n", ResTable::normalizeForOutput(reason.c_str()).c_str());
 }
 
 Vector<String8> getNfcAidCategories(AssetManager& assets, const String8& xmlPath, bool offHost,
@@ -556,7 +556,7 @@ static void addImpliedFeature(KeyedVector<String8, ImpliedFeature>* impliedFeatu
 
 static void printFeatureGroupImpl(const FeatureGroup& grp,
                                   const KeyedVector<String8, ImpliedFeature>* impliedFeatures) {
-    printf("feature-group: label='%s'\n", grp.label.string());
+    printf("feature-group: label='%s'\n", grp.label.c_str());
 
     if (grp.openGLESVersion > 0) {
         printf("  uses-gl-es: '0x%x'\n", grp.openGLESVersion);
@@ -570,7 +570,7 @@ static void printFeatureGroupImpl(const FeatureGroup& grp,
 
         const String8& featureName = grp.features.keyAt(i);
         printf("  uses-feature%s: name='%s'", (required ? "" : "-not-required"),
-                ResTable::normalizeForOutput(featureName.string()).string());
+                ResTable::normalizeForOutput(featureName.c_str()).c_str());
 
         if (version > 0) {
             printf(" version='%d'", version);
@@ -589,15 +589,15 @@ static void printFeatureGroupImpl(const FeatureGroup& grp,
         }
 
         String8 printableFeatureName(ResTable::normalizeForOutput(
-                    impliedFeature.name.string()));
+                    impliedFeature.name.c_str()));
         const char* sdk23Suffix = impliedFeature.impliedBySdk23 ? "-sdk-23" : "";
 
-        printf("  uses-feature%s: name='%s'\n", sdk23Suffix, printableFeatureName.string());
+        printf("  uses-feature%s: name='%s'\n", sdk23Suffix, printableFeatureName.c_str());
         printf("  uses-implied-feature%s: name='%s' reason='", sdk23Suffix,
-               printableFeatureName.string());
+               printableFeatureName.c_str());
         const size_t numReasons = impliedFeature.reasons.size();
         for (size_t j = 0; j < numReasons; j++) {
-            printf("%s", impliedFeature.reasons[j].string());
+            printf("%s", impliedFeature.reasons[j].c_str());
             if (j + 2 < numReasons) {
                 printf(", ");
             } else if (j + 1 < numReasons) {
@@ -649,43 +649,43 @@ static void addImpliedFeaturesForPermission(const int targetSdk, const String8&
                                             bool impliedBySdk23Permission) {
     if (name == "android.permission.CAMERA") {
         addImpliedFeature(impliedFeatures, "android.hardware.camera",
-                          String8::format("requested %s permission", name.string()),
+                          String8::format("requested %s permission", name.c_str()),
                           impliedBySdk23Permission);
     } else if (name == "android.permission.ACCESS_FINE_LOCATION") {
         if (targetSdk < SDK_LOLLIPOP) {
             addImpliedFeature(impliedFeatures, "android.hardware.location.gps",
-                              String8::format("requested %s permission", name.string()),
+                              String8::format("requested %s permission", name.c_str()),
                               impliedBySdk23Permission);
             addImpliedFeature(impliedFeatures, "android.hardware.location.gps",
                               String8::format("targetSdkVersion < %d", SDK_LOLLIPOP),
                               impliedBySdk23Permission);
         }
         addImpliedFeature(impliedFeatures, "android.hardware.location",
-                String8::format("requested %s permission", name.string()),
+                String8::format("requested %s permission", name.c_str()),
                 impliedBySdk23Permission);
     } else if (name == "android.permission.ACCESS_COARSE_LOCATION") {
         if (targetSdk < SDK_LOLLIPOP) {
             addImpliedFeature(impliedFeatures, "android.hardware.location.network",
-                              String8::format("requested %s permission", name.string()),
+                              String8::format("requested %s permission", name.c_str()),
                               impliedBySdk23Permission);
             addImpliedFeature(impliedFeatures, "android.hardware.location.network",
                               String8::format("targetSdkVersion < %d", SDK_LOLLIPOP),
                               impliedBySdk23Permission);
         }
         addImpliedFeature(impliedFeatures, "android.hardware.location",
-                          String8::format("requested %s permission", name.string()),
+                          String8::format("requested %s permission", name.c_str()),
                           impliedBySdk23Permission);
     } else if (name == "android.permission.ACCESS_MOCK_LOCATION" ||
                name == "android.permission.ACCESS_LOCATION_EXTRA_COMMANDS" ||
                name == "android.permission.INSTALL_LOCATION_PROVIDER") {
         addImpliedFeature(impliedFeatures, "android.hardware.location",
-                          String8::format("requested %s permission", name.string()),
+                          String8::format("requested %s permission", name.c_str()),
                           impliedBySdk23Permission);
     } else if (name == "android.permission.BLUETOOTH" ||
                name == "android.permission.BLUETOOTH_ADMIN") {
         if (targetSdk > SDK_DONUT) {
             addImpliedFeature(impliedFeatures, "android.hardware.bluetooth",
-                              String8::format("requested %s permission", name.string()),
+                              String8::format("requested %s permission", name.c_str()),
                               impliedBySdk23Permission);
             addImpliedFeature(impliedFeatures, "android.hardware.bluetooth",
                               String8::format("targetSdkVersion > %d", SDK_DONUT),
@@ -693,13 +693,13 @@ static void addImpliedFeaturesForPermission(const int targetSdk, const String8&
         }
     } else if (name == "android.permission.RECORD_AUDIO") {
         addImpliedFeature(impliedFeatures, "android.hardware.microphone",
-                          String8::format("requested %s permission", name.string()),
+                          String8::format("requested %s permission", name.c_str()),
                           impliedBySdk23Permission);
     } else if (name == "android.permission.ACCESS_WIFI_STATE" ||
                name == "android.permission.CHANGE_WIFI_STATE" ||
                name == "android.permission.CHANGE_WIFI_MULTICAST_STATE") {
         addImpliedFeature(impliedFeatures, "android.hardware.wifi",
-                          String8::format("requested %s permission", name.string()),
+                          String8::format("requested %s permission", name.c_str()),
                           impliedBySdk23Permission);
     } else if (name == "android.permission.CALL_PHONE" ||
                name == "android.permission.CALL_PRIVILEGED" ||
@@ -746,7 +746,7 @@ int doDump(Bundle* bundle)
     for (size_t i = 0; i < bundle->getPackageIncludes().size(); i++) {
       const String8& assetPath = bundle->getPackageIncludes()[i];
       if (!assets.addAssetPath(assetPath, NULL)) {
-        fprintf(stderr, "ERROR: included asset path %s could not be loaded\n", assetPath.string());
+        fprintf(stderr, "ERROR: included asset path %s could not be loaded\n", assetPath.c_str());
         return 1;
       }
     }
@@ -890,7 +890,7 @@ int doDump(Bundle* bundle)
                     goto bail;
                 }
                 String8 tag(ctag16);
-                //printf("Depth %d tag %s\n", depth, tag.string());
+                //printf("Depth %d tag %s\n", depth, tag.c_str());
                 if (depth == 1) {
                     if (tag != "manifest") {
                         SourcePos(manifestFile, tree.getLineNumber()).error(
@@ -898,14 +898,14 @@ int doDump(Bundle* bundle)
                         goto bail;
                     }
                     String8 pkg = AaptXml::getAttribute(tree, NULL, "package", NULL);
-                    printf("package: %s\n", ResTable::normalizeForOutput(pkg.string()).string());
+                    printf("package: %s\n", ResTable::normalizeForOutput(pkg.c_str()).c_str());
                 } else if (depth == 2) {
                     if (tag == "permission") {
                         String8 error;
                         String8 name = AaptXml::getAttribute(tree, NAME_ATTR, &error);
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting 'android:name': %s", error.string());
+                                    "ERROR getting 'android:name': %s", error.c_str());
                             goto bail;
                         }
 
@@ -915,13 +915,13 @@ int doDump(Bundle* bundle)
                             goto bail;
                         }
                         printf("permission: %s\n",
-                                ResTable::normalizeForOutput(name.string()).string());
+                                ResTable::normalizeForOutput(name.c_str()).c_str());
                     } else if (tag == "uses-permission") {
                         String8 error;
                         String8 name = AaptXml::getAttribute(tree, NAME_ATTR, &error);
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting 'android:name' attribute: %s", error.string());
+                                    "ERROR getting 'android:name' attribute: %s", error.c_str());
                             goto bail;
                         }
 
@@ -938,7 +938,7 @@ int doDump(Bundle* bundle)
                         String8 name = AaptXml::getAttribute(tree, NAME_ATTR, &error);
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting 'android:name' attribute: %s", error.string());
+                                    "ERROR getting 'android:name' attribute: %s", error.c_str());
                             goto bail;
                         }
 
@@ -1138,7 +1138,7 @@ int doDump(Bundle* bundle)
                             const size_t N = supportedInput.size();
                             for (size_t i=0; i<N; i++) {
                                 printf("%s", ResTable::normalizeForOutput(
-                                        supportedInput[i].string()).string());
+                                        supportedInput[i].c_str()).c_str());
                                 if (i != N - 1) {
                                     printf("' '");
                                 } else {
@@ -1157,27 +1157,27 @@ int doDump(Bundle* bundle)
                                 printf("launchable-activity:");
                                 if (aName.length() > 0) {
                                     printf(" name='%s' ",
-                                            ResTable::normalizeForOutput(aName.string()).string());
+                                            ResTable::normalizeForOutput(aName.c_str()).c_str());
                                 }
                                 printf(" label='%s' icon='%s'\n",
-                                       ResTable::normalizeForOutput(activityLabel.string())
-                                                .string(),
-                                       ResTable::normalizeForOutput(activityIcon.string())
-                                                .string());
+                                       ResTable::normalizeForOutput(activityLabel.c_str())
+                                                .c_str(),
+                                       ResTable::normalizeForOutput(activityIcon.c_str())
+                                                .c_str());
                             }
                             if (isLeanbackLauncherActivity) {
                                 printf("leanback-launchable-activity:");
                                 if (aName.length() > 0) {
                                     printf(" name='%s' ",
-                                            ResTable::normalizeForOutput(aName.string()).string());
+                                            ResTable::normalizeForOutput(aName.c_str()).c_str());
                                 }
                                 printf(" label='%s' icon='%s' banner='%s'\n",
-                                       ResTable::normalizeForOutput(activityLabel.string())
-                                                .string(),
-                                       ResTable::normalizeForOutput(activityIcon.string())
-                                                .string(),
-                                       ResTable::normalizeForOutput(activityBanner.string())
-                                                .string());
+                                       ResTable::normalizeForOutput(activityLabel.c_str())
+                                                .c_str(),
+                                       ResTable::normalizeForOutput(activityIcon.c_str())
+                                                .c_str(),
+                                       ResTable::normalizeForOutput(activityBanner.c_str())
+                                                .c_str());
                             }
                         }
                         if (!hasIntentFilter) {
@@ -1265,7 +1265,7 @@ int doDump(Bundle* bundle)
                     goto bail;
                 }
                 String8 tag(ctag16);
-                //printf("Depth %d,  %s\n", depth, tag.string());
+                //printf("Depth %d,  %s\n", depth, tag.c_str());
                 if (depth == 1) {
                     if (tag != "manifest") {
                         SourcePos(manifestFile, tree.getLineNumber()).error(
@@ -1274,13 +1274,13 @@ int doDump(Bundle* bundle)
                     }
                     pkg = AaptXml::getAttribute(tree, NULL, "package", NULL);
                     printf("package: name='%s' ",
-                            ResTable::normalizeForOutput(pkg.string()).string());
+                            ResTable::normalizeForOutput(pkg.c_str()).c_str());
                     int32_t versionCode = AaptXml::getIntegerAttribute(tree, VERSION_CODE_ATTR,
                             &error);
                     if (error != "") {
                         SourcePos(manifestFile, tree.getLineNumber()).error(
                                 "ERROR getting 'android:versionCode' attribute: %s",
-                                error.string());
+                                error.c_str());
                         goto bail;
                     }
                     if (versionCode > 0) {
@@ -1293,16 +1293,16 @@ int doDump(Bundle* bundle)
                     if (error != "") {
                         SourcePos(manifestFile, tree.getLineNumber()).error(
                                 "ERROR getting 'android:versionName' attribute: %s",
-                                error.string());
+                                error.c_str());
                         goto bail;
                     }
                     printf("versionName='%s'",
-                            ResTable::normalizeForOutput(versionName.string()).string());
+                            ResTable::normalizeForOutput(versionName.c_str()).c_str());
 
                     String8 splitName = AaptXml::getAttribute(tree, NULL, "split");
                     if (!splitName.isEmpty()) {
                         printf(" split='%s'", ResTable::normalizeForOutput(
-                                    splitName.string()).string());
+                                    splitName.c_str()).c_str());
                     }
 
                     // For 'platformBuildVersionName', using both string and int type as a fallback
@@ -1313,7 +1313,7 @@ int doDump(Bundle* bundle)
                             AaptXml::getIntegerAttribute(tree, NULL, "platformBuildVersionName", 0,
                                                          NULL);
                     if (platformBuildVersionName != "") {
-                        printf(" platformBuildVersionName='%s'", platformBuildVersionName.string());
+                        printf(" platformBuildVersionName='%s'", platformBuildVersionName.c_str());
                     } else if (platformBuildVersionNameInt > 0) {
                         printf(" platformBuildVersionName='%d'", platformBuildVersionNameInt);
                     }
@@ -1326,7 +1326,7 @@ int doDump(Bundle* bundle)
                             AaptXml::getIntegerAttribute(tree, NULL, "platformBuildVersionCode", 0,
                                                          NULL);
                     if (platformBuildVersionCode != "") {
-                        printf(" platformBuildVersionCode='%s'", platformBuildVersionCode.string());
+                        printf(" platformBuildVersionCode='%s'", platformBuildVersionCode.c_str());
                     } else if (platformBuildVersionCodeInt > 0) {
                         printf(" platformBuildVersionCode='%d'", platformBuildVersionCodeInt);
                     }
@@ -1336,7 +1336,7 @@ int doDump(Bundle* bundle)
                     if (error != "") {
                         SourcePos(manifestFile, tree.getLineNumber()).error(
                                 "ERROR getting 'android:compileSdkVersion' attribute: %s",
-                                error.string());
+                                error.c_str());
                         goto bail;
                     }
                     if (compileSdkVersion > 0) {
@@ -1347,7 +1347,7 @@ int doDump(Bundle* bundle)
                             COMPILE_SDK_VERSION_CODENAME_ATTR, &error);
                     if (compileSdkVersionCodename != "") {
                         printf(" compileSdkVersionCodename='%s'", ResTable::normalizeForOutput(
-                                compileSdkVersionCodename.string()).string());
+                                compileSdkVersionCodename.c_str()).c_str());
                     }
 
                     printf("\n");
@@ -1357,7 +1357,7 @@ int doDump(Bundle* bundle)
                     if (error != "") {
                         SourcePos(manifestFile, tree.getLineNumber()).error(
                                 "ERROR getting 'android:installLocation' attribute: %s",
-                                error.string());
+                                error.c_str());
                         goto bail;
                     }
 
@@ -1387,7 +1387,7 @@ int doDump(Bundle* bundle)
                         String8 label;
                         const size_t NL = locales.size();
                         for (size_t i=0; i<NL; i++) {
-                            const char* localeStr =  locales[i].string();
+                            const char* localeStr =  locales[i].c_str();
                             assets.setConfiguration(config, localeStr != NULL ? localeStr : "");
                             String8 llabel = AaptXml::getResolvedAttribute(res, tree, LABEL_ATTR,
                                     &error);
@@ -1395,13 +1395,13 @@ int doDump(Bundle* bundle)
                                 if (localeStr == NULL || strlen(localeStr) == 0) {
                                     label = llabel;
                                     printf("application-label:'%s'\n",
-                                            ResTable::normalizeForOutput(llabel.string()).string());
+                                            ResTable::normalizeForOutput(llabel.c_str()).c_str());
                                 } else {
                                     if (label == "") {
                                         label = llabel;
                                     }
                                     printf("application-label-%s:'%s'\n", localeStr,
-                                           ResTable::normalizeForOutput(llabel.string()).string());
+                                           ResTable::normalizeForOutput(llabel.c_str()).c_str());
                                 }
                             }
                         }
@@ -1415,7 +1415,7 @@ int doDump(Bundle* bundle)
                                     &error);
                             if (icon != "") {
                                 printf("application-icon-%d:'%s'\n", densities[i],
-                                        ResTable::normalizeForOutput(icon.string()).string());
+                                        ResTable::normalizeForOutput(icon.c_str()).c_str());
                             }
                         }
                         assets.setConfiguration(config);
@@ -1423,7 +1423,7 @@ int doDump(Bundle* bundle)
                         String8 icon = AaptXml::getResolvedAttribute(res, tree, ICON_ATTR, &error);
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting 'android:icon' attribute: %s", error.string());
+                                    "ERROR getting 'android:icon' attribute: %s", error.c_str());
                             goto bail;
                         }
                         int32_t testOnly = AaptXml::getIntegerAttribute(tree, TEST_ONLY_ATTR, 0,
@@ -1431,7 +1431,7 @@ int doDump(Bundle* bundle)
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
                                     "ERROR getting 'android:testOnly' attribute: %s",
-                                    error.string());
+                                    error.c_str());
                             goto bail;
                         }
 
@@ -1439,15 +1439,15 @@ int doDump(Bundle* bundle)
                                                                        &error);
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting 'android:banner' attribute: %s", error.string());
+                                    "ERROR getting 'android:banner' attribute: %s", error.c_str());
                             goto bail;
                         }
                         printf("application: label='%s' ",
-                                ResTable::normalizeForOutput(label.string()).string());
-                        printf("icon='%s'", ResTable::normalizeForOutput(icon.string()).string());
+                                ResTable::normalizeForOutput(label.c_str()).c_str());
+                        printf("icon='%s'", ResTable::normalizeForOutput(icon.c_str()).c_str());
                         if (banner != "") {
                             printf(" banner='%s'",
-                                   ResTable::normalizeForOutput(banner.string()).string());
+                                   ResTable::normalizeForOutput(banner.c_str()).c_str());
                         }
                         printf("\n");
                         if (testOnly != 0) {
@@ -1458,7 +1458,7 @@ int doDump(Bundle* bundle)
                                 ISGAME_ATTR, 0, &error);
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting 'android:isGame' attribute: %s", error.string());
+                                    "ERROR getting 'android:isGame' attribute: %s", error.c_str());
                             goto bail;
                         }
                         if (isGame != 0) {
@@ -1470,7 +1470,7 @@ int doDump(Bundle* bundle)
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
                                     "ERROR getting 'android:debuggable' attribute: %s",
-                                    error.string());
+                                    error.c_str());
                             goto bail;
                         }
                         if (debuggable != 0) {
@@ -1500,12 +1500,12 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:minSdkVersion' attribute: %s",
-                                        error.string());
+                                        error.c_str());
                                 goto bail;
                             }
                             if (name == "Donut") targetSdk = SDK_DONUT;
                             printf("sdkVersion:'%s'\n",
-                                    ResTable::normalizeForOutput(name.string()).string());
+                                    ResTable::normalizeForOutput(name.c_str()).c_str());
                         } else if (code != -1) {
                             targetSdk = code;
                             printf("sdkVersion:'%d'\n", code);
@@ -1522,7 +1522,7 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:targetSdkVersion' attribute: %s",
-                                        error.string());
+                                        error.c_str());
                                 goto bail;
                             }
                             if (name == "Donut" && targetSdk < SDK_DONUT) {
@@ -1532,7 +1532,7 @@ int doDump(Bundle* bundle)
                                 targetSdk = SDK_CUR_DEVELOPMENT;
                             }
                             printf("targetSdkVersion:'%s'\n",
-                                    ResTable::normalizeForOutput(name.string()).string());
+                                    ResTable::normalizeForOutput(name.c_str()).c_str());
                         } else if (code != -1) {
                             if (targetSdk < code) {
                                 targetSdk = code;
@@ -1592,7 +1592,7 @@ int doDump(Bundle* bundle)
                         group.label = AaptXml::getResolvedAttribute(res, tree, LABEL_ATTR, &error);
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting 'android:label' attribute: %s", error.string());
+                                    "ERROR getting 'android:label' attribute: %s", error.c_str());
                             goto bail;
                         }
                         featureGroups.add(group);
@@ -1608,7 +1608,7 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "failed to read attribute 'android:required': %s",
-                                        error.string());
+                                        error.c_str());
                                 goto bail;
                             }
 
@@ -1617,7 +1617,7 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "failed to read attribute 'android:version': %s",
-                                        error.string());
+                                        error.c_str());
                                 goto bail;
                             }
 
@@ -1638,7 +1638,7 @@ int doDump(Bundle* bundle)
                         String8 name = AaptXml::getAttribute(tree, NAME_ATTR, &error);
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting 'android:name' attribute: %s", error.string());
+                                    "ERROR getting 'android:name' attribute: %s", error.c_str());
                             goto bail;
                         }
 
@@ -1682,7 +1682,7 @@ int doDump(Bundle* bundle)
                         String8 name = AaptXml::getAttribute(tree, NAME_ATTR, &error);
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting 'android:name' attribute: %s", error.string());
+                                    "ERROR getting 'android:name' attribute: %s", error.c_str());
                             goto bail;
                         }
 
@@ -1701,37 +1701,37 @@ int doDump(Bundle* bundle)
                         String8 name = AaptXml::getAttribute(tree, NAME_ATTR, &error);
                         if (name != "" && error == "") {
                             printf("uses-package:'%s'\n",
-                                    ResTable::normalizeForOutput(name.string()).string());
+                                    ResTable::normalizeForOutput(name.c_str()).c_str());
                         } else {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting 'android:name' attribute: %s", error.string());
+                                    "ERROR getting 'android:name' attribute: %s", error.c_str());
                             goto bail;
                         }
                     } else if (tag == "original-package") {
                         String8 name = AaptXml::getAttribute(tree, NAME_ATTR, &error);
                         if (name != "" && error == "") {
                             printf("original-package:'%s'\n",
-                                    ResTable::normalizeForOutput(name.string()).string());
+                                    ResTable::normalizeForOutput(name.c_str()).c_str());
                         } else {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting 'android:name' attribute: %s", error.string());
+                                    "ERROR getting 'android:name' attribute: %s", error.c_str());
                             goto bail;
                         }
                     } else if (tag == "supports-gl-texture") {
                         String8 name = AaptXml::getAttribute(tree, NAME_ATTR, &error);
                         if (name != "" && error == "") {
                             printf("supports-gl-texture:'%s'\n",
-                                    ResTable::normalizeForOutput(name.string()).string());
+                                    ResTable::normalizeForOutput(name.c_str()).c_str());
                         } else {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting 'android:name' attribute: %s", error.string());
+                                    "ERROR getting 'android:name' attribute: %s", error.c_str());
                             goto bail;
                         }
                     } else if (tag == "compatible-screens") {
                         printCompatibleScreens(tree, &error);
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting compatible screens: %s", error.string());
+                                    "ERROR getting compatible screens: %s", error.c_str());
                             goto bail;
                         }
                         depth--;
@@ -1742,8 +1742,8 @@ int doDump(Bundle* bundle)
                                                                       &error);
                             if (publicKey != "" && error == "") {
                                 printf("package-verifier: name='%s' publicKey='%s'\n",
-                                        ResTable::normalizeForOutput(name.string()).string(),
-                                        ResTable::normalizeForOutput(publicKey.string()).string());
+                                        ResTable::normalizeForOutput(name.c_str()).c_str(),
+                                        ResTable::normalizeForOutput(publicKey.c_str()).c_str());
                             }
                         }
                     }
@@ -1769,7 +1769,7 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:name' attribute: %s",
-                                        error.string());
+                                        error.c_str());
                                 goto bail;
                             }
 
@@ -1778,7 +1778,7 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:label' attribute: %s",
-                                        error.string());
+                                        error.c_str());
                                 goto bail;
                             }
 
@@ -1787,7 +1787,7 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:icon' attribute: %s",
-                                        error.string());
+                                        error.c_str());
                                 goto bail;
                             }
 
@@ -1796,7 +1796,7 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:banner' attribute: %s",
-                                        error.string());
+                                        error.c_str());
                                 goto bail;
                             }
 
@@ -1824,14 +1824,14 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:name' attribute for uses-library"
-                                        " %s", error.string());
+                                        " %s", error.c_str());
                                 goto bail;
                             }
                             int req = AaptXml::getIntegerAttribute(tree,
                                     REQUIRED_ATTR, 1);
                             printf("uses-library%s:'%s'\n",
                                     req ? "" : "-not-required", ResTable::normalizeForOutput(
-                                            libraryName.string()).string());
+                                            libraryName.c_str()).c_str());
                         } else if (tag == "receiver") {
                             withinReceiver = true;
                             receiverName = AaptXml::getAttribute(tree, NAME_ATTR, &error);
@@ -1839,7 +1839,7 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:name' attribute for receiver:"
-                                        " %s", error.string());
+                                        " %s", error.c_str());
                                 goto bail;
                             }
 
@@ -1853,7 +1853,7 @@ int doDump(Bundle* bundle)
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:permission' attribute for"
                                         " receiver '%s': %s",
-                                        receiverName.string(), error.string());
+                                        receiverName.c_str(), error.c_str());
                             }
                         } else if (tag == "service") {
                             withinService = true;
@@ -1862,7 +1862,7 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:name' attribute for "
-                                        "service:%s", error.string());
+                                        "service:%s", error.c_str());
                                 goto bail;
                             }
 
@@ -1887,7 +1887,7 @@ int doDump(Bundle* bundle)
                             } else {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:permission' attribute for "
-                                        "service '%s': %s", serviceName.string(), error.string());
+                                        "service '%s': %s", serviceName.c_str(), error.c_str());
                             }
                         } else if (tag == "provider") {
                             withinProvider = true;
@@ -1897,7 +1897,7 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:exported' attribute for provider:"
-                                        " %s", error.string());
+                                        " %s", error.c_str());
                                 goto bail;
                             }
 
@@ -1906,7 +1906,7 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:grantUriPermissions' attribute for "
-                                        "provider: %s", error.string());
+                                        "provider: %s", error.c_str());
                                 goto bail;
                             }
 
@@ -1915,7 +1915,7 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:permission' attribute for "
-                                        "provider: %s", error.string());
+                                        "provider: %s", error.c_str());
                                 goto bail;
                             }
 
@@ -1928,11 +1928,11 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:name' attribute for "
-                                        "meta-data: %s", error.string());
+                                        "meta-data: %s", error.c_str());
                                 goto bail;
                             }
                             printf("meta-data: name='%s' ",
-                                    ResTable::normalizeForOutput(metaDataName.string()).string());
+                                    ResTable::normalizeForOutput(metaDataName.c_str()).c_str());
                             printResolvedResourceAttribute(res, tree, VALUE_ATTR, String8("value"),
                                     &error);
                             if (error != "") {
@@ -1944,7 +1944,7 @@ int doDump(Bundle* bundle)
                                     SourcePos(manifestFile, tree.getLineNumber()).error(
                                             "ERROR getting 'android:value' or "
                                             "'android:resource' attribute for "
-                                            "meta-data: %s", error.string());
+                                            "meta-data: %s", error.c_str());
                                     goto bail;
                                 }
                             }
@@ -1956,7 +1956,7 @@ int doDump(Bundle* bundle)
                             } else {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:name' attribute: %s",
-                                        error.string());
+                                        error.c_str());
                                 goto bail;
                             }
                         }
@@ -1969,13 +1969,13 @@ int doDump(Bundle* bundle)
                             Feature feature(true);
 
                             int32_t featureVers = AaptXml::getIntegerAttribute(
-                                    tree, androidSchema.string(), "version", 0, &error);
+                                    tree, androidSchema.c_str(), "version", 0, &error);
                             if (error == "") {
                                 feature.version = featureVers;
                             } else {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "failed to read attribute 'android:version': %s",
-                                        error.string());
+                                        error.c_str());
                                 goto bail;
                             }
 
@@ -2016,8 +2016,8 @@ int doDump(Bundle* bundle)
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
                                     "ERROR getting 'android:name' attribute for "
-                                    "meta-data tag in service '%s': %s", serviceName.string(),
-                                    error.string());
+                                    "meta-data tag in service '%s': %s", serviceName.c_str(),
+                                    error.c_str());
                             goto bail;
                         }
 
@@ -2034,7 +2034,7 @@ int doDump(Bundle* bundle)
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting 'android:resource' attribute for "
                                         "meta-data tag in service '%s': %s",
-                                        serviceName.string(), error.string());
+                                        serviceName.c_str(), error.c_str());
                                 goto bail;
                             }
 
@@ -2043,7 +2043,7 @@ int doDump(Bundle* bundle)
                             if (error != "") {
                                 SourcePos(manifestFile, tree.getLineNumber()).error(
                                         "ERROR getting AID category for service '%s'",
-                                        serviceName.string());
+                                        serviceName.c_str());
                                 goto bail;
                             }
 
@@ -2064,7 +2064,7 @@ int doDump(Bundle* bundle)
                         action = AaptXml::getAttribute(tree, NAME_ATTR, &error);
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting 'android:name' attribute: %s", error.string());
+                                    "ERROR getting 'android:name' attribute: %s", error.c_str());
                             goto bail;
                         }
 
@@ -2120,7 +2120,7 @@ int doDump(Bundle* bundle)
                         String8 category = AaptXml::getAttribute(tree, NAME_ATTR, &error);
                         if (error != "") {
                             SourcePos(manifestFile, tree.getLineNumber()).error(
-                                    "ERROR getting 'name' attribute: %s", error.string());
+                                    "ERROR getting 'name' attribute: %s", error.c_str());
                             goto bail;
                         }
                         if (withinActivity) {
@@ -2352,7 +2352,7 @@ int doDump(Bundle* bundle)
             printf("locales:");
             const size_t NL = locales.size();
             for (size_t i=0; i<NL; i++) {
-                const char* localeStr =  locales[i].string();
+                const char* localeStr =  locales[i].c_str();
                 if (localeStr == NULL || strlen(localeStr) == 0) {
                     localeStr = "--_--";
                 }
@@ -2373,7 +2373,7 @@ int doDump(Bundle* bundle)
                     SortedVector<String8> architectures;
                     for (size_t i=0; i<dir->getFileCount(); i++) {
                         architectures.add(ResTable::normalizeForOutput(
-                                dir->getFileName(i).string()));
+                                dir->getFileName(i).c_str()));
                     }
 
                     bool outputAltNativeCode = false;
@@ -2401,7 +2401,7 @@ int doDump(Bundle* bundle)
                         }
 
                         if (index >= 0) {
-                            printf("native-code: '%s'\n", architectures[index].string());
+                            printf("native-code: '%s'\n", architectures[index].c_str());
                             architectures.removeAt(index);
                             outputAltNativeCode = true;
                         }
@@ -2414,7 +2414,7 @@ int doDump(Bundle* bundle)
                         }
                         printf("native-code:");
                         for (size_t i = 0; i < archCount; i++) {
-                            printf(" '%s'", architectures[i].string());
+                            printf(" '%s'", architectures[i].c_str());
                         }
                         printf("\n");
                     }
@@ -2428,7 +2428,7 @@ int doDump(Bundle* bundle)
             res.getConfigurations(&configs);
             const size_t N = configs.size();
             for (size_t i=0; i<N; i++) {
-                printf("%s\n", configs[i].toString().string());
+                printf("%s\n", configs[i].toString().c_str());
             }
         } else {
             fprintf(stderr, "ERROR: unknown dump option '%s'\n", option);
@@ -2486,15 +2486,15 @@ int doAdd(Bundle* bundle)
     for (int i = 1; i < bundle->getFileSpecCount(); i++) {
         const char* fileName = bundle->getFileSpecEntry(i);
 
-        if (strcasecmp(String8(fileName).getPathExtension().string(), ".gz") == 0) {
+        if (strcasecmp(String8(fileName).getPathExtension().c_str(), ".gz") == 0) {
             printf(" '%s'... (from gzip)\n", fileName);
-            result = zip->addGzip(fileName, String8(fileName).getBasePath().string(), NULL);
+            result = zip->addGzip(fileName, String8(fileName).getBasePath().c_str(), NULL);
         } else {
             if (bundle->getJunkPath()) {
                 String8 storageName = String8(fileName).getPathLeaf();
                 printf(" '%s' as '%s'...\n", fileName,
-                        ResTable::normalizeForOutput(storageName.string()).string());
-                result = zip->add(fileName, storageName.string(),
+                        ResTable::normalizeForOutput(storageName.c_str()).c_str());
+                result = zip->add(fileName, storageName.c_str(),
                                   bundle->getCompressionMethod(), NULL);
             } else {
                 printf(" '%s'...\n", fileName);
@@ -2581,7 +2581,7 @@ static status_t addResourcesToBuilder(const sp<AaptDir>& dir, const sp<ApkBuilde
     for (size_t i = 0; i < numDirs; i++) {
         bool ignore = ignoreConfig;
         const sp<AaptDir>& subDir = dir->getDirs().valueAt(i);
-        const char* dirStr = subDir->getLeaf().string();
+        const char* dirStr = subDir->getLeaf().c_str();
         if (!ignore && strstr(dirStr, "mipmap") == dirStr) {
             ignore = true;
         }
@@ -2604,7 +2604,7 @@ static status_t addResourcesToBuilder(const sp<AaptDir>& dir, const sp<ApkBuilde
             }
             if (err != NO_ERROR) {
                 fprintf(stderr, "Failed to add %s (%s) to builder.\n",
-                        gp->getPath().string(), gp->getFiles()[j]->getPrintableSource().string());
+                        gp->getPath().c_str(), gp->getFiles()[j]->getPrintableSource().c_str());
                 return err;
             }
         }
@@ -2620,13 +2620,13 @@ static String8 buildApkName(const String8& original, const sp<ApkSplit>& split)
     String8 ext(original.getPathExtension());
     if (ext == String8(".apk")) {
         return String8::format("%s_%s%s",
-                original.getBasePath().string(),
-                split->getDirectorySafeName().string(),
-                ext.string());
+                original.getBasePath().c_str(),
+                split->getDirectorySafeName().c_str(),
+                ext.c_str());
     }
 
-    return String8::format("%s_%s", original.string(),
-            split->getDirectorySafeName().string());
+    return String8::format("%s_%s", original.c_str(),
+            split->getDirectorySafeName().c_str());
 }
 
 /*
@@ -2712,7 +2712,7 @@ int doPackage(Bundle* bundle)
         for (size_t i = 0; i < numSplits; i++) {
             std::set<ConfigDescription> configs;
             if (!AaptConfig::parseCommaSeparatedList(splitStrs[i], &configs)) {
-                fprintf(stderr, "ERROR: failed to parse split configuration '%s'\n", splitStrs[i].string());
+                fprintf(stderr, "ERROR: failed to parse split configuration '%s'\n", splitStrs[i].c_str());
                 goto bail;
             }
 
@@ -2835,7 +2835,7 @@ int doPackage(Bundle* bundle)
             String8 outputPath = buildApkName(String8(outputAPKFile), split);
             err = writeAPK(bundle, outputPath, split);
             if (err != NO_ERROR) {
-                fprintf(stderr, "ERROR: packaging of '%s' failed\n", outputPath.string());
+                fprintf(stderr, "ERROR: packaging of '%s' failed\n", outputPath.c_str());
                 goto bail;
             }
         }
diff --git a/tools/aapt/CrunchCache.cpp b/tools/aapt/CrunchCache.cpp
index 7b8a576b88d3..1f2febec2230 100644
--- a/tools/aapt/CrunchCache.cpp
+++ b/tools/aapt/CrunchCache.cpp
@@ -44,7 +44,7 @@ size_t CrunchCache::crunch(CacheUpdater* cu, bool forceOverwrite)
         // This efficiently strips the source directory prefix from our path.
         // Also, String8 doesn't have a substring method so this is what we've
         // got to work with.
-        const char* rPathPtr = mSourceFiles.keyAt(0).string()+mSourcePath.length();
+        const char* rPathPtr = mSourceFiles.keyAt(0).c_str()+mSourcePath.length();
         // Strip leading slash if present
         int offset = 0;
         if (rPathPtr[0] == OS_PATH_SEPARATOR)
diff --git a/tools/aapt/DirectoryWalker.h b/tools/aapt/DirectoryWalker.h
index 88031d04b2df..cea3a6eb0ecf 100644
--- a/tools/aapt/DirectoryWalker.h
+++ b/tools/aapt/DirectoryWalker.h
@@ -57,7 +57,7 @@ public:
     virtual bool openDir(String8 path) {
         mBasePath = path;
         dir = NULL;
-        dir = opendir(mBasePath.string() );
+        dir = opendir(mBasePath.c_str() );
 
         if (dir == NULL)
             return false;
@@ -78,7 +78,7 @@ public:
         mEntry = *entryPtr;
         // Get stats
         String8 fullPath = mBasePath.appendPathCopy(mEntry.d_name);
-        stat(fullPath.string(),&mStats);
+        stat(fullPath.c_str(),&mStats);
         return &mEntry;
     };
     // Get the stats for the current entry
diff --git a/tools/aapt/FileFinder.cpp b/tools/aapt/FileFinder.cpp
index c9d0744a4463..a5c19806c804 100644
--- a/tools/aapt/FileFinder.cpp
+++ b/tools/aapt/FileFinder.cpp
@@ -59,14 +59,14 @@ bool SystemFileFinder::findFiles(String8 basePath, Vector<String8>& extensions,
 
         String8 fullPath = basePath.appendPathCopy(entryName);
         // If this entry is a directory we'll recurse into it
-        if (isDirectory(fullPath.string()) ) {
+        if (isDirectory(fullPath.c_str()) ) {
             DirectoryWalker* copy = dw->clone();
             findFiles(fullPath, extensions, fileStore,copy);
             delete copy;
         }
 
         // If this entry is a file, we'll pass it over to checkAndAddFile
-        if (isFile(fullPath.string()) ) {
+        if (isFile(fullPath.c_str()) ) {
             checkAndAddFile(fullPath,dw->entryStats(),extensions,fileStore);
         }
     }
diff --git a/tools/aapt/Images.cpp b/tools/aapt/Images.cpp
index 627a231de5c8..c6c7e960ba2a 100644
--- a/tools/aapt/Images.cpp
+++ b/tools/aapt/Images.cpp
@@ -1328,13 +1328,13 @@ static bool read_png_protected(png_structp read_ptr, String8& printableName, png
 
     png_init_io(read_ptr, fp);
 
-    read_png(printableName.string(), read_ptr, read_info, imageInfo);
+    read_png(printableName.c_str(), read_ptr, read_info, imageInfo);
 
     const size_t nameLen = file->getPath().length();
     if (nameLen > 6) {
-        const char* name = file->getPath().string();
+        const char* name = file->getPath().c_str();
         if (name[nameLen-5] == '9' && name[nameLen-6] == '.') {
-            if (do_9patch(printableName.string(), imageInfo) != NO_ERROR) {
+            if (do_9patch(printableName.c_str(), imageInfo) != NO_ERROR) {
                 return false;
             }
         }
@@ -1349,7 +1349,7 @@ static bool write_png_protected(png_structp write_ptr, String8& printableName, p
         return false;
     }
 
-    write_png(printableName.string(), write_ptr, write_info, *imageInfo, bundle);
+    write_png(printableName.c_str(), write_ptr, write_info, *imageInfo, bundle);
 
     return true;
 }
@@ -1360,7 +1360,7 @@ status_t preProcessImage(const Bundle* bundle, const sp<AaptAssets>& /* assets *
     String8 ext(file->getPath().getPathExtension());
 
     // We currently only process PNG images.
-    if (strcmp(ext.string(), ".png") != 0) {
+    if (strcmp(ext.c_str(), ".png") != 0) {
         return NO_ERROR;
     }
 
@@ -1371,7 +1371,7 @@ status_t preProcessImage(const Bundle* bundle, const sp<AaptAssets>& /* assets *
     String8 printableName(file->getPrintableSource());
 
     if (bundle->getVerbose()) {
-        printf("Processing image: %s\n", printableName.string());
+        printf("Processing image: %s\n", printableName.c_str());
     }
 
     png_structp read_ptr = NULL;
@@ -1385,9 +1385,9 @@ status_t preProcessImage(const Bundle* bundle, const sp<AaptAssets>& /* assets *
 
     status_t error = UNKNOWN_ERROR;
 
-    fp = fopen(file->getSourceFile().string(), "rb");
+    fp = fopen(file->getSourceFile().c_str(), "rb");
     if (fp == NULL) {
-        fprintf(stderr, "%s: ERROR: Unable to open PNG file\n", printableName.string());
+        fprintf(stderr, "%s: ERROR: Unable to open PNG file\n", printableName.c_str());
         goto bail;
     }
 
@@ -1434,7 +1434,7 @@ status_t preProcessImage(const Bundle* bundle, const sp<AaptAssets>& /* assets *
         size_t newSize = file->getSize();
         float factor = ((float)newSize)/oldSize;
         int percent = (int)(factor*100);
-        printf("    (processed image %s: %d%% size of source)\n", printableName.string(), percent);
+        printf("    (processed image %s: %d%% size of source)\n", printableName.c_str(), percent);
     }
 
 bail:
@@ -1450,7 +1450,7 @@ bail:
 
     if (error != NO_ERROR) {
         fprintf(stderr, "ERROR: Failure processing PNG image %s\n",
-                file->getPrintableSource().string());
+                file->getPrintableSource().c_str());
     }
     return error;
 }
@@ -1470,13 +1470,13 @@ status_t preProcessImageToCache(const Bundle* bundle, const String8& source, con
     status_t error = UNKNOWN_ERROR;
 
     if (bundle->getVerbose()) {
-        printf("Processing image to cache: %s => %s\n", source.string(), dest.string());
+        printf("Processing image to cache: %s => %s\n", source.c_str(), dest.c_str());
     }
 
     // Get a file handler to read from
-    fp = fopen(source.string(),"rb");
+    fp = fopen(source.c_str(),"rb");
     if (fp == NULL) {
-        fprintf(stderr, "%s ERROR: Unable to open PNG file\n", source.string());
+        fprintf(stderr, "%s ERROR: Unable to open PNG file\n", source.c_str());
         return error;
     }
 
@@ -1507,7 +1507,7 @@ status_t preProcessImageToCache(const Bundle* bundle, const String8& source, con
     png_init_io(read_ptr,fp);
 
     // Actually read data from the file
-    read_png(source.string(), read_ptr, read_info, &imageInfo);
+    read_png(source.c_str(), read_ptr, read_info, &imageInfo);
 
     // We're done reading so we can clean up
     // Find old file size before releasing handle
@@ -1519,7 +1519,7 @@ status_t preProcessImageToCache(const Bundle* bundle, const String8& source, con
     // Check to see if we're dealing with a 9-patch
     // If we are, process appropriately
     if (source.getBasePath().getPathExtension() == ".9")  {
-        if (do_9patch(source.string(), &imageInfo) != NO_ERROR) {
+        if (do_9patch(source.c_str(), &imageInfo) != NO_ERROR) {
             return error;
         }
     }
@@ -1541,9 +1541,9 @@ status_t preProcessImageToCache(const Bundle* bundle, const String8& source, con
     }
 
     // Open up our destination file for writing
-    fp = fopen(dest.string(), "wb");
+    fp = fopen(dest.c_str(), "wb");
     if (!fp) {
-        fprintf(stderr, "%s ERROR: Unable to open PNG file\n", dest.string());
+        fprintf(stderr, "%s ERROR: Unable to open PNG file\n", dest.c_str());
         png_destroy_write_struct(&write_ptr, &write_info);
         return error;
     }
@@ -1559,11 +1559,11 @@ status_t preProcessImageToCache(const Bundle* bundle, const String8& source, con
     }
 
     // Actually write out to the new png
-    write_png(dest.string(), write_ptr, write_info, imageInfo, bundle);
+    write_png(dest.c_str(), write_ptr, write_info, imageInfo, bundle);
 
     if (bundle->getVerbose()) {
         // Find the size of our new file
-        FILE* reader = fopen(dest.string(), "rb");
+        FILE* reader = fopen(dest.c_str(), "rb");
         fseek(reader, 0, SEEK_END);
         size_t newSize = (size_t)ftell(reader);
         fclose(reader);
@@ -1571,7 +1571,7 @@ status_t preProcessImageToCache(const Bundle* bundle, const String8& source, con
         float factor = ((float)newSize)/oldSize;
         int percent = (int)(factor*100);
         printf("  (processed image to cache entry %s: %d%% size of source)\n",
-               dest.string(), percent);
+               dest.c_str(), percent);
     }
 
     //Clean up
@@ -1588,7 +1588,7 @@ status_t postProcessImage(const Bundle* bundle, const sp<AaptAssets>& assets,
 
     // At this point, now that we have all the resource data, all we need to
     // do is compile XML files.
-    if (strcmp(ext.string(), ".xml") == 0) {
+    if (strcmp(ext.c_str(), ".xml") == 0) {
         String16 resourceName(parseResourceName(file->getSourceFile().getPathLeaf()));
         return compileXmlFile(bundle, assets, resourceName, file, table);
     }
diff --git a/tools/aapt/Package.cpp b/tools/aapt/Package.cpp
index f06643dcf784..965655b59a94 100644
--- a/tools/aapt/Package.cpp
+++ b/tools/aapt/Package.cpp
@@ -69,39 +69,39 @@ status_t writeAPK(Bundle* bundle, const String8& outputFile, const sp<OutputSet>
      * If "update" is set, update the contents of the existing archive.
      * Else, if "force" is set, remove the existing archive.
      */
-    FileType fileType = getFileType(outputFile.string());
+    FileType fileType = getFileType(outputFile.c_str());
     if (fileType == kFileTypeNonexistent) {
         // okay, create it below
     } else if (fileType == kFileTypeRegular) {
         if (bundle->getUpdate()) {
             // okay, open it below
         } else if (bundle->getForce()) {
-            if (unlink(outputFile.string()) != 0) {
-                fprintf(stderr, "ERROR: unable to remove '%s': %s\n", outputFile.string(),
+            if (unlink(outputFile.c_str()) != 0) {
+                fprintf(stderr, "ERROR: unable to remove '%s': %s\n", outputFile.c_str(),
                         strerror(errno));
                 goto bail;
             }
         } else {
             fprintf(stderr, "ERROR: '%s' exists (use '-f' to force overwrite)\n",
-                    outputFile.string());
+                    outputFile.c_str());
             goto bail;
         }
     } else {
-        fprintf(stderr, "ERROR: '%s' exists and is not a regular file\n", outputFile.string());
+        fprintf(stderr, "ERROR: '%s' exists and is not a regular file\n", outputFile.c_str());
         goto bail;
     }
 
     if (bundle->getVerbose()) {
         printf("%s '%s'\n", (fileType == kFileTypeNonexistent) ? "Creating" : "Opening",
-                outputFile.string());
+                outputFile.c_str());
     }
 
     status_t status;
     zip = new ZipFile;
-    status = zip->open(outputFile.string(), ZipFile::kOpenReadWrite | ZipFile::kOpenCreate);
+    status = zip->open(outputFile.c_str(), ZipFile::kOpenReadWrite | ZipFile::kOpenCreate);
     if (status != NO_ERROR) {
         fprintf(stderr, "ERROR: unable to open '%s' as Zip file for writing\n",
-                outputFile.string());
+                outputFile.c_str());
         goto bail;
     }
 
@@ -112,7 +112,7 @@ status_t writeAPK(Bundle* bundle, const String8& outputFile, const sp<OutputSet>
     count = processAssets(bundle, zip, outputSet);
     if (count < 0) {
         fprintf(stderr, "ERROR: unable to process assets while packaging '%s'\n",
-                outputFile.string());
+                outputFile.c_str());
         result = count;
         goto bail;
     }
@@ -124,7 +124,7 @@ status_t writeAPK(Bundle* bundle, const String8& outputFile, const sp<OutputSet>
     count = processJarFiles(bundle, zip);
     if (count < 0) {
         fprintf(stderr, "ERROR: unable to process jar files while packaging '%s'\n",
-                outputFile.string());
+                outputFile.c_str());
         result = count;
         goto bail;
     }
@@ -169,12 +169,12 @@ status_t writeAPK(Bundle* bundle, const String8& outputFile, const sp<OutputSet>
     /* anything here? */
     if (zip->getNumEntries() == 0) {
         if (bundle->getVerbose()) {
-            printf("Archive is empty -- removing %s\n", outputFile.getPathLeaf().string());
+            printf("Archive is empty -- removing %s\n", outputFile.getPathLeaf().c_str());
         }
         delete zip;        // close the file so we can remove it in Win32
         zip = NULL;
-        if (unlink(outputFile.string()) != 0) {
-            fprintf(stderr, "warning: could not unlink '%s'\n", outputFile.string());
+        if (unlink(outputFile.c_str()) != 0) {
+            fprintf(stderr, "warning: could not unlink '%s'\n", outputFile.c_str());
         }
     }
 
@@ -187,9 +187,9 @@ status_t writeAPK(Bundle* bundle, const String8& outputFile, const sp<OutputSet>
         String8 dependencyFile = outputFile;
         dependencyFile.append(".d");
 
-        FILE* fp = fopen(dependencyFile.string(), "a");
+        FILE* fp = fopen(dependencyFile.c_str(), "a");
         // Add this file to the dependency file
-        fprintf(fp, "%s \\\n", outputFile.string());
+        fprintf(fp, "%s \\\n", outputFile.c_str());
         fclose(fp);
     }
 
@@ -199,10 +199,10 @@ bail:
     delete zip;        // must close before remove in Win32
     if (result != NO_ERROR) {
         if (bundle->getVerbose()) {
-            printf("Removing %s due to earlier failures\n", outputFile.string());
+            printf("Removing %s due to earlier failures\n", outputFile.c_str());
         }
-        if (unlink(outputFile.string()) != 0) {
-            fprintf(stderr, "warning: could not unlink '%s'\n", outputFile.string());
+        if (unlink(outputFile.c_str()) != 0) {
+            fprintf(stderr, "warning: could not unlink '%s'\n", outputFile.c_str());
         }
     }
 
@@ -267,31 +267,31 @@ bool processFile(Bundle* bundle, ZipFile* zip,
     int fileNameLen = storageName.length();
     int excludeExtensionLen = strlen(kExcludeExtension);
     if (fileNameLen > excludeExtensionLen
-            && (0 == strcmp(storageName.string() + (fileNameLen - excludeExtensionLen),
+            && (0 == strcmp(storageName.c_str() + (fileNameLen - excludeExtensionLen),
                             kExcludeExtension))) {
-        fprintf(stderr, "warning: '%s' not added to Zip\n", storageName.string());
+        fprintf(stderr, "warning: '%s' not added to Zip\n", storageName.c_str());
         return true;
     }
 
-    if (strcasecmp(storageName.getPathExtension().string(), ".gz") == 0) {
+    if (strcasecmp(storageName.getPathExtension().c_str(), ".gz") == 0) {
         fromGzip = true;
         storageName = storageName.getBasePath();
     }
 
     if (bundle->getUpdate()) {
-        entry = zip->getEntryByName(storageName.string());
+        entry = zip->getEntryByName(storageName.c_str());
         if (entry != NULL) {
             /* file already exists in archive; there can be only one */
             if (entry->getMarked()) {
                 fprintf(stderr,
                         "ERROR: '%s' exists twice (check for with & w/o '.gz'?)\n",
-                        file->getPrintableSource().string());
+                        file->getPrintableSource().c_str());
                 return false;
             }
             if (!hasData) {
                 const String8& srcName = file->getSourceFile();
                 time_t fileModWhen;
-                fileModWhen = getFileModDate(srcName.string());
+                fileModWhen = getFileModDate(srcName.c_str());
                 if (fileModWhen == (time_t) -1) { // file existence tested earlier,
                     return false;                 //  not expecting an error here
                 }
@@ -299,14 +299,14 @@ bool processFile(Bundle* bundle, ZipFile* zip,
                 if (fileModWhen > entry->getModWhen()) {
                     // mark as deleted so add() will succeed
                     if (bundle->getVerbose()) {
-                        printf("      (removing old '%s')\n", storageName.string());
+                        printf("      (removing old '%s')\n", storageName.c_str());
                     }
     
                     zip->remove(entry);
                 } else {
                     // version in archive is newer
                     if (bundle->getVerbose()) {
-                        printf("      (not updating '%s')\n", storageName.string());
+                        printf("      (not updating '%s')\n", storageName.c_str());
                     }
                     entry->setMarked(true);
                     return true;
@@ -321,22 +321,22 @@ bool processFile(Bundle* bundle, ZipFile* zip,
     //android_setMinPriority(NULL, ANDROID_LOG_VERBOSE);
 
     if (fromGzip) {
-        result = zip->addGzip(file->getSourceFile().string(), storageName.string(), &entry);
+        result = zip->addGzip(file->getSourceFile().c_str(), storageName.c_str(), &entry);
     } else if (!hasData) {
         /* don't compress certain files, e.g. PNGs */
         int compressionMethod = bundle->getCompressionMethod();
         if (!okayToCompress(bundle, storageName)) {
             compressionMethod = ZipEntry::kCompressStored;
         }
-        result = zip->add(file->getSourceFile().string(), storageName.string(), compressionMethod,
+        result = zip->add(file->getSourceFile().c_str(), storageName.c_str(), compressionMethod,
                             &entry);
     } else {
-        result = zip->add(file->getData(), file->getSize(), storageName.string(),
+        result = zip->add(file->getData(), file->getSize(), storageName.c_str(),
                            file->getCompressionMethod(), &entry);
     }
     if (result == NO_ERROR) {
         if (bundle->getVerbose()) {
-            printf("      '%s'%s", storageName.string(), fromGzip ? " (from .gz)" : "");
+            printf("      '%s'%s", storageName.c_str(), fromGzip ? " (from .gz)" : "");
             if (entry->getCompressionMethod() == ZipEntry::kCompressStored) {
                 printf(" (not compressed)\n");
             } else {
@@ -348,10 +348,10 @@ bool processFile(Bundle* bundle, ZipFile* zip,
     } else {
         if (result == ALREADY_EXISTS) {
             fprintf(stderr, "      Unable to add '%s': file already in archive (try '-u'?)\n",
-                    file->getPrintableSource().string());
+                    file->getPrintableSource().c_str());
         } else {
             fprintf(stderr, "      Unable to add '%s': Zip add failed (%d)\n",
-                    file->getPrintableSource().string(), result);
+                    file->getPrintableSource().c_str(), result);
         }
         return false;
     }
@@ -372,7 +372,7 @@ bool okayToCompress(Bundle* bundle, const String8& pathName)
         return true;
 
     for (i = 0; i < NELEM(kNoCompressExt); i++) {
-        if (strcasecmp(ext.string(), kNoCompressExt[i]) == 0)
+        if (strcasecmp(ext.c_str(), kNoCompressExt[i]) == 0)
             return false;
     }
 
@@ -383,7 +383,7 @@ bool okayToCompress(Bundle* bundle, const String8& pathName)
         if (pos < 0) {
             continue;
         }
-        const char* path = pathName.string();
+        const char* path = pathName.c_str();
         if (strcasecmp(path + pos, str) == 0) {
             return false;
         }
diff --git a/tools/aapt/Resource.cpp b/tools/aapt/Resource.cpp
index dd3ebdbdea09..4ca3a68d02a6 100644
--- a/tools/aapt/Resource.cpp
+++ b/tools/aapt/Resource.cpp
@@ -57,8 +57,8 @@ public:
 
 String8 parseResourceName(const String8& leaf)
 {
-    const char* firstDot = strchr(leaf.string(), '.');
-    const char* str = leaf.string();
+    const char* firstDot = strchr(leaf.c_str(), '.');
+    const char* str = leaf.c_str();
 
     if (firstDot) {
         return String8(str, firstDot-str);
@@ -132,7 +132,7 @@ public:
             mParams = file->getGroupEntry().toParams();
             if (kIsDebug) {
                 printf("Dir %s: mcc=%d mnc=%d lang=%c%c cnt=%c%c orient=%d ui=%d density=%d touch=%d key=%d inp=%d nav=%d\n",
-                        group->getPath().string(), mParams.mcc, mParams.mnc,
+                        group->getPath().c_str(), mParams.mcc, mParams.mnc,
                         mParams.language[0] ? mParams.language[0] : '-',
                         mParams.language[1] ? mParams.language[1] : '-',
                         mParams.country[0] ? mParams.country[0] : '-',
@@ -147,12 +147,12 @@ public:
             mBaseName = parseResourceName(leaf);
             if (mBaseName == "") {
                 fprintf(stderr, "Error: malformed resource filename %s\n",
-                        file->getPrintableSource().string());
+                        file->getPrintableSource().c_str());
                 return UNKNOWN_ERROR;
             }
 
             if (kIsDebug) {
-                printf("file name=%s\n", mBaseName.string());
+                printf("file name=%s\n", mBaseName.c_str());
             }
 
             return NO_ERROR;
@@ -222,7 +222,7 @@ static status_t parsePackage(Bundle* bundle, const sp<AaptAssets>& assets,
 {
     if (grp->getFiles().size() != 1) {
         fprintf(stderr, "warning: Multiple AndroidManifest.xml files found, using %s\n",
-                grp->getFiles().valueAt(0)->getPrintableSource().string());
+                grp->getFiles().valueAt(0)->getPrintableSource().c_str());
     }
 
     sp<AaptFile> file = grp->getFiles().valueAt(0);
@@ -243,20 +243,20 @@ static status_t parsePackage(Bundle* bundle, const sp<AaptAssets>& assets,
     size_t len;
     if (code != ResXMLTree::START_TAG) {
         fprintf(stderr, "%s:%d: No start tag found\n",
-                file->getPrintableSource().string(), block.getLineNumber());
+                file->getPrintableSource().c_str(), block.getLineNumber());
         return UNKNOWN_ERROR;
     }
-    if (strcmp16(block.getElementName(&len), String16("manifest").string()) != 0) {
+    if (strcmp16(block.getElementName(&len), String16("manifest").c_str()) != 0) {
         fprintf(stderr, "%s:%d: Invalid start tag %s, expected <manifest>\n",
-                file->getPrintableSource().string(), block.getLineNumber(),
-                String8(block.getElementName(&len)).string());
+                file->getPrintableSource().c_str(), block.getLineNumber(),
+                String8(block.getElementName(&len)).c_str());
         return UNKNOWN_ERROR;
     }
 
     ssize_t nameIndex = block.indexOfAttribute(NULL, "package");
     if (nameIndex < 0) {
         fprintf(stderr, "%s:%d: <manifest> does not have package attribute.\n",
-                file->getPrintableSource().string(), block.getLineNumber());
+                file->getPrintableSource().c_str(), block.getLineNumber());
         return UNKNOWN_ERROR;
     }
 
@@ -264,19 +264,19 @@ static status_t parsePackage(Bundle* bundle, const sp<AaptAssets>& assets,
 
     ssize_t revisionCodeIndex = block.indexOfAttribute(RESOURCES_ANDROID_NAMESPACE, "revisionCode");
     if (revisionCodeIndex >= 0) {
-        bundle->setRevisionCode(String8(block.getAttributeStringValue(revisionCodeIndex, &len)).string());
+        bundle->setRevisionCode(String8(block.getAttributeStringValue(revisionCodeIndex, &len)).c_str());
     }
 
     String16 uses_sdk16("uses-sdk");
     while ((code=block.next()) != ResXMLTree::END_DOCUMENT
            && code != ResXMLTree::BAD_DOCUMENT) {
         if (code == ResXMLTree::START_TAG) {
-            if (strcmp16(block.getElementName(&len), uses_sdk16.string()) == 0) {
+            if (strcmp16(block.getElementName(&len), uses_sdk16.c_str()) == 0) {
                 ssize_t minSdkIndex = block.indexOfAttribute(RESOURCES_ANDROID_NAMESPACE,
                                                              "minSdkVersion");
                 if (minSdkIndex >= 0) {
                     const char16_t* minSdk16 = block.getAttributeStringValue(minSdkIndex, &len);
-                    const char* minSdk8 = strdup(String8(minSdk16).string());
+                    const char* minSdk8 = strdup(String8(minSdk16).c_str());
                     bundle->setManifestMinSdkVersion(minSdk8);
                 }
             }
@@ -305,17 +305,17 @@ static status_t makeFileResources(Bundle* bundle, const sp<AaptAssets>& assets,
     while ((res=it.next()) == NO_ERROR) {
         if (bundle->getVerbose()) {
             printf("    (new resource id %s from %s)\n",
-                   it.getBaseName().string(), it.getFile()->getPrintableSource().string());
+                   it.getBaseName().c_str(), it.getFile()->getPrintableSource().c_str());
         }
         String16 baseName(it.getBaseName());
-        const char16_t* str = baseName.string();
+        const char16_t* str = baseName.c_str();
         const char16_t* const end = str + baseName.size();
         while (str < end) {
             if (!((*str >= 'a' && *str <= 'z')
                     || (*str >= '0' && *str <= '9')
                     || *str == '_' || *str == '.')) {
                 fprintf(stderr, "%s: Invalid file name: must contain only [a-z0-9_.]\n",
-                        it.getPath().string());
+                        it.getPath().c_str());
                 hasErrors = true;
             }
             str++;
@@ -413,7 +413,7 @@ static void collect_files(const sp<AaptDir>& dir,
             sp<ResourceTypeSet> set = new ResourceTypeSet();
             if (kIsDebug) {
                 printf("Creating new resource type set for leaf %s with group %s (%p)\n",
-                        leafName.string(), group->getPath().string(), group.get());
+                        leafName.c_str(), group->getPath().c_str(), group.get());
             }
             set->add(leafName, group);
             resources->add(resType, set);
@@ -423,21 +423,21 @@ static void collect_files(const sp<AaptDir>& dir,
             if (index < 0) {
                 if (kIsDebug) {
                     printf("Adding to resource type set for leaf %s group %s (%p)\n",
-                            leafName.string(), group->getPath().string(), group.get());
+                            leafName.c_str(), group->getPath().c_str(), group.get());
                 }
                 set->add(leafName, group);
             } else {
                 sp<AaptGroup> existingGroup = set->valueAt(index);
                 if (kIsDebug) {
                     printf("Extending to resource type set for leaf %s group %s (%p)\n",
-                            leafName.string(), group->getPath().string(), group.get());
+                            leafName.c_str(), group->getPath().c_str(), group.get());
                 }
                 for (size_t j=0; j<files.size(); j++) {
                     if (kIsDebug) {
                         printf("Adding file %s in group %s resType %s\n",
-                                files.valueAt(j)->getSourceFile().string(),
-                                files.keyAt(j).toDirName(String8()).string(),
-                                resType.string());
+                                files.valueAt(j)->getSourceFile().c_str(),
+                                files.keyAt(j).toDirName(String8()).c_str(),
+                                resType.c_str());
                     }
                     existingGroup->addFile(files.valueAt(j));
                 }
@@ -455,14 +455,14 @@ static void collect_files(const sp<AaptAssets>& ass,
     for (int i=0; i<N; i++) {
         const sp<AaptDir>& d = dirs.itemAt(i);
         if (kIsDebug) {
-            printf("Collecting dir #%d %p: %s, leaf %s\n", i, d.get(), d->getPath().string(),
-                    d->getLeaf().string());
+            printf("Collecting dir #%d %p: %s, leaf %s\n", i, d.get(), d->getPath().c_str(),
+                    d->getLeaf().c_str());
         }
         collect_files(d, resources);
 
         // don't try to include the res dir
         if (kIsDebug) {
-            printf("Removing dir leaf %s\n", d->getLeaf().string());
+            printf("Removing dir leaf %s\n", d->getLeaf().c_str());
         }
         ass->removeDir(d->getLeaf());
     }
@@ -490,8 +490,8 @@ static int validateAttr(const String8& path, const ResTable& table,
             int strIdx;
             if ((strIdx=table.resolveReference(&value, 0x10000000, NULL, &specFlags)) < 0) {
                 fprintf(stderr, "%s:%d: Tag <%s> attribute %s references unknown resid 0x%08x.\n",
-                        path.string(), parser.getLineNumber(),
-                        String8(parser.getElementName(&len)).string(), attr,
+                        path.c_str(), parser.getLineNumber(),
+                        String8(parser.getElementName(&len)).c_str(), attr,
                         value.data);
                 return ATTR_NOT_FOUND;
             }
@@ -502,12 +502,12 @@ static int validateAttr(const String8& path, const ResTable& table,
                 str = pool->stringAt(value.data, &len);
             }
             printf("***** RES ATTR: %s specFlags=0x%x strIdx=%d: %s\n", attr,
-                    specFlags, strIdx, str != NULL ? String8(str).string() : "???");
+                    specFlags, strIdx, str != NULL ? String8(str).c_str() : "???");
             #endif
             if ((specFlags&~ResTable_typeSpec::SPEC_PUBLIC) != 0 && false) {
                 fprintf(stderr, "%s:%d: Tag <%s> attribute %s varies by configurations 0x%x.\n",
-                        path.string(), parser.getLineNumber(),
-                        String8(parser.getElementName(&len)).string(), attr,
+                        path.c_str(), parser.getLineNumber(),
+                        String8(parser.getElementName(&len)).c_str(), attr,
                         specFlags);
                 return ATTR_NOT_FOUND;
             }
@@ -515,20 +515,20 @@ static int validateAttr(const String8& path, const ResTable& table,
         if (value.dataType == Res_value::TYPE_STRING) {
             if (pool == NULL) {
                 fprintf(stderr, "%s:%d: Tag <%s> attribute %s has no string block.\n",
-                        path.string(), parser.getLineNumber(),
-                        String8(parser.getElementName(&len)).string(), attr);
+                        path.c_str(), parser.getLineNumber(),
+                        String8(parser.getElementName(&len)).c_str(), attr);
                 return ATTR_NOT_FOUND;
             }
             if ((str = UnpackOptionalString(pool->stringAt(value.data), &len)) == NULL) {
                 fprintf(stderr, "%s:%d: Tag <%s> attribute %s has corrupt string value.\n",
-                        path.string(), parser.getLineNumber(),
-                        String8(parser.getElementName(&len)).string(), attr);
+                        path.c_str(), parser.getLineNumber(),
+                        String8(parser.getElementName(&len)).c_str(), attr);
                 return ATTR_NOT_FOUND;
             }
         } else {
             fprintf(stderr, "%s:%d: Tag <%s> attribute %s has invalid type %d.\n",
-                    path.string(), parser.getLineNumber(),
-                    String8(parser.getElementName(&len)).string(), attr,
+                    path.c_str(), parser.getLineNumber(),
+                    String8(parser.getElementName(&len)).c_str(), attr,
                     value.dataType);
             return ATTR_NOT_FOUND;
         }
@@ -546,30 +546,30 @@ static int validateAttr(const String8& path, const ResTable& table,
                 }
                 if (!okay) {
                     fprintf(stderr, "%s:%d: Tag <%s> attribute %s has invalid character '%c'.\n",
-                            path.string(), parser.getLineNumber(),
-                            String8(parser.getElementName(&len)).string(), attr, (char)str[i]);
+                            path.c_str(), parser.getLineNumber(),
+                            String8(parser.getElementName(&len)).c_str(), attr, (char)str[i]);
                     return (int)i;
                 }
             }
         }
         if (*str == ' ') {
             fprintf(stderr, "%s:%d: Tag <%s> attribute %s can not start with a space.\n",
-                    path.string(), parser.getLineNumber(),
-                    String8(parser.getElementName(&len)).string(), attr);
+                    path.c_str(), parser.getLineNumber(),
+                    String8(parser.getElementName(&len)).c_str(), attr);
             return ATTR_LEADING_SPACES;
         }
         if (len != 0 && str[len-1] == ' ') {
             fprintf(stderr, "%s:%d: Tag <%s> attribute %s can not end with a space.\n",
-                    path.string(), parser.getLineNumber(),
-                    String8(parser.getElementName(&len)).string(), attr);
+                    path.c_str(), parser.getLineNumber(),
+                    String8(parser.getElementName(&len)).c_str(), attr);
             return ATTR_TRAILING_SPACES;
         }
         return ATTR_OKAY;
     }
     if (required) {
         fprintf(stderr, "%s:%d: Tag <%s> missing required attribute %s.\n",
-                path.string(), parser.getLineNumber(),
-                String8(parser.getElementName(&len)).string(), attr);
+                path.c_str(), parser.getLineNumber(),
+                String8(parser.getElementName(&len)).c_str(), attr);
         return ATTR_NOT_FOUND;
     }
     return ATTR_OKAY;
@@ -584,7 +584,7 @@ static void checkForIds(const String8& path, ResXMLParser& parser)
             ssize_t index = parser.indexOfAttribute(NULL, "id");
             if (index >= 0) {
                 fprintf(stderr, "%s:%d: warning: found plain 'id' attribute; did you mean the new 'android:id' name?\n",
-                        path.string(), parser.getLineNumber());
+                        path.c_str(), parser.getLineNumber());
             }
         }
     }
@@ -618,7 +618,7 @@ static bool applyFileOverlay(Bundle *bundle,
             size_t overlayCount = overlaySet->size();
             for (size_t overlayIndex=0; overlayIndex<overlayCount; overlayIndex++) {
                 if (bundle->getVerbose()) {
-                    printf("trying overlaySet Key=%s\n",overlaySet->keyAt(overlayIndex).string());
+                    printf("trying overlaySet Key=%s\n",overlaySet->keyAt(overlayIndex).c_str());
                 }
                 ssize_t baseIndex = -1;
                 if (baseSet->get() != NULL) {
@@ -638,11 +638,11 @@ static bool applyFileOverlay(Bundle *bundle,
                                 baseGroup->getFiles();
                         for (size_t i=0; i < baseFiles.size(); i++) {
                             printf("baseFile " ZD " has flavor %s\n", (ZD_TYPE) i,
-                                    baseFiles.keyAt(i).toString().string());
+                                    baseFiles.keyAt(i).toString().c_str());
                         }
                         for (size_t i=0; i < overlayFiles.size(); i++) {
                             printf("overlayFile " ZD " has flavor %s\n", (ZD_TYPE) i,
-                                    overlayFiles.keyAt(i).toString().string());
+                                    overlayFiles.keyAt(i).toString().c_str());
                         }
                     }
 
@@ -657,16 +657,16 @@ static bool applyFileOverlay(Bundle *bundle,
                             if (bundle->getVerbose()) {
                                 printf("found a match (" ZD ") for overlay file %s, for flavor %s\n",
                                         (ZD_TYPE) baseFileIndex,
-                                        overlayGroup->getLeaf().string(),
-                                        overlayFiles.keyAt(overlayGroupIndex).toString().string());
+                                        overlayGroup->getLeaf().c_str(),
+                                        overlayFiles.keyAt(overlayGroupIndex).toString().c_str());
                             }
                             baseGroup->removeFile(baseFileIndex);
                         } else {
                             // didn't find a match fall through and add it..
                             if (true || bundle->getVerbose()) {
                                 printf("nothing matches overlay file %s, for flavor %s\n",
-                                        overlayGroup->getLeaf().string(),
-                                        overlayFiles.keyAt(overlayGroupIndex).toString().string());
+                                        overlayGroup->getLeaf().c_str(),
+                                        overlayFiles.keyAt(overlayGroupIndex).toString().c_str());
                             }
                         }
                         baseGroup->addFile(overlayFiles.valueAt(overlayGroupIndex));
@@ -728,7 +728,7 @@ bool addTagAttribute(const sp<XMLNode>& node, const char* ns8,
         if (errorOnFailedInsert) {
             fprintf(stderr, "Error: AndroidManifest.xml already defines %s (in %s);"
                             " cannot insert new value %s.\n",
-                    String8(attr).string(), String8(ns).string(), value);
+                    String8(attr).c_str(), String8(ns).c_str(), value);
             return false;
         }
 
@@ -763,7 +763,7 @@ static void fullyQualifyClassName(const String8& package, const sp<XMLNode>& nod
         // .asdf  .a.b  --> package.asdf package.a.b
         // asdf.adsf --> asdf.asdf
         String8 className;
-        const char* p = name.string();
+        const char* p = name.c_str();
         const char* q = strchr(p, '.');
         if (p == q) {
             className += package;
@@ -776,7 +776,7 @@ static void fullyQualifyClassName(const String8& package, const sp<XMLNode>& nod
             className += name;
         }
         if (kIsDebug) {
-            printf("Qualifying class '%s' to '%s'", name.string(), className.string());
+            printf("Qualifying class '%s' to '%s'", name.c_str(), className.c_str());
         }
         attr->string.setTo(String16(className));
     }
@@ -810,7 +810,7 @@ static void massageRoundIconSupport(const String16& iconRef, const String16& rou
   const char* err;
 
   String16 iconPackage, iconType, iconName;
-  if (!ResTable::expandResourceRef(iconRef.string(), iconRef.size(), &iconPackage, &iconType,
+  if (!ResTable::expandResourceRef(iconRef.c_str(), iconRef.size(), &iconPackage, &iconType,
                                    &iconName, NULL, &table->getAssetsPackage(), &err,
                                    &publicOnly)) {
       // Errors will be raised in later XML compilation.
@@ -824,7 +824,7 @@ static void massageRoundIconSupport(const String16& iconRef, const String16& rou
   }
 
   String16 roundIconPackage, roundIconType, roundIconName;
-  if (!ResTable::expandResourceRef(roundIconRef.string(), roundIconRef.size(), &roundIconPackage,
+  if (!ResTable::expandResourceRef(roundIconRef.c_str(), roundIconRef.size(), &roundIconPackage,
                                    &roundIconType, &roundIconName, NULL, &table->getAssetsPackage(),
                                    &err, &publicOnly)) {
       // Errors will be raised in later XML compilation.
@@ -839,9 +839,9 @@ static void massageRoundIconSupport(const String16& iconRef, const String16& rou
       return;
   }
 
-  String16 aliasValue = String16(String8::format("@%s:%s/%s", String8(iconPackage).string(),
-                                                 String8(iconType).string(),
-                                                 String8(iconName).string()));
+  String16 aliasValue = String16(String8::format("@%s:%s/%s", String8(iconPackage).c_str(),
+                                                 String8(iconType).c_str(),
+                                                 String8(iconName).c_str()));
 
   // Add an equivalent v26 entry to the roundIcon for each v26 variant of the regular icon.
   const DefaultKeyedVector<ConfigDescription, sp<ResourceTable::Entry>>& configList =
@@ -872,7 +872,7 @@ status_t massageManifest(Bundle* bundle, ResourceTable* table, sp<XMLNode> root)
         const XMLNode::attribute_entry* attr = root->getAttribute(
                 String16(RESOURCES_ANDROID_NAMESPACE), String16("versionCode"));
         if (attr != NULL) {
-            bundle->setVersionCode(strdup(String8(attr->string).string()));
+            bundle->setVersionCode(strdup(String8(attr->string).c_str()));
         }
     }
 
@@ -883,7 +883,7 @@ status_t massageManifest(Bundle* bundle, ResourceTable* table, sp<XMLNode> root)
         const XMLNode::attribute_entry* attr = root->getAttribute(
                 String16(RESOURCES_ANDROID_NAMESPACE), String16("versionName"));
         if (attr != NULL) {
-            bundle->setVersionName(strdup(String8(attr->string).string()));
+            bundle->setVersionName(strdup(String8(attr->string).c_str()));
         }
     }
     
@@ -914,7 +914,7 @@ status_t massageManifest(Bundle* bundle, ResourceTable* table, sp<XMLNode> root)
         const XMLNode::attribute_entry* attr = vers->getAttribute(
                 String16(RESOURCES_ANDROID_NAMESPACE), String16("minSdkVersion"));
         if (attr != NULL) {
-            bundle->setMinSdkVersion(strdup(String8(attr->string).string()));
+            bundle->setMinSdkVersion(strdup(String8(attr->string).c_str()));
         }
     }
 
@@ -970,7 +970,7 @@ status_t massageManifest(Bundle* bundle, ResourceTable* table, sp<XMLNode> root)
         String8 origPackage(attr->string);
         attr->string.setTo(String16(manifestPackageNameOverride));
         if (kIsDebug) {
-            printf("Overriding package '%s' to be '%s'\n", origPackage.string(),
+            printf("Overriding package '%s' to be '%s'\n", origPackage.c_str(),
                     manifestPackageNameOverride);
         }
 
@@ -1071,7 +1071,7 @@ enum {
 static ssize_t extractPlatformBuildVersion(const ResTable& table, ResXMLTree& tree, Bundle* bundle) {
     // First check if we should be recording the compileSdkVersion* attributes.
     static const String16 compileSdkVersionName("android:attr/compileSdkVersion");
-    const bool useCompileSdkVersion = table.identifierForName(compileSdkVersionName.string(),
+    const bool useCompileSdkVersion = table.identifierForName(compileSdkVersionName.c_str(),
                                                               compileSdkVersionName.size()) != 0u;
 
     size_t len;
@@ -1223,7 +1223,7 @@ status_t generateAndroidManifestForSplit(Bundle* bundle, const sp<AaptAssets>& a
     // Add the 'revisionCode' attribute, which is set to the original revisionCode.
     if (bundle->getRevisionCode().size() > 0) {
         if (!addTagAttribute(manifest, RESOURCES_ANDROID_NAMESPACE, "revisionCode",
-                    bundle->getRevisionCode().string(), true, true)) {
+                    bundle->getRevisionCode().c_str(), true, true)) {
             return UNKNOWN_ERROR;
         }
     }
@@ -1270,7 +1270,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
     }
 
     if (kIsDebug) {
-        printf("Creating resources for package %s\n", assets->getPackage().string());
+        printf("Creating resources for package %s\n", assets->getPackage().c_str());
     }
 
     // Set the private symbols package if it was declared.
@@ -1804,7 +1804,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                     flattenedTable, split->isBase());
             if (err != NO_ERROR) {
                 fprintf(stderr, "Failed to generate resource table for split '%s'\n",
-                        split->getPrintableName().string());
+                        split->getPrintableName().c_str());
                 return err;
             }
             split->addEntry(String8("resources.arsc"), flattenedTable);
@@ -1821,7 +1821,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                 err = resTable.add(flattenedTable->getData(), flattenedTable->getSize());
                 if (err != NO_ERROR) {
                     fprintf(stderr, "Generated resource table for split '%s' is corrupt.\n",
-                            split->getPrintableName().string());
+                            split->getPrintableName().c_str());
                     return err;
                 }
 
@@ -1849,7 +1849,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                             if (block < 0) {
                                 hasError = true;
                                 SourcePos().error("%s has no definition for density split '%s'",
-                                        symbol.toString().string(), config.toString().string());
+                                        symbol.toString().c_str(), config.toString().c_str());
 
                                 if (bundle->getVerbose()) {
                                     const Vector<SymbolDefinition>& defs = densityVaryingResources[k];
@@ -1857,7 +1857,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                                     for (size_t d = 0; d < defCount; d++) {
                                         const SymbolDefinition& def = defs[d];
                                         def.source.error("%s has definition for %s",
-                                                symbol.toString().string(), def.config.toString().string());
+                                                symbol.toString().c_str(), def.config.toString().c_str());
                                     }
 
                                     if (defCount < defs.size()) {
@@ -1880,7 +1880,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                         generatedManifest, &table);
                 if (err != NO_ERROR) {
                     fprintf(stderr, "Failed to generate AndroidManifest.xml for split '%s'\n",
-                            split->getPrintableName().string());
+                            split->getPrintableName().c_str());
                     return err;
                 }
                 split->addEntry(String8("AndroidManifest.xml"), generatedManifest);
@@ -1960,7 +1960,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
             if (block.getElementNamespace(&len) != NULL) {
                 continue;
             }
-            if (strcmp16(block.getElementName(&len), manifest16.string()) == 0) {
+            if (strcmp16(block.getElementName(&len), manifest16.c_str()) == 0) {
                 if (validateAttr(manifestPath, finalResTable, block, NULL, "package",
                                  packageIdentChars, true) != ATTR_OKAY) {
                     hasErrors = true;
@@ -1969,10 +1969,10 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                                  "sharedUserId", packageIdentChars, false) != ATTR_OKAY) {
                     hasErrors = true;
                 }
-            } else if (strcmp16(block.getElementName(&len), permission16.string()) == 0
-                    || strcmp16(block.getElementName(&len), permission_group16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), permission16.c_str()) == 0
+                    || strcmp16(block.getElementName(&len), permission_group16.c_str()) == 0) {
                 const bool isGroup = strcmp16(block.getElementName(&len),
-                        permission_group16.string()) == 0;
+                        permission_group16.c_str()) == 0;
                 if (validateAttr(manifestPath, finalResTable, block, RESOURCES_ANDROID_NAMESPACE,
                                  "name", isGroup ? packageIdentCharsWithTheStupid
                                  : packageIdentChars, true) != ATTR_OKAY) {
@@ -2002,8 +2002,8 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                 const char16_t* id = block.getAttributeStringValue(index, &len);
                 if (id == NULL) {
                     fprintf(stderr, "%s:%d: missing name attribute in element <%s>.\n", 
-                            manifestPath.string(), block.getLineNumber(),
-                            String8(block.getElementName(&len)).string());
+                            manifestPath.c_str(), block.getLineNumber(),
+                            String8(block.getElementName(&len)).c_str());
                     hasErrors = true;
                     break;
                 }
@@ -2038,23 +2038,23 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                 if (begins_with_digit || (e != p && *(e-1) != '.')) {
                   fprintf(stderr,
                           "%s:%d: Permission name <%s> is not a valid Java symbol\n",
-                          manifestPath.string(), block.getLineNumber(), idStr.string());
+                          manifestPath.c_str(), block.getLineNumber(), idStr.c_str());
                   hasErrors = true;
                 }
                 syms->addStringSymbol(String8(e), idStr, srcPos);
                 const char16_t* cmt = block.getComment(&len);
                 if (cmt != NULL && *cmt != 0) {
-                    //printf("Comment of %s: %s\n", String8(e).string(),
-                    //        String8(cmt).string());
+                    //printf("Comment of %s: %s\n", String8(e).c_str(),
+                    //        String8(cmt).c_str());
                     syms->appendComment(String8(e), String16(cmt), srcPos);
                 }
                 syms->makeSymbolPublic(String8(e), srcPos);
-            } else if (strcmp16(block.getElementName(&len), uses_permission16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), uses_permission16.c_str()) == 0) {
                 if (validateAttr(manifestPath, finalResTable, block, RESOURCES_ANDROID_NAMESPACE,
                                  "name", packageIdentChars, true) != ATTR_OKAY) {
                     hasErrors = true;
                 }
-            } else if (strcmp16(block.getElementName(&len), instrumentation16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), instrumentation16.c_str()) == 0) {
                 if (validateAttr(manifestPath, finalResTable, block, RESOURCES_ANDROID_NAMESPACE,
                                  "name", classIdentChars, true) != ATTR_OKAY) {
                     hasErrors = true;
@@ -2064,7 +2064,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                                  packageIdentChars, true) != ATTR_OKAY) {
                     hasErrors = true;
                 }
-            } else if (strcmp16(block.getElementName(&len), application16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), application16.c_str()) == 0) {
                 if (validateAttr(manifestPath, finalResTable, block, RESOURCES_ANDROID_NAMESPACE,
                                  "name", classIdentChars, false) != ATTR_OKAY) {
                     hasErrors = true;
@@ -2084,7 +2084,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                                  processIdentChars, false) != ATTR_OKAY) {
                     hasErrors = true;
                 }
-            } else if (strcmp16(block.getElementName(&len), provider16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), provider16.c_str()) == 0) {
                 if (validateAttr(manifestPath, finalResTable, block, RESOURCES_ANDROID_NAMESPACE,
                                  "name", classIdentChars, true) != ATTR_OKAY) {
                     hasErrors = true;
@@ -2104,9 +2104,9 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                                  processIdentChars, false) != ATTR_OKAY) {
                     hasErrors = true;
                 }
-            } else if (strcmp16(block.getElementName(&len), service16.string()) == 0
-                       || strcmp16(block.getElementName(&len), receiver16.string()) == 0
-                       || strcmp16(block.getElementName(&len), activity16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), service16.c_str()) == 0
+                       || strcmp16(block.getElementName(&len), receiver16.c_str()) == 0
+                       || strcmp16(block.getElementName(&len), activity16.c_str()) == 0) {
                 if (validateAttr(manifestPath, finalResTable, block, RESOURCES_ANDROID_NAMESPACE,
                                  "name", classIdentChars, true) != ATTR_OKAY) {
                     hasErrors = true;
@@ -2126,14 +2126,14 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                                  processIdentChars, false) != ATTR_OKAY) {
                     hasErrors = true;
                 }
-            } else if (strcmp16(block.getElementName(&len), action16.string()) == 0
-                       || strcmp16(block.getElementName(&len), category16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), action16.c_str()) == 0
+                       || strcmp16(block.getElementName(&len), category16.c_str()) == 0) {
                 if (validateAttr(manifestPath, finalResTable, block,
                                  RESOURCES_ANDROID_NAMESPACE, "name",
                                  packageIdentChars, true) != ATTR_OKAY) {
                     hasErrors = true;
                 }
-            } else if (strcmp16(block.getElementName(&len), data16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), data16.c_str()) == 0) {
                 if (validateAttr(manifestPath, finalResTable, block,
                                  RESOURCES_ANDROID_NAMESPACE, "mimeType",
                                  typeIdentChars, true) != ATTR_OKAY) {
@@ -2144,13 +2144,13 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                                  schemeIdentChars, true) != ATTR_OKAY) {
                     hasErrors = true;
                 }
-            } else if (strcmp16(block.getElementName(&len), feature_group16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), feature_group16.c_str()) == 0) {
                 int depth = 1;
                 while ((code=block.next()) != ResXMLTree::END_DOCUMENT
                        && code > ResXMLTree::BAD_DOCUMENT) {
                     if (code == ResXMLTree::START_TAG) {
                         depth++;
-                        if (strcmp16(block.getElementName(&len), uses_feature16.string()) == 0) {
+                        if (strcmp16(block.getElementName(&len), uses_feature16.c_str()) == 0) {
                             ssize_t idx = block.indexOfAttribute(
                                     RESOURCES_ANDROID_NAMESPACE, "required");
                             if (idx < 0) {
@@ -2162,7 +2162,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                                 fprintf(stderr, "%s:%d: Tag <uses-feature> can not have "
                                         "android:required=\"false\" when inside a "
                                         "<feature-group> tag.\n",
-                                        manifestPath.string(), block.getLineNumber());
+                                        manifestPath.c_str(), block.getLineNumber());
                                 hasErrors = true;
                             }
                         }
@@ -2222,7 +2222,7 @@ static String8 flattenSymbol(const String8& symbol) {
 static String8 getSymbolPackage(const String8& symbol, const sp<AaptAssets>& assets, bool pub) {
     ssize_t colon = symbol.find(":", 0);
     if (colon >= 0) {
-        return String8(symbol.string(), colon);
+        return String8(symbol.c_str(), colon);
     }
     return pub ? assets->getPackage() : assets->getSymbolsPrivatePackage();
 }
@@ -2230,7 +2230,7 @@ static String8 getSymbolPackage(const String8& symbol, const sp<AaptAssets>& ass
 static String8 getSymbolName(const String8& symbol) {
     ssize_t colon = symbol.find(":", 0);
     if (colon >= 0) {
-        return String8(symbol.string() + colon + 1);
+        return String8(symbol.c_str() + colon + 1);
     }
     return symbol;
 }
@@ -2245,7 +2245,7 @@ static String16 getAttributeComment(const sp<AaptAssets>& assets,
         asym = asym->getNestedSymbols().valueFor(String8("attr"));
         if (asym != NULL) {
             //printf("Got attrs symbols! comment %s=%s\n",
-            //     name.string(), String8(asym->getComment(name)).string());
+            //     name.c_str(), String8(asym->getComment(name)).c_str());
             if (outTypeComment != NULL) {
                 *outTypeComment = asym->getTypeComment(name);
             }
@@ -2276,8 +2276,8 @@ static status_t writeResourceLoadedCallbackForLayoutClasses(
                 "%sfor(int i = 0; i < styleable.%s.length; ++i) {\n"
                 "%sstyleable.%s[i] = (styleable.%s[i] & 0x00ffffff) | (packageId << 24);\n"
                 "%s}\n",
-                indentStr, nclassName.string(),
-                getIndentSpace(indent+1), nclassName.string(), nclassName.string(),
+                indentStr, nclassName.c_str(),
+                getIndentSpace(indent+1), nclassName.c_str(), nclassName.c_str(),
                 indentStr);
     }
 
@@ -2303,8 +2303,8 @@ static status_t writeResourceLoadedCallback(
         String8 flat_name(flattenSymbol(sym.name));
         fprintf(fp,
                 "%s%s.%s = (%s.%s & 0x00ffffff) | (packageId << 24);\n",
-                getIndentSpace(indent), className.string(), flat_name.string(),
-                className.string(), flat_name.string());
+                getIndentSpace(indent), className.c_str(), flat_name.c_str(),
+                className.c_str(), flat_name.c_str());
     }
 
     N = symbols->getNestedSymbols().size();
@@ -2365,12 +2365,12 @@ static status_t writeLayoutClasses(
                 String16 name16(sym.name);
                 uint32_t typeSpecFlags;
                 code = assets->getIncludedResources().identifierForName(
-                    name16.string(), name16.size(),
-                    attr16.string(), attr16.size(),
-                    package16.string(), package16.size(), &typeSpecFlags);
+                    name16.c_str(), name16.size(),
+                    attr16.c_str(), attr16.size(),
+                    package16.c_str(), package16.size(), &typeSpecFlags);
                 if (code == 0) {
                     fprintf(stderr, "ERROR: In <declare-styleable> %s, unable to find attribute %s\n",
-                            nclassName.string(), sym.name.string());
+                            nclassName.c_str(), sym.name.c_str());
                     hasErrors = true;
                 }
                 isPublic = (typeSpecFlags&ResTable_typeSpec::SPEC_PUBLIC) != 0;
@@ -2388,9 +2388,9 @@ static status_t writeLayoutClasses(
         if (comment.size() > 0) {
             String8 cmt(comment);
             ann.preprocessComment(cmt);
-            fprintf(fp, "%s\n", cmt.string());
+            fprintf(fp, "%s\n", cmt.c_str());
         } else {
-            fprintf(fp, "Attributes that can be used with a %s.\n", nclassName.string());
+            fprintf(fp, "Attributes that can be used with a %s.\n", nclassName.c_str());
         }
         bool hasTable = false;
         for (a=0; a<NA; a++) {
@@ -2423,7 +2423,7 @@ static status_t writeLayoutClasses(
                     continue;
                 }
                 if (comment.size() > 0) {
-                    const char16_t* p = comment.string();
+                    const char16_t* p = comment.c_str();
                     while (*p != 0 && *p != '.') {
                         if (*p == '{') {
                             while (*p != 0 && *p != '}') {
@@ -2436,14 +2436,14 @@ static status_t writeLayoutClasses(
                     if (*p == '.') {
                         p++;
                     }
-                    comment = String16(comment.string(), p-comment.string());
+                    comment = String16(comment.c_str(), p-comment.c_str());
                 }
                 fprintf(fp, "%s   <tr><td><code>{@link #%s_%s %s:%s}</code></td><td>%s</td></tr>\n",
-                        indentStr, nclassName.string(),
-                        flattenSymbol(name8).string(),
-                        getSymbolPackage(name8, assets, true).string(),
-                        getSymbolName(name8).string(),
-                        String8(comment).string());
+                        indentStr, nclassName.c_str(),
+                        flattenSymbol(name8).c_str(),
+                        getSymbolPackage(name8, assets, true).c_str(),
+                        getSymbolName(name8).c_str(),
+                        String8(comment).c_str());
             }
         }
         if (hasTable) {
@@ -2457,8 +2457,8 @@ static status_t writeLayoutClasses(
                     continue;
                 }
                 fprintf(fp, "%s   @see #%s_%s\n",
-                        indentStr, nclassName.string(),
-                        flattenSymbol(sym.name).string());
+                        indentStr, nclassName.c_str(),
+                        flattenSymbol(sym.name).c_str());
             }
         }
         fprintf(fp, "%s */\n", getIndentSpace(indent));
@@ -2468,7 +2468,7 @@ static status_t writeLayoutClasses(
         fprintf(fp,
                 "%spublic static final int[] %s = {\n"
                 "%s",
-                indentStr, nclassName.string(),
+                indentStr, nclassName.c_str(),
                 getIndentSpace(indent+1));
 
         for (a=0; a<NA; a++) {
@@ -2503,11 +2503,11 @@ static status_t writeLayoutClasses(
                 uint32_t typeSpecFlags = 0;
                 String16 name16(sym.name);
                 assets->getIncludedResources().identifierForName(
-                    name16.string(), name16.size(),
-                    attr16.string(), attr16.size(),
-                    package16.string(), package16.size(), &typeSpecFlags);
-                //printf("%s:%s/%s: 0x%08x\n", String8(package16).string(),
-                //    String8(attr16).string(), String8(name16).string(), typeSpecFlags);
+                    name16.c_str(), name16.size(),
+                    attr16.c_str(), attr16.size(),
+                    package16.c_str(), package16.size(), &typeSpecFlags);
+                //printf("%s:%s/%s: 0x%08x\n", String8(package16).c_str(),
+                //    String8(attr16).c_str(), String8(name16).c_str(), typeSpecFlags);
                 const bool pub = (typeSpecFlags&ResTable_typeSpec::SPEC_PUBLIC) != 0;
 
                 AnnotationProcessor ann;
@@ -2516,20 +2516,20 @@ static status_t writeLayoutClasses(
                     String8 cmt(comment);
                     ann.preprocessComment(cmt);
                     fprintf(fp, "%s  <p>\n%s  @attr description\n", indentStr, indentStr);
-                    fprintf(fp, "%s  %s\n", indentStr, cmt.string());
+                    fprintf(fp, "%s  %s\n", indentStr, cmt.c_str());
                 } else {
                     fprintf(fp,
                             "%s  <p>This symbol is the offset where the {@link %s.R.attr#%s}\n"
                             "%s  attribute's value can be found in the {@link #%s} array.\n",
                             indentStr,
-                            getSymbolPackage(name8, assets, pub).string(),
-                            getSymbolName(name8).string(),
-                            indentStr, nclassName.string());
+                            getSymbolPackage(name8, assets, pub).c_str(),
+                            getSymbolName(name8).c_str(),
+                            indentStr, nclassName.c_str());
                 }
                 if (typeComment.size() > 0) {
                     String8 cmt(typeComment);
                     ann.preprocessComment(cmt);
-                    fprintf(fp, "\n\n%s  %s\n", indentStr, cmt.string());
+                    fprintf(fp, "\n\n%s  %s\n", indentStr, cmt.c_str());
                 }
                 if (comment.size() > 0) {
                     if (pub) {
@@ -2537,16 +2537,16 @@ static status_t writeLayoutClasses(
                                 "%s  <p>This corresponds to the global attribute\n"
                                 "%s  resource symbol {@link %s.R.attr#%s}.\n",
                                 indentStr, indentStr,
-                                getSymbolPackage(name8, assets, true).string(),
-                                getSymbolName(name8).string());
+                                getSymbolPackage(name8, assets, true).c_str(),
+                                getSymbolName(name8).c_str());
                     } else {
                         fprintf(fp,
                                 "%s  <p>This is a private symbol.\n", indentStr);
                     }
                 }
                 fprintf(fp, "%s  @attr name %s:%s\n", indentStr,
-                        getSymbolPackage(name8, assets, pub).string(),
-                        getSymbolName(name8).string());
+                        getSymbolPackage(name8, assets, pub).c_str(),
+                        getSymbolName(name8).c_str());
                 fprintf(fp, "%s*/\n", indentStr);
                 ann.printAnnotations(fp, indentStr);
 
@@ -2556,8 +2556,8 @@ static status_t writeLayoutClasses(
 
                 fprintf(fp,
                         id_format,
-                        indentStr, nclassName.string(),
-                        flattenSymbol(name8).string(), (int)pos);
+                        indentStr, nclassName.c_str(),
+                        flattenSymbol(name8).c_str(), (int)pos);
             }
         }
     }
@@ -2598,12 +2598,12 @@ static status_t writeTextLayoutClasses(
                 String16 name16(sym.name);
                 uint32_t typeSpecFlags;
                 code = assets->getIncludedResources().identifierForName(
-                    name16.string(), name16.size(),
-                    attr16.string(), attr16.size(),
-                    package16.string(), package16.size(), &typeSpecFlags);
+                    name16.c_str(), name16.size(),
+                    attr16.c_str(), attr16.size(),
+                    package16.c_str(), package16.size(), &typeSpecFlags);
                 if (code == 0) {
                     fprintf(stderr, "ERROR: In <declare-styleable> %s, unable to find attribute %s\n",
-                            nclassName.string(), sym.name.string());
+                            nclassName.c_str(), sym.name.c_str());
                     hasErrors = true;
                 }
                 isPublic = (typeSpecFlags&ResTable_typeSpec::SPEC_PUBLIC) != 0;
@@ -2615,7 +2615,7 @@ static status_t writeTextLayoutClasses(
 
         NA = idents.size();
 
-        fprintf(fp, "int[] styleable %s {", nclassName.string());
+        fprintf(fp, "int[] styleable %s {", nclassName.c_str());
 
         for (a=0; a<NA; a++) {
             if (a != 0) {
@@ -2645,17 +2645,17 @@ static status_t writeTextLayoutClasses(
                 uint32_t typeSpecFlags = 0;
                 String16 name16(sym.name);
                 assets->getIncludedResources().identifierForName(
-                    name16.string(), name16.size(),
-                    attr16.string(), attr16.size(),
-                    package16.string(), package16.size(), &typeSpecFlags);
-                //printf("%s:%s/%s: 0x%08x\n", String8(package16).string(),
-                //    String8(attr16).string(), String8(name16).string(), typeSpecFlags);
+                    name16.c_str(), name16.size(),
+                    attr16.c_str(), attr16.size(),
+                    package16.c_str(), package16.size(), &typeSpecFlags);
+                //printf("%s:%s/%s: 0x%08x\n", String8(package16).c_str(),
+                //    String8(attr16).c_str(), String8(name16).c_str(), typeSpecFlags);
                 //const bool pub = (typeSpecFlags&ResTable_typeSpec::SPEC_PUBLIC) != 0;
 
                 fprintf(fp,
                         "int styleable %s_%s %d\n",
-                        nclassName.string(),
-                        flattenSymbol(name8).string(), (int)pos);
+                        nclassName.c_str(),
+                        flattenSymbol(name8).c_str(), (int)pos);
             }
         }
     }
@@ -2670,7 +2670,7 @@ static status_t writeSymbolClass(
 {
     fprintf(fp, "%spublic %sfinal class %s {\n",
             getIndentSpace(indent),
-            indent != 0 ? "static " : "", className.string());
+            indent != 0 ? "static " : "", className.c_str());
     indent++;
 
     size_t i;
@@ -2699,7 +2699,7 @@ static status_t writeSymbolClass(
             ann.preprocessComment(cmt);
             fprintf(fp,
                     "%s/** %s\n",
-                    getIndentSpace(indent), cmt.string());
+                    getIndentSpace(indent), cmt.c_str());
         }
         String16 typeComment(sym.typeComment);
         if (typeComment.size() > 0) {
@@ -2708,10 +2708,10 @@ static status_t writeSymbolClass(
             if (!haveComment) {
                 haveComment = true;
                 fprintf(fp,
-                        "%s/** %s\n", getIndentSpace(indent), cmt.string());
+                        "%s/** %s\n", getIndentSpace(indent), cmt.c_str());
             } else {
                 fprintf(fp,
-                        "%s %s\n", getIndentSpace(indent), cmt.string());
+                        "%s %s\n", getIndentSpace(indent), cmt.c_str());
             }
         }
         if (haveComment) {
@@ -2720,7 +2720,7 @@ static status_t writeSymbolClass(
         ann.printAnnotations(fp, getIndentSpace(indent));
         fprintf(fp, id_format,
                 getIndentSpace(indent),
-                flattenSymbol(name8).string(), (int)sym.int32Val);
+                flattenSymbol(name8).c_str(), (int)sym.int32Val);
     }
 
     for (i=0; i<N; i++) {
@@ -2740,13 +2740,13 @@ static status_t writeSymbolClass(
             fprintf(fp,
                     "%s/** %s\n"
                      "%s */\n",
-                    getIndentSpace(indent), cmt.string(),
+                    getIndentSpace(indent), cmt.c_str(),
                     getIndentSpace(indent));
         }
         ann.printAnnotations(fp, getIndentSpace(indent));
         fprintf(fp, "%spublic static final String %s=\"%s\";\n",
                 getIndentSpace(indent),
-                flattenSymbol(name8).string(), sym.stringVal.string());
+                flattenSymbol(name8).c_str(), sym.stringVal.c_str());
     }
 
     sp<AaptSymbols> styleableSymbols;
@@ -2805,8 +2805,8 @@ static status_t writeTextSymbolClass(
 
         String8 name8(sym.name);
         fprintf(fp, "int %s %s 0x%08x\n",
-                className.string(),
-                flattenSymbol(name8).string(), (int)sym.int32Val);
+                className.c_str(),
+                flattenSymbol(name8).c_str(), (int)sym.int32Val);
     }
 
     N = symbols->getNestedSymbols().size();
@@ -2844,7 +2844,7 @@ status_t writeResourceSymbols(Bundle* bundle, const sp<AaptAssets>& assets,
 
         if (bundle->getMakePackageDirs()) {
             const String8& pkg(package);
-            const char* last = pkg.string();
+            const char* last = pkg.c_str();
             const char* s = last-1;
             do {
                 s++;
@@ -2852,9 +2852,9 @@ status_t writeResourceSymbols(Bundle* bundle, const sp<AaptAssets>& assets,
                     String8 part(last, s-last);
                     dest.appendPath(part);
 #ifdef _WIN32
-                    _mkdir(dest.string());
+                    _mkdir(dest.c_str());
 #else
-                    mkdir(dest.string(), S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP);
+                    mkdir(dest.c_str(), S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP);
 #endif
                     last = s+1;
                 }
@@ -2862,14 +2862,14 @@ status_t writeResourceSymbols(Bundle* bundle, const sp<AaptAssets>& assets,
         }
         dest.appendPath(className);
         dest.append(".java");
-        FILE* fp = fopen(dest.string(), "w+");
+        FILE* fp = fopen(dest.c_str(), "w+");
         if (fp == NULL) {
             fprintf(stderr, "ERROR: Unable to open class file %s: %s\n",
-                    dest.string(), strerror(errno));
+                    dest.c_str(), strerror(errno));
             return UNKNOWN_ERROR;
         }
         if (bundle->getVerbose()) {
-            printf("  Writing symbols for class %s.\n", className.string());
+            printf("  Writing symbols for class %s.\n", className.c_str());
         }
 
         fprintf(fp,
@@ -2880,7 +2880,7 @@ status_t writeResourceSymbols(Bundle* bundle, const sp<AaptAssets>& assets,
             " * should not be modified by hand.\n"
             " */\n"
             "\n"
-            "package %s;\n\n", package.string());
+            "package %s;\n\n", package.c_str());
 
         status_t err = writeSymbolClass(fp, assets, includePrivate, symbols,
                 className, 0, bundle->getNonConstantId(), emitCallback);
@@ -2894,14 +2894,14 @@ status_t writeResourceSymbols(Bundle* bundle, const sp<AaptAssets>& assets,
             textDest.appendPath(className);
             textDest.append(".txt");
 
-            FILE* fp = fopen(textDest.string(), "w+");
+            FILE* fp = fopen(textDest.c_str(), "w+");
             if (fp == NULL) {
                 fprintf(stderr, "ERROR: Unable to open text symbol file %s: %s\n",
-                        textDest.string(), strerror(errno));
+                        textDest.c_str(), strerror(errno));
                 return UNKNOWN_ERROR;
             }
             if (bundle->getVerbose()) {
-                printf("  Writing text symbols for class %s.\n", className.string());
+                printf("  Writing text symbols for class %s.\n", className.c_str());
             }
 
             status_t err = writeTextSymbolClass(fp, assets, includePrivate, symbols,
@@ -2919,8 +2919,8 @@ status_t writeResourceSymbols(Bundle* bundle, const sp<AaptAssets>& assets,
             String8 dependencyFile(bundle->getRClassDir());
             dependencyFile.appendPath("R.java.d");
 
-            FILE *fp = fopen(dependencyFile.string(), "a");
-            fprintf(fp,"%s \\\n", dest.string());
+            FILE *fp = fopen(dependencyFile.c_str(), "a");
+            fprintf(fp,"%s \\\n", dest.c_str());
             fclose(fp);
         }
     }
@@ -2956,7 +2956,7 @@ addProguardKeepRule(ProguardKeepSet* keep, const String8& inClassName,
         // asdf     --> package.asdf
         // .asdf  .a.b  --> package.asdf package.a.b
         // asdf.adsf --> asdf.asdf
-        const char* p = className.string();
+        const char* p = className.c_str();
         const char* q = strchr(p, '.');
         if (p == q) {
             className = pkg;
@@ -3023,7 +3023,7 @@ writeProguardForAndroidManifest(ProguardKeepSet* keep, const sp<AaptAssets>& ass
 
     if (assGroup->getFiles().size() != 1) {
         fprintf(stderr, "warning: Multiple AndroidManifest.xml files found, using %s\n",
-                assGroup->getFiles().valueAt(0)->getPrintableSource().string());
+                assGroup->getFiles().valueAt(0)->getPrintableSource().c_str());
     }
 
     assFile = assGroup->getFiles().valueAt(0);
@@ -3048,7 +3048,7 @@ writeProguardForAndroidManifest(ProguardKeepSet* keep, const sp<AaptAssets>& ass
         }
         depth++;
         String8 tag(tree.getElementName(&len));
-        // printf("Depth %d tag %s\n", depth, tag.string());
+        // printf("Depth %d tag %s\n", depth, tag.c_str());
         bool keepTag = false;
         if (depth == 1) {
             if (tag != "manifest") {
@@ -3065,7 +3065,7 @@ writeProguardForAndroidManifest(ProguardKeepSet* keep, const sp<AaptAssets>& ass
                         "http://schemas.android.com/apk/res/android",
                         "backupAgent", &error);
                 if (agent.length() > 0) {
-                    addProguardKeepRule(keep, agent, pkg.string(),
+                    addProguardKeepRule(keep, agent, pkg.c_str(),
                             assFile->getPrintableSource(), tree.getLineNumber());
                 }
 
@@ -3073,7 +3073,7 @@ writeProguardForAndroidManifest(ProguardKeepSet* keep, const sp<AaptAssets>& ass
                     defaultProcess = AaptXml::getAttribute(tree,
                             "http://schemas.android.com/apk/res/android", "process", &error);
                     if (error != "") {
-                        fprintf(stderr, "ERROR: %s\n", error.string());
+                        fprintf(stderr, "ERROR: %s\n", error.c_str());
                         return -1;
                     }
                 }
@@ -3089,7 +3089,7 @@ writeProguardForAndroidManifest(ProguardKeepSet* keep, const sp<AaptAssets>& ass
                     String8 componentProcess = AaptXml::getAttribute(tree,
                             "http://schemas.android.com/apk/res/android", "process", &error);
                     if (error != "") {
-                        fprintf(stderr, "ERROR: %s\n", error.string());
+                        fprintf(stderr, "ERROR: %s\n", error.c_str());
                         return -1;
                     }
 
@@ -3103,14 +3103,14 @@ writeProguardForAndroidManifest(ProguardKeepSet* keep, const sp<AaptAssets>& ass
             String8 name = AaptXml::getAttribute(tree,
                     "http://schemas.android.com/apk/res/android", "name", &error);
             if (error != "") {
-                fprintf(stderr, "ERROR: %s\n", error.string());
+                fprintf(stderr, "ERROR: %s\n", error.c_str());
                 return -1;
             }
 
             keepTag = name.length() > 0;
 
             if (keepTag) {
-                addProguardKeepRule(keep, name, pkg.string(),
+                addProguardKeepRule(keep, name, pkg.c_str(),
                         assFile->getPrintableSource(), tree.getLineNumber());
             }
         }
@@ -3170,7 +3170,7 @@ writeProguardForXml(ProguardKeepSet* keep, const sp<AaptFile>& layoutFile,
         String8 tag(tree.getElementName(&len));
 
         // If there is no '.', we'll assume that it's one of the built in names.
-        if (strchr(tag.string(), '.')) {
+        if (strchr(tag.c_str(), '.')) {
             addProguardKeepRule(keep, tag, NULL,
                     layoutFile->getPrintableSource(), tree.getLineNumber());
         } else if (tagAttrPairs != NULL) {
@@ -3183,8 +3183,8 @@ writeProguardForXml(ProguardKeepSet* keep, const sp<AaptFile>& layoutFile,
                     ssize_t attrIndex = tree.indexOfAttribute(nsAttr.ns, nsAttr.attr);
                     if (attrIndex < 0) {
                         // fprintf(stderr, "%s:%d: <%s> does not have attribute %s:%s.\n",
-                        //        layoutFile->getPrintableSource().string(), tree.getLineNumber(),
-                        //        tag.string(), nsAttr.ns, nsAttr.attr);
+                        //        layoutFile->getPrintableSource().c_str(), tree.getLineNumber(),
+                        //        tag.c_str(), nsAttr.ns, nsAttr.attr);
                     } else {
                         size_t len;
                         addProguardKeepRule(keep,
@@ -3242,7 +3242,7 @@ writeProguardForLayouts(ProguardKeepSet* keep, const sp<AaptAssets>& assets)
 
     // tag:attribute pairs that should be checked in transition files.
     KeyedVector<String8, Vector<NamespaceAttributePair> > kTransitionTagAttrPairs;
-    addTagAttrPair(&kTransitionTagAttrPairs, kTransition.string(), NULL, kClass);
+    addTagAttrPair(&kTransitionTagAttrPairs, kTransition.c_str(), NULL, kClass);
     addTagAttrPair(&kTransitionTagAttrPairs, "pathMotion", NULL, kClass);
 
     const Vector<sp<AaptDir> >& dirs = assets->resDirs();
@@ -3252,16 +3252,16 @@ writeProguardForLayouts(ProguardKeepSet* keep, const sp<AaptAssets>& assets)
         const String8& dirName = d->getLeaf();
         Vector<String8> startTags;
         const KeyedVector<String8, Vector<NamespaceAttributePair> >* tagAttrPairs = NULL;
-        if ((dirName == String8("layout")) || (strncmp(dirName.string(), "layout-", 7) == 0)) {
+        if ((dirName == String8("layout")) || (strncmp(dirName.c_str(), "layout-", 7) == 0)) {
             tagAttrPairs = &kLayoutTagAttrPairs;
-        } else if ((dirName == String8("xml")) || (strncmp(dirName.string(), "xml-", 4) == 0)) {
+        } else if ((dirName == String8("xml")) || (strncmp(dirName.c_str(), "xml-", 4) == 0)) {
             startTags.add(String8("PreferenceScreen"));
             startTags.add(String8("preference-headers"));
             tagAttrPairs = &kXmlTagAttrPairs;
-        } else if ((dirName == String8("menu")) || (strncmp(dirName.string(), "menu-", 5) == 0)) {
+        } else if ((dirName == String8("menu")) || (strncmp(dirName.c_str(), "menu-", 5) == 0)) {
             startTags.add(String8("menu"));
             tagAttrPairs = NULL;
-        } else if (dirName == kTransition || (strncmp(dirName.string(), kTransitionPrefix.string(),
+        } else if (dirName == kTransition || (strncmp(dirName.c_str(), kTransitionPrefix.c_str(),
                         kTransitionPrefix.size()) == 0)) {
             tagAttrPairs = &kTransitionTagAttrPairs;
         } else {
@@ -3307,9 +3307,9 @@ writeProguardSpec(const char* filename, const ProguardKeepSet& keep, status_t er
         const SortedVector<String8>& locations = rules.valueAt(i);
         const size_t M = locations.size();
         for (size_t j=0; j<M; j++) {
-            fprintf(fp, "# %s\n", locations.itemAt(j).string());
+            fprintf(fp, "# %s\n", locations.itemAt(j).c_str());
         }
-        fprintf(fp, "%s\n\n", rules.keyAt(i).string());
+        fprintf(fp, "%s\n\n", rules.keyAt(i).c_str());
     }
     fclose(fp);
 
@@ -3366,7 +3366,7 @@ status_t writePathsToFile(const sp<FilePathStore>& files, FILE* fp)
     status_t deps = -1;
     for (size_t file_i = 0; file_i < files->size(); ++file_i) {
         // Add the full file path to the dependency file
-        fprintf(fp, "%s \\\n", files->itemAt(file_i).string());
+        fprintf(fp, "%s \\\n", files->itemAt(file_i).c_str());
         deps++;
     }
     return deps;
diff --git a/tools/aapt/ResourceFilter.cpp b/tools/aapt/ResourceFilter.cpp
index ed06f605eaeb..cc8dce7e9f3e 100644
--- a/tools/aapt/ResourceFilter.cpp
+++ b/tools/aapt/ResourceFilter.cpp
@@ -32,7 +32,7 @@ WeakResourceFilter::parse(const String8& str)
             // only specify locale in the standard 'en_US' format.
             val.writeTo(&entry.first);
         } else if (!AaptConfig::parse(part, &entry.first)) {
-            fprintf(stderr, "Invalid configuration: %s\n", part.string());
+            fprintf(stderr, "Invalid configuration: %s\n", part.c_str());
             return UNKNOWN_ERROR;
         }
 
@@ -43,7 +43,7 @@ WeakResourceFilter::parse(const String8& str)
 
         // Ignore any densities. Those are best handled in --preferred-density
         if ((entry.second & ResTable_config::CONFIG_DENSITY) != 0) {
-            fprintf(stderr, "warning: ignoring flag -c %s. Use --preferred-density instead.\n", entry.first.toString().string());
+            fprintf(stderr, "warning: ignoring flag -c %s. Use --preferred-density instead.\n", entry.first.toString().c_str());
             entry.first.density = 0;
             entry.second &= ~ResTable_config::CONFIG_DENSITY;
         }
@@ -148,7 +148,7 @@ StrongResourceFilter::parse(const String8& str) {
     mConfigs.clear();
     for (size_t i = 0; i < configStrs.size(); i++) {
         if (!AaptConfig::parse(configStrs[i], &config)) {
-            fprintf(stderr, "Invalid configuration: %s\n", configStrs[i].string());
+            fprintf(stderr, "Invalid configuration: %s\n", configStrs[i].c_str());
             return UNKNOWN_ERROR;
         }
         mConfigs.insert(config);
diff --git a/tools/aapt/ResourceIdCache.cpp b/tools/aapt/ResourceIdCache.cpp
index 8835fb0130a3..1c7788d70053 100644
--- a/tools/aapt/ResourceIdCache.cpp
+++ b/tools/aapt/ResourceIdCache.cpp
@@ -37,7 +37,7 @@ static inline uint32_t hashround(uint32_t hash, int c) {
 
 static uint32_t hash(const android::String16& hashableString) {
     uint32_t hash = 5381;
-    const char16_t* str = hashableString.string();
+    const char16_t* str = hashableString.c_str();
     while (int c = *str++) hash = hashround(hash, c);
     return hash;
 }
diff --git a/tools/aapt/ResourceTable.cpp b/tools/aapt/ResourceTable.cpp
index 47750fc11a6e..3abb89acd23b 100644
--- a/tools/aapt/ResourceTable.cpp
+++ b/tools/aapt/ResourceTable.cpp
@@ -361,10 +361,10 @@ static status_t compileAttribute(const sp<AaptFile>& in,
     ssize_t typeIdx = block.indexOfAttribute(NULL, "format");
     if (typeIdx >= 0) {
         String16 typeStr = String16(block.getAttributeStringValue(typeIdx, &len));
-        attr.type = parse_flags(typeStr.string(), typeStr.size(), gFormatFlags);
+        attr.type = parse_flags(typeStr.c_str(), typeStr.size(), gFormatFlags);
         if (attr.type == 0) {
             attr.sourcePos.error("Tag <attr> 'format' attribute value \"%s\" not valid\n",
-                    String8(typeStr).string());
+                    String8(typeStr).c_str());
             attr.hasErrors = true;
         }
         attr.createIfNeeded(outTable);
@@ -374,14 +374,14 @@ static status_t compileAttribute(const sp<AaptFile>& in,
         attr.createIfNeeded(outTable);
     }
 
-    //printf("Attribute %s: type=0x%08x\n", String8(attr.ident).string(), attr.type);
+    //printf("Attribute %s: type=0x%08x\n", String8(attr.ident).c_str(), attr.type);
 
     ssize_t minIdx = block.indexOfAttribute(NULL, "min");
     if (minIdx >= 0) {
         String16 val = String16(block.getAttributeStringValue(minIdx, &len));
-        if (!ResTable::stringToInt(val.string(), val.size(), NULL)) {
+        if (!ResTable::stringToInt(val.c_str(), val.size(), NULL)) {
             attr.sourcePos.error("Tag <attr> 'min' attribute must be a number, not \"%s\"\n",
-                    String8(val).string());
+                    String8(val).c_str());
             attr.hasErrors = true;
         }
         attr.createIfNeeded(outTable);
@@ -397,9 +397,9 @@ static status_t compileAttribute(const sp<AaptFile>& in,
     ssize_t maxIdx = block.indexOfAttribute(NULL, "max");
     if (maxIdx >= 0) {
         String16 val = String16(block.getAttributeStringValue(maxIdx, &len));
-        if (!ResTable::stringToInt(val.string(), val.size(), NULL)) {
+        if (!ResTable::stringToInt(val.c_str(), val.size(), NULL)) {
             attr.sourcePos.error("Tag <attr> 'max' attribute must be a number, not \"%s\"\n",
-                    String8(val).string());
+                    String8(val).c_str());
             attr.hasErrors = true;
         }
         attr.createIfNeeded(outTable);
@@ -422,7 +422,7 @@ static status_t compileAttribute(const sp<AaptFile>& in,
         uint32_t l10n_required = parse_flags(str, len, l10nRequiredFlags, &error);
         if (error) {
             attr.sourcePos.error("Tag <attr> 'localization' attribute value \"%s\" not valid\n",
-                    String8(str).string());
+                    String8(str).c_str());
             attr.hasErrors = true;
         }
         attr.createIfNeeded(outTable);
@@ -442,14 +442,14 @@ static status_t compileAttribute(const sp<AaptFile>& in,
     while ((code=block.next()) != ResXMLTree::END_DOCUMENT && code != ResXMLTree::BAD_DOCUMENT) {
         if (code == ResXMLTree::START_TAG) {
             uint32_t localType = 0;
-            if (strcmp16(block.getElementName(&len), enum16.string()) == 0) {
+            if (strcmp16(block.getElementName(&len), enum16.c_str()) == 0) {
                 localType = ResTable_map::TYPE_ENUM;
-            } else if (strcmp16(block.getElementName(&len), flag16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), flag16.c_str()) == 0) {
                 localType = ResTable_map::TYPE_FLAGS;
             } else {
                 SourcePos(in->getPrintableSource(), block.getLineNumber())
                         .error("Tag <%s> can not appear inside <attr>, only <enum> or <flag>\n",
-                        String8(block.getElementName(&len)).string());
+                        String8(block.getElementName(&len)).c_str());
                 return UNKNOWN_ERROR;
             }
 
@@ -505,11 +505,11 @@ static status_t compileAttribute(const sp<AaptFile>& in,
                         .error("A 'value' attribute is required for <enum> or <flag>\n");
                 attr.hasErrors = true;
             }
-            if (!attr.hasErrors && !ResTable::stringToInt(value.string(), value.size(), NULL)) {
+            if (!attr.hasErrors && !ResTable::stringToInt(value.c_str(), value.size(), NULL)) {
                 SourcePos(in->getPrintableSource(), block.getLineNumber())
                         .error("Tag <enum> or <flag> 'value' attribute must be a number,"
                         " not \"%s\"\n",
-                        String8(value).string());
+                        String8(value).c_str());
                 attr.hasErrors = true;
             }
 
@@ -546,21 +546,21 @@ static status_t compileAttribute(const sp<AaptFile>& in,
                 }
             }
         } else if (code == ResXMLTree::END_TAG) {
-            if (strcmp16(block.getElementName(&len), attr16.string()) == 0) {
+            if (strcmp16(block.getElementName(&len), attr16.c_str()) == 0) {
                 break;
             }
             if ((attr.type&ResTable_map::TYPE_ENUM) != 0) {
-                if (strcmp16(block.getElementName(&len), enum16.string()) != 0) {
+                if (strcmp16(block.getElementName(&len), enum16.c_str()) != 0) {
                     SourcePos(in->getPrintableSource(), block.getLineNumber())
                             .error("Found tag </%s> where </enum> is expected\n",
-                            String8(block.getElementName(&len)).string());
+                            String8(block.getElementName(&len)).c_str());
                     return UNKNOWN_ERROR;
                 }
             } else {
-                if (strcmp16(block.getElementName(&len), flag16.string()) != 0) {
+                if (strcmp16(block.getElementName(&len), flag16.c_str()) != 0) {
                     SourcePos(in->getPrintableSource(), block.getLineNumber())
                             .error("Found tag </%s> where </flag> is expected\n",
-                            String8(block.getElementName(&len)).string());
+                            String8(block.getElementName(&len)).c_str());
                     return UNKNOWN_ERROR;
                 }
             }
@@ -606,7 +606,7 @@ status_t parseAndAddBag(Bundle* bundle,
 
     String16 str;
     Vector<StringPool::entry_style_span> spans;
-    err = parseStyledString(bundle, in->getPrintableSource().string(),
+    err = parseStyledString(bundle, in->getPrintableSource().c_str(),
                             block, item16, &str, &spans, isFormatted,
                             pseudolocalize);
     if (err != NO_ERROR) {
@@ -619,10 +619,10 @@ status_t parseAndAddBag(Bundle* bundle,
                 config.language[0], config.language[1],
                 config.country[0], config.country[1],
                 config.orientation, config.density,
-                String8(parentIdent).string(),
-                String8(ident).string(),
-                String8(itemIdent).string(),
-                String8(str).string());
+                String8(parentIdent).c_str(),
+                String8(ident).c_str(),
+                String8(itemIdent).c_str(),
+                String8(str).c_str());
     }
 
     err = outTable->addBag(SourcePos(in->getPrintableSource(), block->getLineNumber()),
@@ -636,8 +636,8 @@ status_t parseAndAddBag(Bundle* bundle,
  * haystack, false otherwise.
  */
 bool isInProductList(const String16& needle, const String16& haystack) {
-    const char16_t *needle2 = needle.string();
-    const char16_t *haystack2 = haystack.string();
+    const char16_t *needle2 = needle.c_str();
+    const char16_t *haystack2 = haystack.c_str();
     size_t needlesize = needle.size();
 
     while (*haystack2 != '\0') {
@@ -703,7 +703,7 @@ status_t parseAndAddEntry(Bundle* bundle,
 
     String16 str;
     Vector<StringPool::entry_style_span> spans;
-    err = parseStyledString(bundle, in->getPrintableSource().string(), block,
+    err = parseStyledString(bundle, in->getPrintableSource().c_str(), block,
                             curTag, &str, curIsStyled ? &spans : NULL,
                             isFormatted, pseudolocalize);
 
@@ -730,7 +730,7 @@ status_t parseAndAddEntry(Bundle* bundle,
          */
 
         if (bundleProduct[0] == '\0') {
-            if (strcmp16(String16("default").string(), product.string()) != 0) {
+            if (strcmp16(String16("default").c_str(), product.c_str()) != 0) {
                 /*
                  * This string has a product other than 'default'. Do not add it,
                  * but record it so that if we do not see the same string with
@@ -750,7 +750,7 @@ status_t parseAndAddEntry(Bundle* bundle,
 
             if (isInProductList(product, String16(bundleProduct))) {
                 ;
-            } else if (strcmp16(String16("default").string(), product.string()) == 0 &&
+            } else if (strcmp16(String16("default").c_str(), product.c_str()) == 0 &&
                        !outTable->hasBagOrEntry(myPackage, curType, ident, config)) {
                 ;
             } else {
@@ -764,7 +764,7 @@ status_t parseAndAddEntry(Bundle* bundle,
                 config.language[0], config.language[1],
                 config.country[0], config.country[1],
                 config.orientation, config.density,
-                String8(ident).string(), String8(str).string());
+                String8(ident).c_str(), String8(str).c_str());
     }
 
     err = outTable->addEntry(SourcePos(in->getPrintableSource(), block->getLineNumber()),
@@ -847,7 +847,7 @@ status_t compileResourceFile(Bundle* bundle,
     bool hasErrors = false;
 
     bool fileIsTranslatable = true;
-    if (strstr(in->getPrintableSource().string(), "donottranslate") != NULL) {
+    if (strstr(in->getPrintableSource().c_str(), "donottranslate") != NULL) {
         fileIsTranslatable = false;
     }
 
@@ -869,9 +869,9 @@ status_t compileResourceFile(Bundle* bundle,
                 "No start tag found\n");
         return UNKNOWN_ERROR;
     }
-    if (strcmp16(block.getElementName(&len), resources16.string()) != 0) {
+    if (strcmp16(block.getElementName(&len), resources16.c_str()) != 0) {
         SourcePos(in->getPrintableSource(), block.getLineNumber()).error(
-                "Invalid start tag %s\n", String8(block.getElementName(&len)).string());
+                "Invalid start tag %s\n", String8(block.getElementName(&len)).c_str());
         return UNKNOWN_ERROR;
     }
 
@@ -900,7 +900,7 @@ status_t compileResourceFile(Bundle* bundle,
         SourcePos(in->getPrintableSource(), 0).warning(
                 "Resource file %s is skipped as pseudolocalization"
                 " was done automatically.",
-                in->getPrintableSource().string());
+                in->getPrintableSource().c_str());
         return NO_ERROR;
     }
 
@@ -917,29 +917,29 @@ status_t compileResourceFile(Bundle* bundle,
             bool curIsFormatted = fileIsTranslatable;
             bool localHasErrors = false;
 
-            if (strcmp16(block.getElementName(&len), skip16.string()) == 0) {
+            if (strcmp16(block.getElementName(&len), skip16.c_str()) == 0) {
                 while ((code=block.next()) != ResXMLTree::END_DOCUMENT
                         && code != ResXMLTree::BAD_DOCUMENT) {
                     if (code == ResXMLTree::END_TAG) {
-                        if (strcmp16(block.getElementName(&len), skip16.string()) == 0) {
+                        if (strcmp16(block.getElementName(&len), skip16.c_str()) == 0) {
                             break;
                         }
                     }
                 }
                 continue;
 
-            } else if (strcmp16(block.getElementName(&len), eat_comment16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), eat_comment16.c_str()) == 0) {
                 while ((code=block.next()) != ResXMLTree::END_DOCUMENT
                         && code != ResXMLTree::BAD_DOCUMENT) {
                     if (code == ResXMLTree::END_TAG) {
-                        if (strcmp16(block.getElementName(&len), eat_comment16.string()) == 0) {
+                        if (strcmp16(block.getElementName(&len), eat_comment16.c_str()) == 0) {
                             break;
                         }
                     }
                 }
                 continue;
 
-            } else if (strcmp16(block.getElementName(&len), public16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), public16.c_str()) == 0) {
                 SourcePos srcPos(in->getPrintableSource(), block.getLineNumber());
             
                 String16 type;
@@ -965,7 +965,7 @@ status_t compileResourceFile(Bundle* bundle,
                     Res_value identValue;
                     if (!ResTable::stringToInt(identStr, len, &identValue)) {
                         srcPos.error("Given 'id' attribute is not an integer: %s\n",
-                                String8(block.getAttributeStringValue(identIdx, &len)).string());
+                                String8(block.getAttributeStringValue(identIdx, &len)).c_str());
                         hasErrors = localHasErrors = true;
                     } else {
                         ident = identValue.data;
@@ -1004,14 +1004,14 @@ status_t compileResourceFile(Bundle* bundle,
 
                 while ((code=block.next()) != ResXMLTree::END_DOCUMENT && code != ResXMLTree::BAD_DOCUMENT) {
                     if (code == ResXMLTree::END_TAG) {
-                        if (strcmp16(block.getElementName(&len), public16.string()) == 0) {
+                        if (strcmp16(block.getElementName(&len), public16.c_str()) == 0) {
                             break;
                         }
                     }
                 }
                 continue;
 
-            } else if (strcmp16(block.getElementName(&len), public_padding16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), public_padding16.c_str()) == 0) {
                 SourcePos srcPos(in->getPrintableSource(), block.getLineNumber());
             
                 String16 type;
@@ -1037,7 +1037,7 @@ status_t compileResourceFile(Bundle* bundle,
                     Res_value startValue;
                     if (!ResTable::stringToInt(startStr, len, &startValue)) {
                         srcPos.error("Given 'start' attribute is not an integer: %s\n",
-                                String8(block.getAttributeStringValue(startIdx, &len)).string());
+                                String8(block.getAttributeStringValue(startIdx, &len)).c_str());
                         hasErrors = localHasErrors = true;
                     } else {
                         start = startValue.data;
@@ -1057,7 +1057,7 @@ status_t compileResourceFile(Bundle* bundle,
                     Res_value endValue;
                     if (!ResTable::stringToInt(endStr, len, &endValue)) {
                         srcPos.error("Given 'end' attribute is not an integer: %s\n",
-                                String8(block.getAttributeStringValue(endIdx, &len)).string());
+                                String8(block.getAttributeStringValue(endIdx, &len)).c_str());
                         hasErrors = localHasErrors = true;
                     } else {
                         end = endValue.data;
@@ -1114,14 +1114,14 @@ status_t compileResourceFile(Bundle* bundle,
 
                 while ((code=block.next()) != ResXMLTree::END_DOCUMENT && code != ResXMLTree::BAD_DOCUMENT) {
                     if (code == ResXMLTree::END_TAG) {
-                        if (strcmp16(block.getElementName(&len), public_padding16.string()) == 0) {
+                        if (strcmp16(block.getElementName(&len), public_padding16.c_str()) == 0) {
                             break;
                         }
                     }
                 }
                 continue;
 
-            } else if (strcmp16(block.getElementName(&len), private_symbols16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), private_symbols16.c_str()) == 0) {
                 String16 pkg;
                 ssize_t pkgIdx = block.indexOfAttribute(NULL, "package");
                 if (pkgIdx < 0) {
@@ -1144,14 +1144,14 @@ status_t compileResourceFile(Bundle* bundle,
 
                 while ((code=block.next()) != ResXMLTree::END_DOCUMENT && code != ResXMLTree::BAD_DOCUMENT) {
                     if (code == ResXMLTree::END_TAG) {
-                        if (strcmp16(block.getElementName(&len), private_symbols16.string()) == 0) {
+                        if (strcmp16(block.getElementName(&len), private_symbols16.c_str()) == 0) {
                             break;
                         }
                     }
                 }
                 continue;
 
-            } else if (strcmp16(block.getElementName(&len), java_symbol16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), java_symbol16.c_str()) == 0) {
                 SourcePos srcPos(in->getPrintableSource(), block.getLineNumber());
             
                 String16 type;
@@ -1186,7 +1186,7 @@ status_t compileResourceFile(Bundle* bundle,
 
                 while ((code=block.next()) != ResXMLTree::END_DOCUMENT && code != ResXMLTree::BAD_DOCUMENT) {
                     if (code == ResXMLTree::END_TAG) {
-                        if (strcmp16(block.getElementName(&len), java_symbol16.string()) == 0) {
+                        if (strcmp16(block.getElementName(&len), java_symbol16.c_str()) == 0) {
                             break;
                         }
                     }
@@ -1194,7 +1194,7 @@ status_t compileResourceFile(Bundle* bundle,
                 continue;
 
 
-            } else if (strcmp16(block.getElementName(&len), add_resource16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), add_resource16.c_str()) == 0) {
                 SourcePos srcPos(in->getPrintableSource(), block.getLineNumber());
             
                 String16 typeName;
@@ -1217,14 +1217,14 @@ status_t compileResourceFile(Bundle* bundle,
 
                 while ((code=block.next()) != ResXMLTree::END_DOCUMENT && code != ResXMLTree::BAD_DOCUMENT) {
                     if (code == ResXMLTree::END_TAG) {
-                        if (strcmp16(block.getElementName(&len), add_resource16.string()) == 0) {
+                        if (strcmp16(block.getElementName(&len), add_resource16.c_str()) == 0) {
                             break;
                         }
                     }
                 }
                 continue;
                 
-            } else if (strcmp16(block.getElementName(&len), declare_styleable16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), declare_styleable16.c_str()) == 0) {
                 SourcePos srcPos(in->getPrintableSource(), block.getLineNumber());
                                 
                 String16 ident;
@@ -1258,30 +1258,30 @@ status_t compileResourceFile(Bundle* bundle,
 
                 while ((code=block.next()) != ResXMLTree::END_DOCUMENT && code != ResXMLTree::BAD_DOCUMENT) {
                     if (code == ResXMLTree::START_TAG) {
-                        if (strcmp16(block.getElementName(&len), skip16.string()) == 0) {
+                        if (strcmp16(block.getElementName(&len), skip16.c_str()) == 0) {
                             while ((code=block.next()) != ResXMLTree::END_DOCUMENT
                                    && code != ResXMLTree::BAD_DOCUMENT) {
                                 if (code == ResXMLTree::END_TAG) {
-                                    if (strcmp16(block.getElementName(&len), skip16.string()) == 0) {
+                                    if (strcmp16(block.getElementName(&len), skip16.c_str()) == 0) {
                                         break;
                                     }
                                 }
                             }
                             continue;
-                        } else if (strcmp16(block.getElementName(&len), eat_comment16.string()) == 0) {
+                        } else if (strcmp16(block.getElementName(&len), eat_comment16.c_str()) == 0) {
                             while ((code=block.next()) != ResXMLTree::END_DOCUMENT
                                    && code != ResXMLTree::BAD_DOCUMENT) {
                                 if (code == ResXMLTree::END_TAG) {
-                                    if (strcmp16(block.getElementName(&len), eat_comment16.string()) == 0) {
+                                    if (strcmp16(block.getElementName(&len), eat_comment16.c_str()) == 0) {
                                         break;
                                     }
                                 }
                             }
                             continue;
-                        } else if (strcmp16(block.getElementName(&len), attr16.string()) != 0) {
+                        } else if (strcmp16(block.getElementName(&len), attr16.c_str()) != 0) {
                             SourcePos(in->getPrintableSource(), block.getLineNumber()).error(
                                     "Tag <%s> can not appear inside <declare-styleable>, only <attr>\n",
-                                    String8(block.getElementName(&len)).string());
+                                    String8(block.getElementName(&len)).c_str());
                             return UNKNOWN_ERROR;
                         }
 
@@ -1297,30 +1297,30 @@ status_t compileResourceFile(Bundle* bundle,
                             SourcePos srcPos(String8(in->getPrintableSource()), block.getLineNumber());
                             symbols->addSymbol(String8(itemIdent), 0, srcPos);
                             symbols->appendComment(String8(itemIdent), comment, srcPos);
-                            //printf("Attribute %s comment: %s\n", String8(itemIdent).string(),
-                            //     String8(comment).string());
+                            //printf("Attribute %s comment: %s\n", String8(itemIdent).c_str(),
+                            //     String8(comment).c_str());
                         }
                     } else if (code == ResXMLTree::END_TAG) {
-                        if (strcmp16(block.getElementName(&len), declare_styleable16.string()) == 0) {
+                        if (strcmp16(block.getElementName(&len), declare_styleable16.c_str()) == 0) {
                             break;
                         }
 
                         SourcePos(in->getPrintableSource(), block.getLineNumber()).error(
                                 "Found tag </%s> where </attr> is expected\n",
-                                String8(block.getElementName(&len)).string());
+                                String8(block.getElementName(&len)).c_str());
                         return UNKNOWN_ERROR;
                     }
                 }
                 continue;
 
-            } else if (strcmp16(block.getElementName(&len), attr16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), attr16.c_str()) == 0) {
                 err = compileAttribute(in, block, myPackage, outTable, NULL);
                 if (err != NO_ERROR) {
                     hasErrors = true;
                 }
                 continue;
 
-            } else if (strcmp16(block.getElementName(&len), item16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), item16.c_str()) == 0) {
                 curTag = &item16;
                 ssize_t attri = block.indexOfAttribute(NULL, "type");
                 if (attri >= 0) {
@@ -1333,12 +1333,12 @@ status_t compileResourceFile(Bundle* bundle,
                     if (formatIdx >= 0) {
                         String16 formatStr = String16(block.getAttributeStringValue(
                                 formatIdx, &len));
-                        curFormat = parse_flags(formatStr.string(), formatStr.size(),
+                        curFormat = parse_flags(formatStr.c_str(), formatStr.size(),
                                                 gFormatFlags);
                         if (curFormat == 0) {
                             SourcePos(in->getPrintableSource(), block.getLineNumber()).error(
                                     "Tag <item> 'format' attribute value \"%s\" not valid\n",
-                                    String8(formatStr).string());
+                                    String8(formatStr).c_str());
                             hasErrors = localHasErrors = true;
                         }
                     }
@@ -1348,7 +1348,7 @@ status_t compileResourceFile(Bundle* bundle,
                     hasErrors = localHasErrors = true;
                 }
                 curIsStyled = true;
-            } else if (strcmp16(block.getElementName(&len), string16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), string16.c_str()) == 0) {
                 // Note the existence and locale of every string we process
                 char rawLocale[RESTABLE_MAX_LOCALE_LEN];
                 curParams.getBcp47Locale(rawLocale);
@@ -1361,11 +1361,11 @@ status_t compileResourceFile(Bundle* bundle,
                 for (size_t i = 0; i < n; i++) {
                     size_t length;
                     const char16_t* attr = block.getAttributeName(i, &length);
-                    if (strcmp16(attr, name16.string()) == 0) {
+                    if (strcmp16(attr, name16.c_str()) == 0) {
                         name.setTo(block.getAttributeStringValue(i, &length));
-                    } else if (strcmp16(attr, translatable16.string()) == 0) {
+                    } else if (strcmp16(attr, translatable16.c_str()) == 0) {
                         translatable.setTo(block.getAttributeStringValue(i, &length));
-                    } else if (strcmp16(attr, formatted16.string()) == 0) {
+                    } else if (strcmp16(attr, formatted16.c_str()) == 0) {
                         formatted.setTo(block.getAttributeStringValue(i, &length));
                     }
                 }
@@ -1380,8 +1380,8 @@ status_t compileResourceFile(Bundle* bundle,
                         if (locale.size() > 0) {
                             SourcePos(in->getPrintableSource(), block.getLineNumber()).warning(
                                     "string '%s' marked untranslatable but exists in locale '%s'\n",
-                                    String8(name).string(),
-                                    locale.string());
+                                    String8(name).c_str(),
+                                    locale.c_str());
                             // hasErrors = localHasErrors = true;
                         } else {
                             // Intentionally empty block:
@@ -1407,31 +1407,31 @@ status_t compileResourceFile(Bundle* bundle,
                 curFormat = ResTable_map::TYPE_REFERENCE|ResTable_map::TYPE_STRING;
                 curIsStyled = true;
                 curIsPseudolocalizable = fileIsTranslatable && (translatable != false16);
-            } else if (strcmp16(block.getElementName(&len), drawable16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), drawable16.c_str()) == 0) {
                 curTag = &drawable16;
                 curType = drawable16;
                 curFormat = ResTable_map::TYPE_REFERENCE|ResTable_map::TYPE_COLOR;
-            } else if (strcmp16(block.getElementName(&len), color16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), color16.c_str()) == 0) {
                 curTag = &color16;
                 curType = color16;
                 curFormat = ResTable_map::TYPE_REFERENCE|ResTable_map::TYPE_COLOR;
-            } else if (strcmp16(block.getElementName(&len), bool16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), bool16.c_str()) == 0) {
                 curTag = &bool16;
                 curType = bool16;
                 curFormat = ResTable_map::TYPE_REFERENCE|ResTable_map::TYPE_BOOLEAN;
-            } else if (strcmp16(block.getElementName(&len), integer16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), integer16.c_str()) == 0) {
                 curTag = &integer16;
                 curType = integer16;
                 curFormat = ResTable_map::TYPE_REFERENCE|ResTable_map::TYPE_INTEGER;
-            } else if (strcmp16(block.getElementName(&len), dimen16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), dimen16.c_str()) == 0) {
                 curTag = &dimen16;
                 curType = dimen16;
                 curFormat = ResTable_map::TYPE_REFERENCE|ResTable_map::TYPE_DIMENSION;
-            } else if (strcmp16(block.getElementName(&len), fraction16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), fraction16.c_str()) == 0) {
                 curTag = &fraction16;
                 curType = fraction16;
                 curFormat = ResTable_map::TYPE_REFERENCE|ResTable_map::TYPE_FRACTION;
-            } else if (strcmp16(block.getElementName(&len), bag16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), bag16.c_str()) == 0) {
                 curTag = &bag16;
                 curIsBag = true;
                 ssize_t attri = block.indexOfAttribute(NULL, "type");
@@ -1442,16 +1442,16 @@ status_t compileResourceFile(Bundle* bundle,
                             "A 'type' attribute is required for <bag>\n");
                     hasErrors = localHasErrors = true;
                 }
-            } else if (strcmp16(block.getElementName(&len), style16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), style16.c_str()) == 0) {
                 curTag = &style16;
                 curType = style16;
                 curIsBag = true;
-            } else if (strcmp16(block.getElementName(&len), plurals16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), plurals16.c_str()) == 0) {
                 curTag = &plurals16;
                 curType = plurals16;
                 curIsBag = true;
                 curIsPseudolocalizable = fileIsTranslatable;
-            } else if (strcmp16(block.getElementName(&len), array16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), array16.c_str()) == 0) {
                 curTag = &array16;
                 curType = array16;
                 curIsBag = true;
@@ -1460,16 +1460,16 @@ status_t compileResourceFile(Bundle* bundle,
                 if (formatIdx >= 0) {
                     String16 formatStr = String16(block.getAttributeStringValue(
                             formatIdx, &len));
-                    curFormat = parse_flags(formatStr.string(), formatStr.size(),
+                    curFormat = parse_flags(formatStr.c_str(), formatStr.size(),
                                             gFormatFlags);
                     if (curFormat == 0) {
                         SourcePos(in->getPrintableSource(), block.getLineNumber()).error(
                                 "Tag <array> 'format' attribute value \"%s\" not valid\n",
-                                String8(formatStr).string());
+                                String8(formatStr).c_str());
                         hasErrors = localHasErrors = true;
                     }
                 }
-            } else if (strcmp16(block.getElementName(&len), string_array16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), string_array16.c_str()) == 0) {
                 // Check whether these strings need valid formats.
                 // (simplified form of what string16 does above)
                 bool isTranslatable = false;
@@ -1480,14 +1480,14 @@ status_t compileResourceFile(Bundle* bundle,
                 for (size_t i = 0; i < n; i++) {
                     size_t length;
                     const char16_t* attr = block.getAttributeName(i, &length);
-                    if (strcmp16(attr, formatted16.string()) == 0) {
+                    if (strcmp16(attr, formatted16.c_str()) == 0) {
                         const char16_t* value = block.getAttributeStringValue(i, &length);
-                        if (strcmp16(value, false16.string()) == 0) {
+                        if (strcmp16(value, false16.c_str()) == 0) {
                             curIsFormatted = false;
                         }
-                    } else if (strcmp16(attr, translatable16.string()) == 0) {
+                    } else if (strcmp16(attr, translatable16.c_str()) == 0) {
                         const char16_t* value = block.getAttributeStringValue(i, &length);
-                        if (strcmp16(value, false16.string()) == 0) {
+                        if (strcmp16(value, false16.c_str()) == 0) {
                             isTranslatable = false;
                         }
                     }
@@ -1499,7 +1499,7 @@ status_t compileResourceFile(Bundle* bundle,
                 curIsBag = true;
                 curIsBagReplaceOnOverwrite = true;
                 curIsPseudolocalizable = isTranslatable && fileIsTranslatable;
-            } else if (strcmp16(block.getElementName(&len), integer_array16.string()) == 0) {
+            } else if (strcmp16(block.getElementName(&len), integer_array16.c_str()) == 0) {
                 curTag = &integer_array16;
                 curType = array16;
                 curFormat = ResTable_map::TYPE_REFERENCE|ResTable_map::TYPE_INTEGER;
@@ -1508,7 +1508,7 @@ status_t compileResourceFile(Bundle* bundle,
             } else {
                 SourcePos(in->getPrintableSource(), block.getLineNumber()).error(
                         "Found tag %s where item is expected\n",
-                        String8(block.getElementName(&len)).string());
+                        String8(block.getElementName(&len)).c_str());
                 return UNKNOWN_ERROR;
             }
 
@@ -1519,7 +1519,7 @@ status_t compileResourceFile(Bundle* bundle,
             } else {
                 SourcePos(in->getPrintableSource(), block.getLineNumber()).error(
                         "A 'name' attribute is required for <%s>\n",
-                        String8(*curTag).string());
+                        String8(*curTag).c_str());
                 hasErrors = localHasErrors = true;
             }
 
@@ -1560,11 +1560,11 @@ status_t compileResourceFile(Bundle* bundle,
                         && code != ResXMLTree::BAD_DOCUMENT) {
 
                     if (code == ResXMLTree::START_TAG) {
-                        if (strcmp16(block.getElementName(&len), item16.string()) != 0) {
+                        if (strcmp16(block.getElementName(&len), item16.c_str()) != 0) {
                             SourcePos(in->getPrintableSource(), block.getLineNumber()).error(
                                     "Tag <%s> can not appear inside <%s>, only <item>\n",
-                                    String8(block.getElementName(&len)).string(),
-                                    String8(*curTag).string());
+                                    String8(block.getElementName(&len)).c_str(),
+                                    String8(*curTag).c_str());
                             return UNKNOWN_ERROR;
                         }
 
@@ -1647,11 +1647,11 @@ status_t compileResourceFile(Bundle* bundle,
                             hasErrors = localHasErrors = true;
                         }
                     } else if (code == ResXMLTree::END_TAG) {
-                        if (strcmp16(block.getElementName(&len), curTag->string()) != 0) {
+                        if (strcmp16(block.getElementName(&len), curTag->c_str()) != 0) {
                             SourcePos(in->getPrintableSource(), block.getLineNumber()).error(
                                     "Found tag </%s> where </%s> is expected\n",
-                                    String8(block.getElementName(&len)).string(),
-                                    String8(*curTag).string());
+                                    String8(block.getElementName(&len)).c_str(),
+                                    String8(*curTag).c_str());
                             return UNKNOWN_ERROR;
                         }
                         break;
@@ -1700,9 +1700,9 @@ status_t compileResourceFile(Bundle* bundle,
 
 #if 0
             if (comment.size() > 0) {
-                printf("Comment for @%s:%s/%s: %s\n", String8(myPackage).string(),
-                       String8(curType).string(), String8(ident).string(),
-                       String8(comment).string());
+                printf("Comment for @%s:%s/%s: %s\n", String8(myPackage).c_str(),
+                       String8(curType).c_str(), String8(ident).c_str(),
+                       String8(comment).c_str());
             }
 #endif
             if (!localHasErrors) {
@@ -1710,9 +1710,9 @@ status_t compileResourceFile(Bundle* bundle,
             }
         }
         else if (code == ResXMLTree::END_TAG) {
-            if (strcmp16(block.getElementName(&len), resources16.string()) != 0) {
+            if (strcmp16(block.getElementName(&len), resources16.c_str()) != 0) {
                 SourcePos(in->getPrintableSource(), block.getLineNumber()).error(
-                        "Unexpected end tag %s\n", String8(block.getElementName(&len)).string());
+                        "Unexpected end tag %s\n", String8(block.getElementName(&len)).c_str());
                 return UNKNOWN_ERROR;
             }
         }
@@ -1724,7 +1724,7 @@ status_t compileResourceFile(Bundle* bundle,
             }
             SourcePos(in->getPrintableSource(), block.getLineNumber()).error(
                     "Found text \"%s\" where item tag is expected\n",
-                    String8(block.getText(&len)).string());
+                    String8(block.getText(&len)).c_str());
             return UNKNOWN_ERROR;
         }
     }
@@ -1740,13 +1740,13 @@ status_t compileResourceFile(Bundle* bundle,
                 const char* bundleProduct =
                         (bundle->getProduct() == NULL) ? "" : bundle->getProduct();
                 fprintf(stderr, "In resource file %s: %s\n",
-                        in->getPrintableSource().string(),
-                        curParams.toString().string());
+                        in->getPrintableSource().c_str(),
+                        curParams.toString().c_str());
 
                 fprintf(stderr, "\t%s '%s' does not match product %s.\n"
                         "\tYou may have forgotten to include a 'default' product variant"
                         " of the resource.\n",
-                        String8(p.type).string(), String8(p.ident).string(),
+                        String8(p.type).c_str(), String8(p.ident).c_str(),
                         bundleProduct[0] == 0 ? "default" : bundleProduct);
                 return UNKNOWN_ERROR;
             }
@@ -1816,7 +1816,7 @@ status_t ResourceTable::addIncludedResources(Bundle* bundle, const sp<AaptAssets
         AssetManager featureAssetManager;
         if (!featureAssetManager.addAssetPath(featureAfter, NULL)) {
             fprintf(stderr, "ERROR: Feature package '%s' not found.\n",
-                    featureAfter.string());
+                    featureAfter.c_str());
             return UNKNOWN_ERROR;
         }
 
@@ -1835,13 +1835,13 @@ status_t ResourceTable::addPublic(const SourcePos& sourcePos,
                                   const uint32_t ident)
 {
     uint32_t rid = mAssets->getIncludedResources()
-        .identifierForName(name.string(), name.size(),
-                           type.string(), type.size(),
-                           package.string(), package.size());
+        .identifierForName(name.c_str(), name.size(),
+                           type.c_str(), type.size(),
+                           package.c_str(), package.size());
     if (rid != 0) {
         sourcePos.error("Error declaring public resource %s/%s for included package %s\n",
-                String8(type).string(), String8(name).string(),
-                String8(package).string());
+                String8(type).c_str(), String8(name).c_str(),
+                String8(package).c_str());
         return UNKNOWN_ERROR;
     }
 
@@ -1864,12 +1864,12 @@ status_t ResourceTable::addEntry(const SourcePos& sourcePos,
                                  const bool overwrite)
 {
     uint32_t rid = mAssets->getIncludedResources()
-        .identifierForName(name.string(), name.size(),
-                           type.string(), type.size(),
-                           package.string(), package.size());
+        .identifierForName(name.c_str(), name.size(),
+                           type.c_str(), type.size(),
+                           package.c_str(), package.size());
     if (rid != 0) {
         sourcePos.error("Resource entry %s/%s is already defined in package %s.",
-                String8(type).string(), String8(name).string(), String8(package).string());
+                String8(type).c_str(), String8(name).c_str(), String8(package).c_str());
         return UNKNOWN_ERROR;
     }
     
@@ -1899,12 +1899,12 @@ status_t ResourceTable::startBag(const SourcePos& sourcePos,
     // Check for adding entries in other packages...  for now we do
     // nothing.  We need to do the right thing here to support skinning.
     uint32_t rid = mAssets->getIncludedResources()
-    .identifierForName(name.string(), name.size(),
-                       type.string(), type.size(),
-                       package.string(), package.size());
+    .identifierForName(name.c_str(), name.size(),
+                       type.c_str(), type.size(),
+                       package.c_str(), package.size());
     if (rid != 0) {
         sourcePos.error("Resource entry %s/%s is already defined in package %s.",
-                String8(type).string(), String8(name).string(), String8(package).string());
+                String8(type).c_str(), String8(name).c_str(), String8(package).c_str());
         return UNKNOWN_ERROR;
     }
 
@@ -1921,7 +1921,7 @@ status_t ResourceTable::startBag(const SourcePos& sourcePos,
         }
         if (!canAdd) {
             sourcePos.error("Resource does not already exist in overlay at '%s'; use <add-resource> to add.\n",
-                            String8(name).string());
+                            String8(name).c_str());
             return UNKNOWN_ERROR;
         }
     }
@@ -1959,9 +1959,9 @@ status_t ResourceTable::addBag(const SourcePos& sourcePos,
     // Check for adding entries in other packages...  for now we do
     // nothing.  We need to do the right thing here to support skinning.
     uint32_t rid = mAssets->getIncludedResources()
-        .identifierForName(name.string(), name.size(),
-                           type.string(), type.size(),
-                           package.string(), package.size());
+        .identifierForName(name.c_str(), name.size(),
+                           type.c_str(), type.size(),
+                           package.c_str(), package.size());
     if (rid != 0) {
         return NO_ERROR;
     }
@@ -1969,7 +1969,7 @@ status_t ResourceTable::addBag(const SourcePos& sourcePos,
 #if 0
     if (name == String16("left")) {
         printf("Adding bag left: file=%s, line=%d, type=%s\n",
-               sourcePos.file.striing(), sourcePos.line, String8(type).string());
+               sourcePos.file.striing(), sourcePos.line, String8(type).c_str());
     }
 #endif
     sp<Entry> e = getEntry(package, type, name, sourcePos, replace, params);
@@ -1996,9 +1996,9 @@ bool ResourceTable::hasBagOrEntry(const String16& package,
 {
     // First look for this in the included resources...
     uint32_t rid = mAssets->getIncludedResources()
-        .identifierForName(name.string(), name.size(),
-                           type.string(), type.size(),
-                           package.string(), package.size());
+        .identifierForName(name.c_str(), name.size(),
+                           type.c_str(), type.size(),
+                           package.c_str(), package.size());
     if (rid != 0) {
         return true;
     }
@@ -2022,9 +2022,9 @@ bool ResourceTable::hasBagOrEntry(const String16& package,
 {
     // First look for this in the included resources...
     uint32_t rid = mAssets->getIncludedResources()
-        .identifierForName(name.string(), name.size(),
-                           type.string(), type.size(),
-                           package.string(), package.size());
+        .identifierForName(name.c_str(), name.size(),
+                           type.c_str(), type.size(),
+                           package.c_str(), package.size());
     if (rid != 0) {
         return true;
     }
@@ -2051,7 +2051,7 @@ bool ResourceTable::hasBagOrEntry(const String16& ref,
                                   const String16* defPackage)
 {
     String16 package, type, name;
-    if (!ResTable::expandResourceRef(ref.string(), ref.size(), &package, &type, &name,
+    if (!ResTable::expandResourceRef(ref.c_str(), ref.size(), &package, &type, &name,
                 defType, defPackage ? defPackage:&mAssetsPackage, NULL)) {
         return false;
     }
@@ -2115,17 +2115,17 @@ bool ResourceTable::makeAttribute(const String16& package,
 
     // First look for this in the included resources...
     uint32_t rid = mAssets->getIncludedResources()
-            .identifierForName(name.string(), name.size(),
-                               attr16.string(), attr16.size(),
-                               package.string(), package.size());
+            .identifierForName(name.c_str(), name.size(),
+                               attr16.c_str(), attr16.size(),
+                               package.c_str(), package.size());
     if (rid != 0) {
-        source.error("Attribute \"%s\" has already been defined", String8(name).string());
+        source.error("Attribute \"%s\" has already been defined", String8(name).c_str());
         return false;
     }
 
     sp<ResourceTable::Entry> entry = getEntry(package, attr16, name, source, false);
     if (entry == NULL) {
-        source.error("Failed to create entry attr/%s", String8(name).string());
+        source.error("Failed to create entry attr/%s", String8(name).c_str());
         return false;
     }
 
@@ -2146,7 +2146,7 @@ bool ResourceTable::makeAttribute(const String16& package,
                 formatItem.value != formatValue16) {
             source.error("Attribute \"%s\" already defined with incompatible format.\n"
                          "%s:%d: Original attribute defined here.",
-                         String8(name).string(), formatItem.sourcePos.file.string(),
+                         String8(name).c_str(), formatItem.sourcePos.file.c_str(),
                          formatItem.sourcePos.line);
             return false;
         }
@@ -2207,9 +2207,9 @@ uint32_t ResourceTable::getResId(const String16& package,
     // First look for this in the included resources...
     uint32_t specFlags = 0;
     uint32_t rid = mAssets->getIncludedResources()
-        .identifierForName(name.string(), name.size(),
-                           type.string(), type.size(),
-                           package.string(), package.size(),
+        .identifierForName(name.c_str(), name.size(),
+                           type.c_str(), type.size(),
+                           package.c_str(), package.size(),
                            &specFlags);
     if (rid != 0) {
         if (onlyPublic && (specFlags & ResTable_typeSpec::SPEC_PUBLIC) == 0) {
@@ -2253,27 +2253,27 @@ uint32_t ResourceTable::getResId(const String16& ref,
     String16 package, type, name;
     bool refOnlyPublic = true;
     if (!ResTable::expandResourceRef(
-        ref.string(), ref.size(), &package, &type, &name,
+        ref.c_str(), ref.size(), &package, &type, &name,
         defType, defPackage ? defPackage:&mAssetsPackage,
         outErrorMsg, &refOnlyPublic)) {
         if (kIsDebug) {
-            printf("Expanding resource: ref=%s\n", String8(ref).string());
+            printf("Expanding resource: ref=%s\n", String8(ref).c_str());
             printf("Expanding resource: defType=%s\n",
-                    defType ? String8(*defType).string() : "NULL");
+                    defType ? String8(*defType).c_str() : "NULL");
             printf("Expanding resource: defPackage=%s\n",
-                    defPackage ? String8(*defPackage).string() : "NULL");
-            printf("Expanding resource: ref=%s\n", String8(ref).string());
+                    defPackage ? String8(*defPackage).c_str() : "NULL");
+            printf("Expanding resource: ref=%s\n", String8(ref).c_str());
             printf("Expanded resource: p=%s, t=%s, n=%s, res=0\n",
-                    String8(package).string(), String8(type).string(),
-                    String8(name).string());
+                    String8(package).c_str(), String8(type).c_str(),
+                    String8(name).c_str());
         }
         return 0;
     }
     uint32_t res = getResId(package, type, name, onlyPublic && refOnlyPublic);
     if (kIsDebug) {
         printf("Expanded resource: p=%s, t=%s, n=%s, res=%d\n",
-                String8(package).string(), String8(type).string(),
-                String8(name).string(), res);
+                String8(package).c_str(), String8(type).c_str(),
+                String8(name).c_str(), res);
     }
     if (res == 0) {
         if (outErrorMsg)
@@ -2284,7 +2284,7 @@ uint32_t ResourceTable::getResId(const String16& ref,
 
 bool ResourceTable::isValidResourceName(const String16& s)
 {
-    const char16_t* p = s.string();
+    const char16_t* p = s.c_str();
     bool first = true;
     while (*p) {
         if ((*p >= 'a' && *p <= 'z')
@@ -2315,7 +2315,7 @@ bool ResourceTable::stringToValue(Res_value* outValue, StringPool* pool,
     if (style == NULL || style->size() == 0) {
         // Text is not styled so it can be any type...  let's figure it out.
         res = mAssets->getIncludedResources()
-            .stringToValue(outValue, &finalStr, str.string(), str.size(), preserveSpaces,
+            .stringToValue(outValue, &finalStr, str.c_str(), str.size(), preserveSpaces,
                             coerceType, attrID, NULL, &mAssetsPackage, this,
                            accessorCookie, attrType);
     } else {
@@ -2344,7 +2344,7 @@ bool ResourceTable::stringToValue(Res_value* outValue, StringPool* pool,
             if (kIsDebug) {
                 printf("Adding to pool string style #%zu config %s: %s\n",
                         style != NULL ? style->size() : 0U,
-                        configStr.string(), String8(finalStr).string());
+                        configStr.c_str(), String8(finalStr).c_str());
             }
             if (style != NULL && style->size() > 0) {
                 outValue->data = pool->add(finalStr, *style, configTypeName, config);
@@ -2368,8 +2368,8 @@ bool ResourceTable::stringToValue(Res_value* outValue, StringPool* pool,
 uint32_t ResourceTable::getCustomResource(
     const String16& package, const String16& type, const String16& name) const
 {
-    //printf("getCustomResource: %s %s %s\n", String8(package).string(),
-    //       String8(type).string(), String8(name).string());
+    //printf("getCustomResource: %s %s %s\n", String8(package).c_str(),
+    //       String8(type).c_str(), String8(name).c_str());
     sp<Package> p = mPackages.valueFor(package);
     if (p == NULL) return 0;
     sp<Type> t = p->getTypes().valueFor(type);
@@ -2400,7 +2400,7 @@ uint32_t ResourceTable::getCustomResourceWithCreation(
 
     if (mAssetsPackage != package) {
         mCurrentXmlPos.error("creating resource for external package %s: %s/%s.",
-                String8(package).string(), String8(type).string(), String8(name).string());
+                String8(package).c_str(), String8(type).c_str(), String8(name).c_str());
         if (package == String16("android")) {
             mCurrentXmlPos.printf("did you mean to use @+id instead of @+android:id?");
         }
@@ -2427,7 +2427,7 @@ bool ResourceTable::getAttributeType(uint32_t attrID, uint32_t* outType)
     Res_value value;
     if (getItemValue(attrID, ResTable_map::ATTR_TYPE, &value)) {
         //printf("getAttributeType #%08x (%s): #%08x\n", attrID,
-        //       String8(getEntry(attrID)->getName()).string(), value.data);
+        //       String8(getEntry(attrID)->getName()).c_str(), value.data);
         *outType = value.data;
         return true;
     }
@@ -2481,7 +2481,7 @@ void ResourceTable::reportError(void* accessorCookie, const char* fmt, ...)
         vsnprintf(buf, sizeof(buf), fmt, ap);
         va_end(ap);
         ac->sourcePos.error("Error: %s (at '%s' with value '%s').\n",
-                            buf, ac->attr.string(), ac->value.string());
+                            buf, ac->attr.c_str(), ac->value.c_str());
     }
 }
 
@@ -2493,7 +2493,7 @@ bool ResourceTable::getAttributeKeys(
         const size_t N = e->getBag().size();
         for (size_t i=0; i<N; i++) {
             const String16& key = e->getBag().keyAt(i);
-            if (key.size() > 0 && key.string()[0] != '^') {
+            if (key.size() > 0 && key.c_str()[0] != '^') {
                 outKeys->add(key);
             }
         }
@@ -2506,14 +2506,14 @@ bool ResourceTable::getAttributeEnum(
     uint32_t attrID, const char16_t* name, size_t nameLen,
     Res_value* outValue)
 {
-    //printf("getAttributeEnum #%08x %s\n", attrID, String8(name, nameLen).string());
+    //printf("getAttributeEnum #%08x %s\n", attrID, String8(name, nameLen).c_str());
     String16 nameStr(name, nameLen);
     sp<const Entry> e = getEntry(attrID);
     if (e != NULL) {
         const size_t N = e->getBag().size();
         for (size_t i=0; i<N; i++) {
-            //printf("Comparing %s to %s\n", String8(name, nameLen).string(),
-            //       String8(e->getBag().keyAt(i)).string());
+            //printf("Comparing %s to %s\n", String8(name, nameLen).c_str(),
+            //       String8(e->getBag().keyAt(i)).c_str());
             if (e->getBag().keyAt(i) == nameStr) {
                 return getItemValue(attrID, e->getBag().valueAt(i).bagKeyId, outValue);
             }
@@ -2529,7 +2529,7 @@ bool ResourceTable::getAttributeFlags(
     outValue->dataType = Res_value::TYPE_INT_HEX;
     outValue->data = 0;
 
-    //printf("getAttributeFlags #%08x %s\n", attrID, String8(name, nameLen).string());
+    //printf("getAttributeFlags #%08x %s\n", attrID, String8(name, nameLen).c_str());
     String16 nameStr(name, nameLen);
     sp<const Entry> e = getEntry(attrID);
     if (e != NULL) {
@@ -2546,8 +2546,8 @@ bool ResourceTable::getAttributeFlags(
             String16 nameStr(start, pos-start);
             size_t i;
             for (i=0; i<N; i++) {
-                //printf("Comparing \"%s\" to \"%s\"\n", String8(nameStr).string(),
-                //       String8(e->getBag().keyAt(i)).string());
+                //printf("Comparing \"%s\" to \"%s\"\n", String8(nameStr).c_str(),
+                //       String8(e->getBag().keyAt(i)).c_str());
                 if (e->getBag().keyAt(i) == nameStr) {
                     Res_value val;
                     bool got = getItemValue(attrID, e->getBag().valueAt(i).bagKeyId, &val);
@@ -2753,7 +2753,7 @@ status_t ResourceTable::addSymbols(const sp<AaptSymbols>& outSymbols,
                         if (mHasDefaultLocalization.find(c->getName())
                                 == mHasDefaultLocalization.end()) {
                             // printf("Skip symbol [%08x] %s\n", rid,
-                            //          String8(c->getName()).string());
+                            //          String8(c->getName()).c_str());
                             continue;
                         }
                     }
@@ -2763,7 +2763,7 @@ status_t ResourceTable::addSymbols(const sp<AaptSymbols>& outSymbols,
                     String16 comment(c->getComment());
                     typeSymbols->appendComment(String8(c->getName()), comment, c->getPos());
                     //printf("Type symbol [%08x] %s comment: %s\n", rid,
-                    //        String8(c->getName()).string(), String8(comment).string());
+                    //        String8(c->getName()).c_str(), String8(comment).c_str());
                     comment = c->getTypeComment();
                     typeSymbols->appendTypeComment(String8(c->getName()), comment);
                 }
@@ -2809,10 +2809,10 @@ ResourceTable::validateLocalizations(void)
         // Look for strings with no default localization
         if (configSrcMap.count(defaultLocale) == 0) {
             SourcePos().warning("string '%s' has no default translation.",
-                    String8(nameIter.first).string());
+                    String8(nameIter.first).c_str());
             if (mBundle->getVerbose()) {
                 for (const auto& locale : configSrcMap) {
-                    locale.second.printf("locale %s found", locale.first.string());
+                    locale.second.printf("locale %s found", locale.first.c_str());
                 }
             }
             // !!! TODO: throw an error here in some circumstances
@@ -2820,7 +2820,7 @@ ResourceTable::validateLocalizations(void)
 
         // Check that all requested localizations are present for this string
         if (mBundle->getConfigurations().size() > 0 && mBundle->getRequireLocalization()) {
-            const char* allConfigs = mBundle->getConfigurations().string();
+            const char* allConfigs = mBundle->getConfigurations().c_str();
             const char* start = allConfigs;
             const char* comma;
 
@@ -2847,7 +2847,7 @@ ResourceTable::validateLocalizations(void)
                         // requiring a specific regional localization [e.g. de_DE] but there is an
                         // available string in the generic language localization [e.g. de];
                         // consider that string to have fulfilled the localization requirement.
-                        String8 region(config.string(), 2);
+                        String8 region(config.c_str(), 2);
                         if (configSrcMap.find(region) == configSrcMap.end() &&
                                 configSrcMap.count(defaultLocale) == 0) {
                             missingConfigs.insert(config);
@@ -2859,12 +2859,12 @@ ResourceTable::validateLocalizations(void)
             if (!missingConfigs.empty()) {
                 String8 configStr;
                 for (const auto& iter : missingConfigs) {
-                    configStr.appendFormat(" %s", iter.string());
+                    configStr.appendFormat(" %s", iter.c_str());
                 }
                 SourcePos().warning("string '%s' is missing %u required localizations:%s",
-                        String8(nameIter.first).string(),
+                        String8(nameIter.first).c_str(),
                         (unsigned int)missingConfigs.size(),
-                        configStr.string());
+                        configStr.c_str());
             }
         }
     }
@@ -3021,7 +3021,7 @@ status_t ResourceTable::flatten(Bundle* bundle, const sp<const ResourceFilter>&
         header->header.type = htods(RES_TABLE_PACKAGE_TYPE);
         header->header.headerSize = htods(sizeof(*header));
         header->id = htodl(static_cast<uint32_t>(p->getAssignedId()));
-        strcpy16_htod(header->name, p->getName().string());
+        strcpy16_htod(header->name, p->getName().c_str());
 
         // Write the string blocks.
         const size_t typeStringsStart = data->getSize();
@@ -3061,7 +3061,7 @@ status_t ResourceTable::flatten(Bundle* bundle, const sp<const ResourceFilter>&
             sp<Type> t = p->getTypes().valueFor(typeName);
             LOG_ALWAYS_FATAL_IF(t == NULL && typeName != String16("<empty>"),
                                 "Type name %s not found",
-                                String8(typeName).string());
+                                String8(typeName).c_str());
             if (t == NULL) {
                 continue;
             }
@@ -3260,7 +3260,7 @@ status_t ResourceTable::flatten(Bundle* bundle, const sp<const ResourceFilter>&
                         sp<ConfigList> c = t->getOrderedConfigs().itemAt(i);
                         if (c != NULL) {
                             fprintf(stderr, "%s: no entries written for %s/%s (0x%08zx)\n", log_prefix,
-                                    String8(typeName).string(), String8(c->getName()).string(),
+                                    String8(typeName).c_str(), String8(c->getName()).c_str(),
                                     Res_MAKEID(p->getAssignedId() - 1, ti, i));
                         }
                         missing_entry = true;
@@ -3359,7 +3359,7 @@ status_t ResourceTable::flattenLibraryTable(const sp<AaptFile>& dest, const Vect
             sp<Package> libPackage = libs[i];
             if (kIsDebug) {
                 fprintf(stderr, "  Entry %s -> 0x%02x\n",
-                        String8(libPackage->getName()).string(),
+                        String8(libPackage->getName()).c_str(),
                         (uint8_t)libPackage->getAssignedId());
             }
 
@@ -3367,7 +3367,7 @@ status_t ResourceTable::flattenLibraryTable(const sp<AaptFile>& dest, const Vect
                     entryStart, sizeof(ResTable_lib_entry));
             memset(entry, 0, sizeof(*entry));
             entry->packageId = htodl(libPackage->getAssignedId());
-            strcpy16_htod(entry->packageName, libPackage->getName().string());
+            strcpy16_htod(entry->packageName, libPackage->getName().c_str());
         }
     }
     return NO_ERROR;
@@ -3435,13 +3435,13 @@ void ResourceTable::writePublicDefinitions(const String16& package, FILE* fp, bo
                         const SourcePos& pos = c->getEntries().valueAt(k)->getPos();
                         if (pos.file != "") {
                             fprintf(fp,"  <!-- Declared at %s:%d -->\n",
-                                    pos.file.string(), pos.line);
+                                    pos.file.c_str(), pos.line);
                         }
                     }
                 }
                 fprintf(fp, "  <public type=\"%s\" name=\"%s\" id=\"0x%08x\" />\n",
-                        String8(t->getName()).string(),
-                        String8(c->getName()).string(),
+                        String8(t->getName()).c_str(),
+                        String8(c->getName()).c_str(),
                         getResId(pkg, t, c->getEntryIndex()));
             }
         }
@@ -3501,8 +3501,8 @@ status_t ResourceTable::Entry::makeItABag(const SourcePos& sourcePos)
     }
     sourcePos.error("Resource entry %s is already defined as a single item.\n"
                     "%s:%d: Originally defined here.\n",
-                    String8(mName).string(),
-                    mItem.sourcePos.file.string(), mItem.sourcePos.line);
+                    String8(mName).c_str(),
+                    mItem.sourcePos.file.c_str(), mItem.sourcePos.line);
     return UNKNOWN_ERROR;
 }
 
@@ -3517,21 +3517,21 @@ status_t ResourceTable::Entry::setItem(const SourcePos& sourcePos,
     if (mType == TYPE_BAG) {
         if (mBag.size() == 0) {
             sourcePos.error("Resource entry %s is already defined as a bag.",
-                    String8(mName).string());
+                    String8(mName).c_str());
         } else {
             const Item& item(mBag.valueAt(0));
             sourcePos.error("Resource entry %s is already defined as a bag.\n"
                             "%s:%d: Originally defined here.\n",
-                            String8(mName).string(),
-                            item.sourcePos.file.string(), item.sourcePos.line);
+                            String8(mName).c_str(),
+                            item.sourcePos.file.c_str(), item.sourcePos.line);
         }
         return UNKNOWN_ERROR;
     }
     if ( (mType != TYPE_UNKNOWN) && (overwrite == false) ) {
         sourcePos.error("Resource entry %s is already defined.\n"
                         "%s:%d: Originally defined here.\n",
-                        String8(mName).string(),
-                        mItem.sourcePos.file.string(), mItem.sourcePos.line);
+                        String8(mName).c_str(),
+                        mItem.sourcePos.file.c_str(), mItem.sourcePos.line);
         return UNKNOWN_ERROR;
     }
 
@@ -3562,12 +3562,12 @@ status_t ResourceTable::Entry::addToBag(const SourcePos& sourcePos,
             const Item& item(mBag.valueAt(origKey));
             sourcePos.error("Resource entry %s already has bag item %s.\n"
                     "%s:%d: Originally defined here.\n",
-                    String8(mName).string(), String8(key).string(),
-                    item.sourcePos.file.string(), item.sourcePos.line);
+                    String8(mName).c_str(), String8(key).c_str(),
+                    item.sourcePos.file.c_str(), item.sourcePos.line);
             return UNKNOWN_ERROR;
         }
         //printf("Replacing %s with %s\n",
-        //       String8(mBag.valueFor(key).value).string(), String8(value).string());
+        //       String8(mBag.valueFor(key).value).c_str(), String8(value).c_str());
         mBag.replaceValueFor(key, item);
     }
 
@@ -3611,8 +3611,8 @@ status_t ResourceTable::Entry::generateAttributes(ResourceTable* table,
                 String16 value("false");
                 if (kIsDebug) {
                     fprintf(stderr, "Generating %s:id/%s\n",
-                            String8(package).string(),
-                            String8(key).string());
+                            String8(package).c_str(),
+                            String8(key).c_str());
                 }
                 status_t err = table->addEntry(SourcePos(String8("<generated>"), 0), package,
                                                id16, key, value);
@@ -3624,10 +3624,10 @@ status_t ResourceTable::Entry::generateAttributes(ResourceTable* table,
 
 #if 1
 //             fprintf(stderr, "ERROR: Bag attribute '%s' has not been defined.\n",
-//                     String8(key).string());
+//                     String8(key).c_str());
 //             const Item& item(mBag.valueAt(i));
 //             fprintf(stderr, "Referenced from file %s line %d\n",
-//                     item.sourcePos.file.string(), item.sourcePos.line);
+//                     item.sourcePos.file.c_str(), item.sourcePos.line);
 //             return UNKNOWN_ERROR;
 #else
             char numberStr[16];
@@ -3660,7 +3660,7 @@ status_t ResourceTable::Entry::assignResourceIds(ResourceTable* table,
             mParentId = table->getResId(mParent, &style16, NULL, &errorMsg);
             if (mParentId == 0) {
                 mPos.error("Error retrieving parent for item: %s '%s'.\n",
-                        errorMsg, String8(mParent).string());
+                        errorMsg, String8(mParent).c_str());
                 hasErrors = true;
             }
         }
@@ -3670,11 +3670,11 @@ status_t ResourceTable::Entry::assignResourceIds(ResourceTable* table,
             Item& it = mBag.editValueAt(i);
             it.bagKeyId = table->getResId(key,
                     it.isId ? &id16 : &attr16, NULL, &errorMsg);
-            //printf("Bag key of %s: #%08x\n", String8(key).string(), it.bagKeyId);
+            //printf("Bag key of %s: #%08x\n", String8(key).c_str(), it.bagKeyId);
             if (it.bagKeyId == 0) {
                 it.sourcePos.error("Error: %s: %s '%s'.\n", errorMsg,
-                        String8(it.isId ? id16 : attr16).string(),
-                        String8(key).string());
+                        String8(it.isId ? id16 : attr16).c_str(),
+                        String8(key).c_str());
                 hasErrors = true;
             }
         }
@@ -3709,7 +3709,7 @@ status_t ResourceTable::Entry::prepareFlatten(StringPool* strings, ResourceTable
         }
     } else {
         mPos.error("Error: entry %s is not a single item or a bag.\n",
-                   String8(mName).string());
+                   String8(mName).c_str());
         return UNKNOWN_ERROR;
     }
     return NO_ERROR;
@@ -3732,7 +3732,7 @@ status_t ResourceTable::Entry::remapStringValue(StringPool* strings)
         }
     } else {
         mPos.error("Error: entry %s is not a single item or a bag.\n",
-                   String8(mName).string());
+                   String8(mName).c_str());
         return UNKNOWN_ERROR;
     }
     return NO_ERROR;
@@ -3768,7 +3768,7 @@ ssize_t ResourceTable::Entry::flatten(Bundle* /* bundle */, const sp<AaptFile>&
         par.data = htodl(it.parsedValue.data);
         #if 0
         printf("Writing item (%s): type=%d, data=0x%x, res0=0x%x\n",
-               String8(mName).string(), it.parsedValue.dataType,
+               String8(mName).c_str(), it.parsedValue.dataType,
                it.parsedValue.data, par.res0);
         #endif
         err = data->writeData(&par, it.parsedValue.size);
@@ -3852,7 +3852,7 @@ status_t ResourceTable::Type::addPublic(const SourcePos& sourcePos,
     int32_t entryIdx = Res_GETENTRY(ident);
     if (entryIdx < 0) {
         sourcePos.error("Public resource %s/%s has an invalid 0 identifier (0x%08x).\n",
-                String8(mName).string(), String8(name).string(), ident);
+                String8(mName).c_str(), String8(name).c_str(), ident);
         return UNKNOWN_ERROR;
     }
     #endif
@@ -3863,7 +3863,7 @@ status_t ResourceTable::Type::addPublic(const SourcePos& sourcePos,
         if (mPublicIndex > 0 && mPublicIndex != typeIdx) {
             sourcePos.error("Public resource %s/%s has conflicting type codes for its"
                     " public identifiers (0x%x vs 0x%x).\n",
-                    String8(mName).string(), String8(name).string(),
+                    String8(mName).c_str(), String8(name).c_str(),
                     mPublicIndex, typeIdx);
             return UNKNOWN_ERROR;
         }
@@ -3882,8 +3882,8 @@ status_t ResourceTable::Type::addPublic(const SourcePos& sourcePos,
             sourcePos.error("Public resource %s/%s has conflicting public identifiers"
                     " (0x%08x vs 0x%08x).\n"
                     "%s:%d: Originally defined here.\n",
-                    String8(mName).string(), String8(name).string(), p.ident, ident,
-                    p.sourcePos.file.string(), p.sourcePos.line);
+                    String8(mName).c_str(), String8(name).c_str(), p.ident, ident,
+                    p.sourcePos.file.c_str(), p.sourcePos.line);
             return UNKNOWN_ERROR;
         }
     }
@@ -3909,7 +3909,7 @@ sp<ResourceTable::Entry> ResourceTable::Type::getEntry(const String16& entry,
         if (overlay && !autoAddOverlay && mCanAddEntries.indexOf(entry) < 0) {
             sourcePos.error("Resource at %s appears in overlay but not"
                             " in the base package; use <add-resource> to add.\n",
-                            String8(entry).string());
+                            String8(entry).c_str());
             return NULL;
         }
         c = new ConfigList(entry, sourcePos);
@@ -3931,7 +3931,7 @@ sp<ResourceTable::Entry> ResourceTable::Type::getEntry(const String16& entry,
                 printf("New entry at %s:%d: imsi:%d/%d lang:%c%c cnt:%c%c "
                     "orien:%d touch:%d density:%d key:%d inp:%d nav:%d sz:%dx%d "
                     "sw%ddp w%ddp h%ddp layout:%d\n",
-                      sourcePos.file.string(), sourcePos.line,
+                      sourcePos.file.c_str(), sourcePos.line,
                       config->mcc, config->mnc,
                       config->language[0] ? config->language[0] : '-',
                       config->language[1] ? config->language[1] : '-',
@@ -3951,7 +3951,7 @@ sp<ResourceTable::Entry> ResourceTable::Type::getEntry(const String16& entry,
                       config->screenLayout);
             } else {
                 printf("New entry at %s:%d: NULL config\n",
-                        sourcePos.file.string(), sourcePos.line);
+                        sourcePos.file.c_str(), sourcePos.line);
             }
         }
         e = new Entry(entry, sourcePos);
@@ -4032,11 +4032,11 @@ status_t ResourceTable::Type::applyPublicEntryOrder()
         const Public& p = mPublic.valueAt(j);
         int32_t idx = Res_GETENTRY(p.ident);
         //printf("Looking for entry \"%s\"/\"%s\" (0x%08x) in %d...\n",
-        //       String8(mName).string(), String8(name).string(), p.ident, N);
+        //       String8(mName).c_str(), String8(name).c_str(), p.ident, N);
         bool found = false;
         for (i=0; i<N; i++) {
             sp<ConfigList> e = origOrder.itemAt(i);
-            //printf("#%d: \"%s\"\n", i, String8(e->getName()).string());
+            //printf("#%d: \"%s\"\n", i, String8(e->getName()).c_str());
             if (e->getName() == name) {
                 if (idx >= (int32_t)mOrderedConfigs.size()) {
                     mOrderedConfigs.resize(idx + 1);
@@ -4056,10 +4056,10 @@ status_t ResourceTable::Type::applyPublicEntryOrder()
                     p.sourcePos.error("Multiple entry names declared for public entry"
                             " identifier 0x%x in type %s (%s vs %s).\n"
                             "%s:%d: Originally defined here.",
-                            idx+1, String8(mName).string(),
-                            String8(oe->getName()).string(),
-                            String8(name).string(),
-                            oe->getPublicSourcePos().file.string(),
+                            idx+1, String8(mName).c_str(),
+                            String8(oe->getName()).c_str(),
+                            String8(name).c_str(),
+                            oe->getPublicSourcePos().file.c_str(),
                             oe->getPublicSourcePos().line);
                     hasError = true;
                 }
@@ -4068,7 +4068,7 @@ status_t ResourceTable::Type::applyPublicEntryOrder()
 
         if (!found) {
             p.sourcePos.error("Public symbol %s/%s declared here is not defined.",
-                    String8(mName).string(), String8(name).string());
+                    String8(mName).c_str(), String8(name).c_str());
             hasError = true;
         }
     }
@@ -4189,9 +4189,9 @@ status_t ResourceTable::Package::applyPublicTypeOrder()
                 t->getFirstPublicSourcePos().error("Multiple type names declared for public type"
                         " identifier 0x%x (%s vs %s).\n"
                         "%s:%d: Originally defined here.",
-                        idx, String8(ot->getName()).string(),
-                        String8(t->getName()).string(),
-                        ot->getFirstPublicSourcePos().file.string(),
+                        idx, String8(ot->getName()).c_str(),
+                        String8(t->getName()).c_str(),
+                        ot->getFirstPublicSourcePos().file.c_str(),
                         ot->getFirstPublicSourcePos().line);
                 return UNKNOWN_ERROR;
             }
@@ -4399,8 +4399,8 @@ const ResourceTable::Item* ResourceTable::getItem(uint32_t resID, uint32_t attrI
         const Item& it = e->getBag().valueAt(i);
         if (it.bagKeyId == 0) {
             fprintf(stderr, "warning: ID not yet assigned to '%s' in bag '%s'\n",
-                    String8(e->getName()).string(),
-                    String8(e->getBag().keyAt(i)).string());
+                    String8(e->getName()).c_str(),
+                    String8(e->getBag().keyAt(i)).c_str());
         }
         if (it.bagKeyId == attrID) {
             return &it;
@@ -4427,8 +4427,8 @@ bool ResourceTable::getItemValue(
                 }
             }
             fprintf(stderr, "warning: Circular reference detected in key '%s' of bag '%s'\n",
-                    String8(e->getName()).string(),
-                    String8(e->getBag().keyAt(i)).string());
+                    String8(e->getName()).c_str(),
+                    String8(e->getBag().keyAt(i)).c_str());
             return false;
         }
         item->evaluating = true;
@@ -4436,7 +4436,7 @@ bool ResourceTable::getItemValue(
         if (kIsDebug) {
             if (res) {
                 printf("getItemValue of #%08x[#%08x] (%s): type=#%08x, data=#%08x\n",
-                       resID, attrID, String8(getEntry(resID)->getName()).string(),
+                       resID, attrID, String8(getEntry(resID)->getName()).c_str(),
                        outValue->dataType, outValue->data);
             } else {
                 printf("getItemValue of #%08x[#%08x]: failed\n",
@@ -4713,10 +4713,10 @@ status_t ResourceTable::modifyForCompat(const Bundle* bundle) {
                         entriesToAdd[i].value->getPos()
                                 .printf("using v%d attributes; synthesizing resource %s:%s/%s for configuration %s.",
                                         entriesToAdd[i].key.sdkVersion,
-                                        String8(p->getName()).string(),
-                                        String8(t->getName()).string(),
-                                        String8(entriesToAdd[i].value->getName()).string(),
-                                        entriesToAdd[i].key.toString().string());
+                                        String8(p->getName()).c_str(),
+                                        String8(t->getName()).c_str(),
+                                        String8(entriesToAdd[i].value->getName()).c_str(),
+                                        entriesToAdd[i].key.toString().c_str());
                     }
 
                     sp<Entry> newEntry = t->getEntry(c->getName(),
@@ -4801,8 +4801,8 @@ bool ResourceTable::versionForCompat(const Bundle* bundle, const String16& resou
     sp<AaptFile> newFile = new AaptFile(target->getSourceFile(),
             AaptGroupEntry(newConfig), target->getResourceType());
     String8 resPath = String8::format("res/%s/%s.xml",
-            newFile->getGroupEntry().toDirName(target->getResourceType()).string(),
-            String8(resourceName).string());
+            newFile->getGroupEntry().toDirName(target->getResourceType()).c_str(),
+            String8(resourceName).c_str());
     resPath.convertToResPath();
 
     // Add a resource table entry.
@@ -4893,10 +4893,10 @@ status_t ResourceTable::modifyForCompat(const Bundle* bundle,
                 if (bundle->getVerbose()) {
                     SourcePos(node->getFilename(), node->getStartLineNumber()).printf(
                             "removing attribute %s%s%s from <%s>",
-                            String8(attr.ns).string(),
+                            String8(attr.ns).c_str(),
                             (attr.ns.size() == 0 ? "" : ":"),
-                            String8(attr.name).string(),
-                            String8(node->getElementName()).string());
+                            String8(attr.name).c_str(),
+                            String8(node->getElementName()).c_str());
                 }
                 node->removeAttribute(i);
                 i--;
@@ -4925,8 +4925,8 @@ status_t ResourceTable::modifyForCompat(const Bundle* bundle,
         sp<AaptFile> newFile = new AaptFile(target->getSourceFile(),
                 AaptGroupEntry(newConfig), target->getResourceType());
         String8 resPath = String8::format("res/%s/%s.xml",
-                newFile->getGroupEntry().toDirName(target->getResourceType()).string(),
-                String8(resourceName).string());
+                newFile->getGroupEntry().toDirName(target->getResourceType()).c_str(),
+                String8(resourceName).c_str());
         resPath.convertToResPath();
 
         // Add a resource table entry.
@@ -4934,10 +4934,10 @@ status_t ResourceTable::modifyForCompat(const Bundle* bundle,
             SourcePos(target->getSourceFile(), -1).printf(
                     "using v%d attributes; synthesizing resource %s:%s/%s for configuration %s.",
                     newConfig.sdkVersion,
-                    mAssets->getPackage().string(),
-                    newFile->getResourceType().string(),
-                    String8(resourceName).string(),
-                    newConfig.toString().string());
+                    mAssets->getPackage().c_str(),
+                    newFile->getResourceType().c_str(),
+                    String8(resourceName).c_str(),
+                    newConfig.toString().c_str());
         }
 
         addEntry(SourcePos(),
@@ -5114,8 +5114,8 @@ status_t ResourceTable::processBundleFormatImpl(const Bundle* bundle,
         sp<XMLNode> nestedRoot = findOnlyChildElement(child);
         if (nestedRoot == NULL) {
             source.error("<%s:%s> must have exactly one child element",
-                         String8(child->getElementNamespace()).string(),
-                         String8(child->getElementName()).string());
+                         String8(child->getElementNamespace()).c_str(),
+                         String8(child->getElementName()).c_str());
             return UNKNOWN_ERROR;
         }
 
@@ -5130,7 +5130,7 @@ status_t ResourceTable::processBundleFormatImpl(const Bundle* bundle,
         // Parse the attribute name.
         const char* errorMsg = NULL;
         String16 attrPackage, attrType, attrName;
-        bool result = ResTable::expandResourceRef(attr->string.string(),
+        bool result = ResTable::expandResourceRef(attr->string.c_str(),
                                                   attr->string.size(),
                                                   &attrPackage, &attrType, &attrName,
                                                   &kAttr16, &kAssetPackage16,
@@ -5156,11 +5156,11 @@ status_t ResourceTable::processBundleFormatImpl(const Bundle* bundle,
             // This child element will be extracted into its own resource file.
             // Generate a name and path for it from its parent.
             nestedResourceName = String8::format("%s_%d",
-                        String8(resourceName).string(), suffix++);
+                        String8(resourceName).c_str(), suffix++);
             nestedResourcePath = String8::format("res/%s/%s.xml",
                         target->getGroupEntry().toDirName(target->getResourceType())
-                                               .string(),
-                        nestedResourceName.string());
+                                               .c_str(),
+                        nestedResourceName.c_str());
 
             // Lookup or create the entry for this name.
             sp<Entry> entry = getEntry(kAssetPackage16,
@@ -5187,20 +5187,20 @@ status_t ResourceTable::processBundleFormatImpl(const Bundle* bundle,
 
         if (bundle->getVerbose()) {
             source.printf("generating nested resource %s:%s/%s",
-                    mAssets->getPackage().string(), target->getResourceType().string(),
-                    nestedResourceName.string());
+                    mAssets->getPackage().c_str(), target->getResourceType().c_str(),
+                    nestedResourceName.c_str());
         }
 
         // Build the attribute reference and assign it to the parent.
         String16 nestedResourceRef = String16(String8::format("@%s:%s/%s",
-                    mAssets->getPackage().string(), target->getResourceType().string(),
-                    nestedResourceName.string()));
+                    mAssets->getPackage().c_str(), target->getResourceType().c_str(),
+                    nestedResourceName.c_str()));
 
         String16 attrNs = buildNamespace(attrPackage);
         if (parent->getAttribute(attrNs, attrName) != NULL) {
             SourcePos(parent->getFilename(), parent->getStartLineNumber())
                     .error("parent of nested resource already defines attribute '%s:%s'",
-                           String8(attrPackage).string(), String8(attrName).string());
+                           String8(attrPackage).c_str(), String8(attrName).c_str());
             return UNKNOWN_ERROR;
         }
 
diff --git a/tools/aapt/SourcePos.cpp b/tools/aapt/SourcePos.cpp
index 38643201c22d..e13028684414 100644
--- a/tools/aapt/SourcePos.cpp
+++ b/tools/aapt/SourcePos.cpp
@@ -80,12 +80,12 @@ ErrorPos::print(FILE* to) const
     
     if (!this->file.isEmpty()) {
         if (this->line >= 0) {
-            fprintf(to, "%s:%d: %s%s\n", this->file.string(), this->line, type, this->error.string());
+            fprintf(to, "%s:%d: %s%s\n", this->file.c_str(), this->line, type, this->error.c_str());
         } else {
-            fprintf(to, "%s: %s%s\n", this->file.string(), type, this->error.string());
+            fprintf(to, "%s: %s%s\n", this->file.c_str(), type, this->error.c_str());
         }
     } else {
-        fprintf(to, "%s%s\n", type, this->error.string());
+        fprintf(to, "%s%s\n", type, this->error.c_str());
     }
 }
 
diff --git a/tools/aapt/StringPool.cpp b/tools/aapt/StringPool.cpp
index 6cacd32eb91d..8d0268393433 100644
--- a/tools/aapt/StringPool.cpp
+++ b/tools/aapt/StringPool.cpp
@@ -67,7 +67,7 @@ void printStringPool(const ResStringPool* pool)
     const size_t NS = pool->size();
     for (size_t s=0; s<NS; s++) {
         auto str = pool->string8ObjectAt(s);
-        printf("String #" ZD ": %s\n", (ZD_TYPE) s, (str.has_value() ? str->string() : ""));
+        printf("String #" ZD ": %s\n", (ZD_TYPE) s, (str.has_value() ? str->c_str() : ""));
     }
 }
 
@@ -139,7 +139,7 @@ ssize_t StringPool::add(const String16& value,
     if (eidx < 0) {
         eidx = mEntries.add(entry(value));
         if (eidx < 0) {
-            fprintf(stderr, "Failure adding string %s\n", String8(value).string());
+            fprintf(stderr, "Failure adding string %s\n", String8(value).c_str());
             return eidx;
         }
     }
@@ -148,7 +148,7 @@ ssize_t StringPool::add(const String16& value,
         entry& ent = mEntries.editItemAt(eidx);
         if (kIsDebug) {
             printf("*** adding config type name %s, was %s\n",
-                    configTypeName->string(), ent.configTypeName.string());
+                    configTypeName->c_str(), ent.configTypeName.c_str());
         }
         if (ent.configTypeName.size() <= 0) {
             ent.configTypeName = *configTypeName;
@@ -166,7 +166,7 @@ ssize_t StringPool::add(const String16& value,
             if (cmp >= 0) {
                 if (cmp > 0) {
                     if (kIsDebug) {
-                        printf("*** inserting config: %s\n", config->toString().string());
+                        printf("*** inserting config: %s\n", config->toString().c_str());
                     }
                     ent.configs.insertAt(*config, addPos);
                 }
@@ -175,7 +175,7 @@ ssize_t StringPool::add(const String16& value,
         }
         if (addPos >= ent.configs.size()) {
             if (kIsDebug) {
-                printf("*** adding config: %s\n", config->toString().string());
+                printf("*** adding config: %s\n", config->toString().c_str());
             }
             ent.configs.add(*config);
         }
@@ -195,7 +195,7 @@ ssize_t StringPool::add(const String16& value,
 
     if (kIsDebug) {
         printf("Adding string %s to pool: pos=%zd eidx=%zd vidx=%zd\n",
-                String8(value).string(), pos, eidx, vidx);
+                String8(value).c_str(), pos, eidx, vidx);
     }
 
     return pos;
@@ -286,13 +286,13 @@ void StringPool::sortByConfig()
 
     for (size_t i=0; i<N; i++) {
         printf("#%d was %d: %s\n", i, newPosToOriginalPos[i],
-                mEntries[mEntryArray[newPosToOriginalPos[i]]].makeConfigsString().string());
+                mEntries[mEntryArray[newPosToOriginalPos[i]]].makeConfigsString().c_str());
         entries.add(mEntries[mEntryArray[i]]);
     }
 
     for (size_t i=0; i<entries.size(); i++) {
         printf("Sorted config #%d: %s\n", i,
-                entries[i].makeConfigsString().string());
+                entries[i].makeConfigsString().c_str());
     }
 #endif
 
@@ -363,8 +363,8 @@ void StringPool::sortByConfig()
     printf("FINAL SORTED STRING CONFIGS:\n");
     for (size_t i=0; i<mEntries.size(); i++) {
         const entry& ent = mEntries[i];
-        printf("#" ZD " %s: %s\n", (ZD_TYPE)i, ent.makeConfigsString().string(),
-                String8(ent.value).string());
+        printf("#" ZD " %s: %s\n", (ZD_TYPE)i, ent.makeConfigsString().c_str(),
+                String8(ent.value).c_str());
     }
 #endif
 }
@@ -415,7 +415,7 @@ status_t StringPool::writeStringBlock(const sp<AaptFile>& pool)
             ssize_t idx = add(span.name, true);
             if (idx < 0) {
                 fprintf(stderr, "Error adding span for style tag '%s'\n",
-                        String8(span.name).string());
+                        String8(span.name).c_str());
                 return idx;
             }
             span.span.name.index = (uint32_t)idx;
@@ -571,7 +571,7 @@ status_t StringPool::writeStringBlock(const sp<AaptFile>& pool)
         if (kIsDebug) {
             printf("Writing entry #%zu: \"%s\" ent=%zu off=%zu\n",
                     i,
-                    String8(ent.value).string(),
+                    String8(ent.value).c_str(),
                     mEntryArray[i],
                     ent.offset);
         }
@@ -591,8 +591,8 @@ ssize_t StringPool::offsetForString(const String16& val) const
     const Vector<size_t>* indices = offsetsForString(val);
     ssize_t res = indices != NULL && indices->size() > 0 ? indices->itemAt(0) : -1;
     if (kIsDebug) {
-        printf("Offset for string %s: %zd (%s)\n", String8(val).string(), res,
-                res >= 0 ? String8(mEntries[mEntryArray[res]].value).string() : String8());
+        printf("Offset for string %s: %zd (%s)\n", String8(val).c_str(), res,
+                res >= 0 ? String8(mEntries[mEntryArray[res]].value).c_str() : String8());
     }
     return res;
 }
diff --git a/tools/aapt/Symbol.h b/tools/aapt/Symbol.h
index e1575410e38b..de1d60cbae42 100644
--- a/tools/aapt/Symbol.h
+++ b/tools/aapt/Symbol.h
@@ -68,9 +68,9 @@ Symbol::Symbol(const android::String16& p, const android::String16& t, const and
 
 android::String8 Symbol::toString() const {
     return android::String8::format("%s:%s/%s (0x%08x)",
-            android::String8(package).string(),
-            android::String8(type).string(),
-            android::String8(name).string(),
+            android::String8(package).c_str(),
+            android::String8(type).c_str(),
+            android::String8(name).c_str(),
             (int) id);
 }
 
diff --git a/tools/aapt/XMLNode.cpp b/tools/aapt/XMLNode.cpp
index 69392d66e21f..e270a7333295 100644
--- a/tools/aapt/XMLNode.cpp
+++ b/tools/aapt/XMLNode.cpp
@@ -66,14 +66,14 @@ static const String16 RESOURCES_TOOLS_NAMESPACE("http://schemas.android.com/tool
 
 String16 getNamespaceResourcePackage(const String16& appPackage, const String16& namespaceUri, bool* outIsPublic)
 {
-    //printf("%s starts with %s?\n", String8(namespaceUri).string(),
-    //       String8(RESOURCES_PREFIX).string());
+    //printf("%s starts with %s?\n", String8(namespaceUri).c_str(),
+    //       String8(RESOURCES_PREFIX).c_str());
     size_t prefixSize;
     bool isPublic = true;
     if(namespaceUri.startsWith(RESOURCES_PREFIX_AUTO_PACKAGE)) {
         if (kIsDebug) {
-            printf("Using default application package: %s -> %s\n", String8(namespaceUri).string(),
-                   String8(appPackage).string());
+            printf("Using default application package: %s -> %s\n", String8(namespaceUri).c_str(),
+                   String8(appPackage).c_str());
         }
         isPublic = true;
         return appPackage;
@@ -88,7 +88,7 @@ String16 getNamespaceResourcePackage(const String16& appPackage, const String16&
     }
 
     //printf("YES!\n");
-    //printf("namespace: %s\n", String8(String16(namespaceUri, namespaceUri.size()-prefixSize, prefixSize)).string());
+    //printf("namespace: %s\n", String8(String16(namespaceUri, namespaceUri.size()-prefixSize, prefixSize)).c_str());
     if (outIsPublic) *outIsPublic = isPublic;
     return String16(namespaceUri, namespaceUri.size()-prefixSize, prefixSize);
 }
@@ -97,7 +97,7 @@ status_t hasSubstitutionErrors(const char* fileName,
                                ResXMLTree* inXml,
                                const String16& str16)
 {
-    const char16_t* str = str16.string();
+    const char16_t* str = str16.c_str();
     const char16_t* p = str;
     const char16_t* end = str + str16.size();
 
@@ -223,7 +223,7 @@ status_t parseStyledString(Bundle* /* bundle */,
             String16 text(inXml->getText(&len));
             if (firstTime && text.size() > 0) {
                 firstTime = false;
-                if (text.string()[0] == '@') {
+                if (text.c_str()[0] == '@') {
                     // If this is a resource reference, don't do the pseudoloc.
                     pseudolocalize = NO_PSEUDOLOCALIZATION;
                     pseudo.setMethod(pseudolocalize);
@@ -263,7 +263,7 @@ status_t parseStyledString(Bundle* /* bundle */,
                 {
                     SourcePos(String8(fileName), inXml->getLineNumber()).error(
                             "Found unsupported XLIFF tag <%s>\n",
-                            element8.string());
+                            element8.c_str());
                     return UNKNOWN_ERROR;
                 }
 moveon:
@@ -272,14 +272,14 @@ moveon:
 
             if (outSpans == NULL) {
                 SourcePos(String8(fileName), inXml->getLineNumber()).error(
-                        "Found style tag <%s> where styles are not allowed\n", element8.string());
+                        "Found style tag <%s> where styles are not allowed\n", element8.c_str());
                 return UNKNOWN_ERROR;
             }
 
-            if (!ResTable::collectString(outString, curString.string(),
+            if (!ResTable::collectString(outString, curString.c_str(),
                                          curString.size(), false, &errorMsg, true)) {
                 SourcePos(String8(fileName), inXml->getLineNumber()).error("%s (in %s)\n",
-                        errorMsg, String8(curString).string());
+                        errorMsg, String8(curString).c_str());
                 return UNKNOWN_ERROR;
             }
             rawString.append(curString);
@@ -295,7 +295,7 @@ moveon:
                 str = inXml->getAttributeStringValue(ai, &len);
                 span.name.append(str, len);
             }
-            //printf("Span: %s\n", String8(span.name).string());
+            //printf("Span: %s\n", String8(span.name).c_str());
             span.span.firstChar = span.span.lastChar = outString->size();
             spanStack.push(span);
 
@@ -311,21 +311,21 @@ moveon:
                 xliffDepth--;
                 continue;
             }
-            if (!ResTable::collectString(outString, curString.string(),
+            if (!ResTable::collectString(outString, curString.c_str(),
                                          curString.size(), false, &errorMsg, true)) {
                 SourcePos(String8(fileName), inXml->getLineNumber()).error("%s (in %s)\n",
-                        errorMsg, String8(curString).string());
+                        errorMsg, String8(curString).c_str());
                 return UNKNOWN_ERROR;
             }
             rawString.append(curString);
             curString = String16();
 
             if (spanStack.size() == 0) {
-                if (strcmp16(inXml->getElementName(&len), endTag.string()) != 0) {
+                if (strcmp16(inXml->getElementName(&len), endTag.c_str()) != 0) {
                     SourcePos(String8(fileName), inXml->getLineNumber()).error(
                             "Found tag %s where <%s> close is expected\n",
-                            String8(inXml->getElementName(&len)).string(),
-                            String8(endTag).string());
+                            String8(inXml->getElementName(&len)).c_str(),
+                            String8(endTag).c_str());
                     return UNKNOWN_ERROR;
                 }
                 break;
@@ -334,15 +334,15 @@ moveon:
             String16 spanTag;
             ssize_t semi = span.name.findFirst(';');
             if (semi >= 0) {
-                spanTag.setTo(span.name.string(), semi);
+                spanTag.setTo(span.name.c_str(), semi);
             } else {
                 spanTag.setTo(span.name);
             }
-            if (strcmp16(inXml->getElementName(&len), spanTag.string()) != 0) {
+            if (strcmp16(inXml->getElementName(&len), spanTag.c_str()) != 0) {
                 SourcePos(String8(fileName), inXml->getLineNumber()).error(
                         "Found close tag %s where close tag %s is expected\n",
-                        String8(inXml->getElementName(&len)).string(),
-                        String8(spanTag).string());
+                        String8(inXml->getElementName(&len)).c_str(),
+                        String8(spanTag).c_str());
                 return UNKNOWN_ERROR;
             }
             bool empty = true;
@@ -363,7 +363,7 @@ moveon:
             if (0 && empty) {
                 fprintf(stderr, "%s:%d: warning: empty '%s' span found in text '%s'\n",
                         fileName, inXml->getLineNumber(),
-                        String8(spanTag).string(), String8(*outString).string());
+                        String8(spanTag).c_str(), String8(*outString).c_str());
 
             }
         } else if (code == ResXMLTree::START_NAMESPACE) {
@@ -380,11 +380,11 @@ moveon:
 
     if (outSpans != NULL && outSpans->size() > 0) {
         if (curString.size() > 0) {
-            if (!ResTable::collectString(outString, curString.string(),
+            if (!ResTable::collectString(outString, curString.c_str(),
                                          curString.size(), false, &errorMsg, true)) {
                 SourcePos(String8(fileName), inXml->getLineNumber()).error(
                         "%s (in %s)\n",
-                        errorMsg, String8(curString).string());
+                        errorMsg, String8(curString).c_str());
                 return UNKNOWN_ERROR;
             }
         }
@@ -450,10 +450,10 @@ void printXMLBlock(ResXMLTree* block)
             String8 elemNs = build_namespace(namespaces, ns16);
             const char16_t* com16 = block->getComment(&len);
             if (com16) {
-                printf("%s <!-- %s -->\n", prefix.string(), String8(com16).string());
+                printf("%s <!-- %s -->\n", prefix.c_str(), String8(com16).c_str());
             }
-            printf("%sE: %s%s (line=%d)\n", prefix.string(), elemNs.string(),
-                   String8(block->getElementName(&len)).string(),
+            printf("%sE: %s%s (line=%d)\n", prefix.c_str(), elemNs.c_str(),
+                   String8(block->getElementName(&len)).c_str(),
                    block->getLineNumber());
             int N = block->getAttributeCount();
             depth++;
@@ -463,11 +463,11 @@ void printXMLBlock(ResXMLTree* block)
                 ns16 = block->getAttributeNamespace(i, &len);
                 String8 ns = build_namespace(namespaces, ns16);
                 String8 name(block->getAttributeName(i, &len));
-                printf("%sA: ", prefix.string());
+                printf("%sA: ", prefix.c_str());
                 if (res) {
-                    printf("%s%s(0x%08x)", ns.string(), name.string(), res);
+                    printf("%s%s(0x%08x)", ns.c_str(), name.c_str(), res);
                 } else {
-                    printf("%s%s", ns.string(), name.string());
+                    printf("%s%s", ns.c_str(), name.c_str());
                 }
                 Res_value value;
                 block->getAttributeValue(i, &value);
@@ -480,14 +480,14 @@ void printXMLBlock(ResXMLTree* block)
                 } else if (value.dataType == Res_value::TYPE_STRING) {
                     printf("=\"%s\"",
                             ResTable::normalizeForOutput(String8(block->getAttributeStringValue(i,
-                                        &len)).string()).string());
+                                        &len)).c_str()).c_str());
                 } else {
                     printf("=(type 0x%x)0x%x", (int)value.dataType, (int)value.data);
                 }
                 const char16_t* val = block->getAttributeStringValue(i, &len);
                 if (val != NULL) {
-                    printf(" (Raw: \"%s\")", ResTable::normalizeForOutput(String8(val).string()).
-                            string());
+                    printf(" (Raw: \"%s\")", ResTable::normalizeForOutput(String8(val).c_str()).
+                            c_str());
                 }
                 printf("\n");
             }
@@ -509,8 +509,8 @@ void printXMLBlock(ResXMLTree* block)
             }
             ns.uri = String8(block->getNamespaceUri(&len));
             namespaces.push(ns);
-            printf("%sN: %s=%s\n", prefix.string(), ns.prefix.string(),
-                    ns.uri.string());
+            printf("%sN: %s=%s\n", prefix.c_str(), ns.prefix.c_str(),
+                    ns.uri.c_str());
             depth++;
         } else if (code == ResXMLTree::END_NAMESPACE) {
             if (--depth < 0) {
@@ -529,19 +529,19 @@ void printXMLBlock(ResXMLTree* block)
             if (ns.prefix != pr) {
                 prefix = make_prefix(depth);
                 printf("%s*** BAD END NS PREFIX: found=%s, expected=%s\n",
-                        prefix.string(), pr.string(), ns.prefix.string());
+                        prefix.c_str(), pr.c_str(), ns.prefix.c_str());
             }
             String8 uri = String8(block->getNamespaceUri(&len));
             if (ns.uri != uri) {
                 prefix = make_prefix(depth);
                 printf("%s *** BAD END NS URI: found=%s, expected=%s\n",
-                        prefix.string(), uri.string(), ns.uri.string());
+                        prefix.c_str(), uri.c_str(), ns.uri.c_str());
             }
             namespaces.pop();
         } else if (code == ResXMLTree::TEXT) {
             size_t len;
-            printf("%sC: \"%s\"\n", prefix.string(),
-                    ResTable::normalizeForOutput(String8(block->getText(&len)).string()).string());
+            printf("%sC: \"%s\"\n", prefix.c_str(),
+                    ResTable::normalizeForOutput(String8(block->getText(&len)).c_str()).c_str());
         }
     }
 
@@ -583,7 +583,7 @@ status_t parseXMLResource(const sp<AaptFile>& file, ResXMLTree* outTree,
 sp<XMLNode> XMLNode::parse(const sp<AaptFile>& file)
 {
     char buf[16384];
-    int fd = open(file->getSourceFile().string(), O_RDONLY | O_BINARY);
+    int fd = open(file->getSourceFile().c_str(), O_RDONLY | O_BINARY);
     if (fd < 0) {
         SourcePos(file->getSourceFile(), -1).error("Unable to open file for read: %s",
                 strerror(errno));
@@ -875,9 +875,9 @@ void XMLNode::setAttributeResID(size_t attrIdx, uint32_t resId)
     }
     if (kIsDebug) {
         printf("Elem %s %s=\"%s\": set res id = 0x%08x\n",
-                String8(getElementName()).string(),
-                String8(mAttributes.itemAt(attrIdx).name).string(),
-                String8(mAttributes.itemAt(attrIdx).string).string(),
+                String8(getElementName()).c_str(),
+                String8(mAttributes.itemAt(attrIdx).name).c_str(),
+                String8(mAttributes.itemAt(attrIdx).string).c_str(),
                 resId);
     }
     mAttributes.editItemAt(attrIdx).nameResId = resId;
@@ -915,7 +915,7 @@ void XMLNode::setEndLineNumber(int32_t line)
 
 void XMLNode::removeWhitespace(bool stripAll, const char** cDataTags)
 {
-    //printf("Removing whitespace in %s\n", String8(mElementName).string());
+    //printf("Removing whitespace in %s\n", String8(mElementName).c_str());
     size_t N = mChildren.size();
     if (cDataTags) {
         String8 tag(mElementName);
@@ -931,13 +931,13 @@ void XMLNode::removeWhitespace(bool stripAll, const char** cDataTags)
         sp<XMLNode> node = mChildren.itemAt(i);
         if (node->getType() == TYPE_CDATA) {
             // This is a CDATA node...
-            const char16_t* p = node->mChars.string();
+            const char16_t* p = node->mChars.c_str();
             while (*p != 0 && *p < 128 && isspace(*p)) {
                 p++;
             }
             //printf("Space ends at %d in \"%s\"\n",
-            //       (int)(p-node->mChars.string()),
-            //       String8(node->mChars).string());
+            //       (int)(p-node->mChars.c_str()),
+            //       String8(node->mChars).c_str());
             if (*p == 0) {
                 if (stripAll) {
                     // Remove this node!
@@ -949,18 +949,18 @@ void XMLNode::removeWhitespace(bool stripAll, const char** cDataTags)
                 }
             } else {
                 // Compact leading/trailing whitespace.
-                const char16_t* e = node->mChars.string()+node->mChars.size()-1;
+                const char16_t* e = node->mChars.c_str()+node->mChars.size()-1;
                 while (e > p && *e < 128 && isspace(*e)) {
                     e--;
                 }
-                if (p > node->mChars.string()) {
+                if (p > node->mChars.c_str()) {
                     p--;
                 }
-                if (e < (node->mChars.string()+node->mChars.size()-1)) {
+                if (e < (node->mChars.c_str()+node->mChars.size()-1)) {
                     e++;
                 }
-                if (p > node->mChars.string() ||
-                    e < (node->mChars.string()+node->mChars.size()-1)) {
+                if (p > node->mChars.c_str() ||
+                    e < (node->mChars.c_str()+node->mChars.size()-1)) {
                     String16 tmp(p, e-p+1);
                     node->mChars = tmp;
                 }
@@ -986,14 +986,14 @@ status_t XMLNode::parseValues(const sp<AaptAssets>& assets,
             table->setCurrentXmlPos(SourcePos(mFilename, getStartLineNumber()));
             if (!assets->getIncludedResources()
                     .stringToValue(&e.value, &e.string,
-                                  e.string.string(), e.string.size(), true, true,
+                                  e.string.c_str(), e.string.size(), true, true,
                                   e.nameResId, NULL, &defPackage, table, &ac)) {
                 hasErrors = true;
             }
             if (kIsDebug) {
                 printf("Attr %s: type=0x%x, str=%s\n",
-                        String8(e.name).string(), e.value.dataType,
-                        String8(e.string).string());
+                        String8(e.name).c_str(), e.value.dataType,
+                        String8(e.string).c_str());
             }
         }
     }
@@ -1023,30 +1023,30 @@ status_t XMLNode::assignResourceIds(const sp<AaptAssets>& assets,
             String16 pkg(getNamespaceResourcePackage(String16(assets->getPackage()), e.ns, &nsIsPublic));
             if (kIsDebug) {
                 printf("Elem %s %s=\"%s\": namespace(%s) %s ===> %s\n",
-                        String8(getElementName()).string(),
-                        String8(e.name).string(),
-                        String8(e.string).string(),
-                        String8(e.ns).string(),
+                        String8(getElementName()).c_str(),
+                        String8(e.name).c_str(),
+                        String8(e.string).c_str(),
+                        String8(e.ns).c_str(),
                         (nsIsPublic) ? "public" : "private",
-                        String8(pkg).string());
+                        String8(pkg).c_str());
             }
             if (pkg.size() <= 0) continue;
             uint32_t res = table != NULL
                 ? table->getResId(e.name, &attr, &pkg, &errorMsg, nsIsPublic)
                 : assets->getIncludedResources().
-                    identifierForName(e.name.string(), e.name.size(),
-                                      attr.string(), attr.size(),
-                                      pkg.string(), pkg.size());
+                    identifierForName(e.name.c_str(), e.name.size(),
+                                      attr.c_str(), attr.size(),
+                                      pkg.c_str(), pkg.size());
             if (res != 0) {
                 if (kIsDebug) {
                     printf("XML attribute name %s: resid=0x%08x\n",
-                            String8(e.name).string(), res);
+                            String8(e.name).c_str(), res);
                 }
                 setAttributeResID(i, res);
             } else {
                 SourcePos(mFilename, getStartLineNumber()).error(
                         "No resource identifier found for attribute '%s' in package '%s'\n",
-                        String8(e.name).string(), String8(pkg).string());
+                        String8(e.name).c_str(), String8(pkg).c_str());
                 hasErrors = true;
             }
         }
@@ -1137,7 +1137,7 @@ status_t XMLNode::flatten(const sp<AaptFile>& dest,
     if (kPrintStringMetrics) {
         fprintf(stderr, "**** total xml size: %zu / %zu%% strings (in %s)\n",
                 dest->getSize(), (stringPool->getSize()*100)/dest->getSize(),
-                dest->getPath().string());
+                dest->getPath().c_str());
     }
 
     return NO_ERROR;
@@ -1155,8 +1155,8 @@ void XMLNode::print(int indent)
         if (elemNs.size() > 0) {
             elemNs.append(":");
         }
-        printf("%s E: %s%s", prefix.string(),
-               elemNs.string(), String8(getElementName()).string());
+        printf("%s E: %s%s", prefix.c_str(),
+               elemNs.c_str(), String8(getElementName()).c_str());
         int N = mAttributes.size();
         for (i=0; i<N; i++) {
             ssize_t idx = mAttributeOrder.valueAt(i);
@@ -1171,21 +1171,21 @@ void XMLNode::print(int indent)
                 attrNs.append(":");
             }
             if (attr.nameResId) {
-                printf("%s%s(0x%08x)", attrNs.string(),
-                       String8(attr.name).string(), attr.nameResId);
+                printf("%s%s(0x%08x)", attrNs.c_str(),
+                       String8(attr.name).c_str(), attr.nameResId);
             } else {
-                printf("%s%s", attrNs.string(), String8(attr.name).string());
+                printf("%s%s", attrNs.c_str(), String8(attr.name).c_str());
             }
-            printf("=%s", String8(attr.string).string());
+            printf("=%s", String8(attr.string).c_str());
         }
         printf("\n");
     } else if (getType() == TYPE_NAMESPACE) {
-        printf("%s N: %s=%s\n", prefix.string(),
+        printf("%s N: %s=%s\n", prefix.c_str(),
                getNamespacePrefix().size() > 0
-                    ? String8(getNamespacePrefix()).string() : "<DEF>",
-               String8(getNamespaceUri()).string());
+                    ? String8(getNamespacePrefix()).c_str() : "<DEF>",
+               String8(getNamespaceUri()).c_str());
     } else {
-        printf("%s C: \"%s\"\n", prefix.string(), String8(getCData()).string());
+        printf("%s C: \"%s\"\n", prefix.c_str(), String8(getCData()).c_str());
     }
     int N = mChildren.size();
     for (i=0; i<N; i++) {
@@ -1258,7 +1258,7 @@ void XMLCALL
 XMLNode::characterData(void *userData, const XML_Char *s, int len)
 {
     if (kIsDebugParse) {
-        printf("CDATA: \"%s\"\n", String8(s, len).string());
+        printf("CDATA: \"%s\"\n", String8(s, len).c_str());
     }
     ParseState* st = (ParseState*)userData;
     sp<XMLNode> node = NULL;
@@ -1423,7 +1423,7 @@ status_t XMLNode::collect_attr_strings(StringPool* outPool,
                 idx = outPool->add(attr.name);
                 if (kIsDebug) {
                     printf("Adding attr %s (resid 0x%08x) to pool: idx=%zd\n",
-                            String8(attr.name).string(), id, idx);
+                            String8(attr.name).c_str(), id, idx);
                 }
                 if (id != 0) {
                     while ((ssize_t)outResIds->size() <= idx) {
@@ -1434,7 +1434,7 @@ status_t XMLNode::collect_attr_strings(StringPool* outPool,
             }
             attr.namePoolIdx = idx;
             if (kIsDebug) {
-                printf("String %s offset=0x%08zd\n", String8(attr.name).string(), idx);
+                printf("String %s offset=0x%08zd\n", String8(attr.name).c_str(), idx);
             }
         }
     }
@@ -1488,7 +1488,7 @@ status_t XMLNode::flatten_node(const StringPool& strings, const sp<AaptFile>& de
         node.comment.index = htodl(
             mComment.size() > 0 ? strings.offsetForString(mComment) : -1);
         //if (mComment.size() > 0) {
-        //  printf("Flattening comment: %s\n", String8(mComment).string());
+        //  printf("Flattening comment: %s\n", String8(mComment).c_str());
         //}
     } else {
         node.comment.index = htodl((uint32_t)-1);
diff --git a/tools/aapt/pseudolocalize.cpp b/tools/aapt/pseudolocalize.cpp
index 4e8dcb1bc6ee..fc2ed98949dd 100644
--- a/tools/aapt/pseudolocalize.cpp
+++ b/tools/aapt/pseudolocalize.cpp
@@ -42,7 +42,7 @@ String16 Pseudolocalizer::text(const String16& text) {
   size_t depth = mLastDepth;
   size_t lastpos, pos;
   const size_t length= text.size();
-  const char16_t* str = text.string();
+  const char16_t* str = text.c_str();
   bool escaped = false;
   for (lastpos = pos = 0; pos < length; pos++) {
     char16_t c = str[pos];
@@ -181,7 +181,7 @@ static bool is_possible_normal_placeholder_end(const char16_t c) {
 
 static String16 pseudo_generate_expansion(const unsigned int length) {
     String16 result = k_expansion_string;
-    const char16_t* s = result.string();
+    const char16_t* s = result.c_str();
     if (result.size() < length) {
         result += String16(" ");
         result += pseudo_generate_expansion(length - result.size());
@@ -237,7 +237,7 @@ String16 PseudoMethodAccent::end() {
  */
 String16 PseudoMethodAccent::text(const String16& source)
 {
-    const char16_t* s = source.string();
+    const char16_t* s = source.c_str();
     String16 result;
     const size_t I = source.size();
     bool lastspace = true;
@@ -357,7 +357,7 @@ String16 PseudoMethodAccent::placeholder(const String16& source) {
 
 String16 PseudoMethodBidi::text(const String16& source)
 {
-    const char16_t* s = source.string();
+    const char16_t* s = source.c_str();
     String16 result;
     bool lastspace = true;
     bool space = true;
diff --git a/tools/aapt2/Debug.cpp b/tools/aapt2/Debug.cpp
index f47d66ea5e87..3fa39009971c 100644
--- a/tools/aapt2/Debug.cpp
+++ b/tools/aapt2/Debug.cpp
@@ -445,7 +445,7 @@ void Debug::DumpResStringPool(const android::ResStringPool* pool, text::Printer*
   const size_t NS = pool->size();
   for (size_t s=0; s<NS; s++) {
     auto str = pool->string8ObjectAt(s);
-    printer->Print(StringPrintf("String #%zd : %s\n", s, str.has_value() ? str->string() : ""));
+    printer->Print(StringPrintf("String #%zd : %s\n", s, str.has_value() ? str->c_str() : ""));
   }
 }
 
diff --git a/tools/aapt2/cmd/Util.cpp b/tools/aapt2/cmd/Util.cpp
index 3244fb83fa4b..73a8d683c2bd 100644
--- a/tools/aapt2/cmd/Util.cpp
+++ b/tools/aapt2/cmd/Util.cpp
@@ -213,7 +213,7 @@ std::unique_ptr<xml::XmlResource> GenerateSplitManifest(const AppInfo& app_info,
   }
   std::vector<std::string> sanitized_config_names;
   for (const auto &config : constraints.configs) {
-    sanitized_config_names.push_back(MakePackageSafeName(config.toString().string()));
+    sanitized_config_names.push_back(MakePackageSafeName(config.toString().c_str()));
   }
   split_name << "config." << util::Joiner(sanitized_config_names, "_");
 
diff --git a/tools/aapt2/format/binary/BinaryResourceParser.cpp b/tools/aapt2/format/binary/BinaryResourceParser.cpp
index c65c55024bab..5ed84879d561 100644
--- a/tools/aapt2/format/binary/BinaryResourceParser.cpp
+++ b/tools/aapt2/format/binary/BinaryResourceParser.cpp
@@ -450,7 +450,7 @@ bool BinaryResourceParser::ParseLibrary(const ResChunk_header* chunk) {
   const size_t count = entries.size();
   for (size_t i = 0; i < count; i++) {
     table_->included_packages_[entries.valueAt(i)] =
-        util::Utf16ToUtf8(StringPiece16(entries.keyAt(i).string()));
+        util::Utf16ToUtf8(StringPiece16(entries.keyAt(i).c_str()));
   }
   return true;
 }
diff --git a/tools/split-select/Grouper_test.cpp b/tools/split-select/Grouper_test.cpp
index 7294a86fa862..a8b78cd3cf7c 100644
--- a/tools/split-select/Grouper_test.cpp
+++ b/tools/split-select/Grouper_test.cpp
@@ -179,7 +179,7 @@ void GrouperTest::expectHasGroupWithSplits(const Vector<const char*>& expectedSt
             errorMessage.append("\n");
         }
     }
-    ADD_FAILURE() << errorMessage.string();
+    ADD_FAILURE() << errorMessage.c_str();
 }
 
 void GrouperTest::addSplit(Vector<SplitDescription>& splits, const char* str) {
diff --git a/tools/split-select/Main.cpp b/tools/split-select/Main.cpp
index e6966db0aa00..1e751171b370 100644
--- a/tools/split-select/Main.cpp
+++ b/tools/split-select/Main.cpp
@@ -99,8 +99,7 @@ void generate(const KeyedVector<String8, Vector<SplitDescription> >& splits, con
         }
         masterRule = Rule::simplify(masterRule);
         fprintf(stdout, "  {\n    \"path\": \"%s\",\n    \"rules\": %s\n  }",
-                splits.keyAt(i).string(),
-                masterRule->toJson(2).string());
+                splits.keyAt(i).c_str(), masterRule->toJson(2).c_str());
     }
     fprintf(stdout, "\n]\n");
 }
@@ -158,25 +157,23 @@ static bool getAppInfo(const String8& path, AppInfo& outInfo) {
         const char16_t* name = xml.getElementName(&len);
         String16 name16(name, len);
         if (name16 == kManifestTag) {
-            ssize_t idx = xml.indexOfAttribute(
-                    kAndroidNamespace.string(), kAndroidNamespace.size(),
-                    kVersionCodeAttr.string(), kVersionCodeAttr.size());
+            ssize_t idx = xml.indexOfAttribute(kAndroidNamespace.c_str(), kAndroidNamespace.size(),
+                                               kVersionCodeAttr.c_str(), kVersionCodeAttr.size());
             if (idx >= 0) {
                 outInfo.versionCode = xml.getAttributeData(idx);
             }
 
         } else if (name16 == kApplicationTag) {
-            ssize_t idx = xml.indexOfAttribute(
-                    kAndroidNamespace.string(), kAndroidNamespace.size(),
-                    kMultiArchAttr.string(), kMultiArchAttr.size());
+            ssize_t idx = xml.indexOfAttribute(kAndroidNamespace.c_str(), kAndroidNamespace.size(),
+                                               kMultiArchAttr.c_str(), kMultiArchAttr.size());
             if (idx >= 0) {
                 outInfo.multiArch = xml.getAttributeData(idx) != 0;
             }
 
         } else if (name16 == kUsesSdkTag) {
-            ssize_t idx = xml.indexOfAttribute(
-                    kAndroidNamespace.string(), kAndroidNamespace.size(),
-                    kMinSdkVersionAttr.string(), kMinSdkVersionAttr.size());
+            ssize_t idx =
+                    xml.indexOfAttribute(kAndroidNamespace.c_str(), kAndroidNamespace.size(),
+                                         kMinSdkVersionAttr.c_str(), kMinSdkVersionAttr.size());
             if (idx >= 0) {
                 uint16_t type = xml.getAttributeDataType(idx);
                 if (type >= Res_value::TYPE_FIRST_INT && type <= Res_value::TYPE_LAST_INT) {
@@ -187,10 +184,10 @@ static bool getAppInfo(const String8& path, AppInfo& outInfo) {
                         fprintf(stderr, "warning: failed to retrieve android:minSdkVersion.\n");
                     } else {
                         char *endPtr;
-                        int minSdk = strtol(minSdk8->string(), &endPtr, 10);
-                        if (endPtr != minSdk8->string() + minSdk8->size()) {
+                        int minSdk = strtol(minSdk8->c_str(), &endPtr, 10);
+                        if (endPtr != minSdk8->c_str() + minSdk8->size()) {
                             fprintf(stderr, "warning: failed to parse android:minSdkVersion '%s'\n",
-                                    minSdk8->string());
+                                    minSdk8->c_str());
                         } else {
                             outInfo.minSdkVersion = minSdk;
                         }
@@ -232,7 +229,7 @@ static Vector<SplitDescription> extractSplitDescriptionsFromApk(const String8& p
             splits.add();
             Vector<String8> parts = AaptUtil::splitAndLowerCase(dir->getFileName(i), '-');
             if (parseAbi(parts, 0, &splits.editTop()) < 0) {
-                fprintf(stderr, "Malformed library %s\n", dir->getFileName(i).string());
+                fprintf(stderr, "Malformed library %s\n", dir->getFileName(i).c_str());
                 splits.pop();
             }
         }
@@ -291,7 +288,7 @@ static int main(int argc, char** argv) {
             help();
             return 0;
         } else {
-            fprintf(stderr, "error: unknown argument '%s'.\n", arg.string());
+            fprintf(stderr, "error: unknown argument '%s'.\n", arg.c_str());
             usage();
             return 1;
         }
@@ -313,15 +310,14 @@ static int main(int argc, char** argv) {
     // Find out some details about the base APK.
     AppInfo baseAppInfo;
     if (!getAppInfo(baseApkPath, baseAppInfo)) {
-        fprintf(stderr, "error: unable to read base APK: '%s'.\n", baseApkPath.string());
+        fprintf(stderr, "error: unable to read base APK: '%s'.\n", baseApkPath.c_str());
         return 1;
     }
 
     SplitDescription targetSplit;
     if (!generateFlag) {
         if (!SplitDescription::parse(targetConfigStr, &targetSplit)) {
-            fprintf(stderr, "error: invalid --target config: '%s'.\n",
-                    targetConfigStr.string());
+            fprintf(stderr, "error: invalid --target config: '%s'.\n", targetConfigStr.c_str());
             usage();
             return 1;
         }
@@ -341,7 +337,7 @@ static int main(int argc, char** argv) {
         Vector<SplitDescription> splits = extractSplitDescriptionsFromApk(splitApkPaths[i]);
         if (splits.isEmpty()) {
             fprintf(stderr, "error: invalid --split path: '%s'. No splits found.\n",
-                    splitApkPaths[i].string());
+                    splitApkPaths[i].c_str());
             usage();
             return 1;
         }
@@ -364,7 +360,7 @@ static int main(int argc, char** argv) {
         const size_t matchingSplitApkPathCount = matchingSplitPaths.size();
         for (size_t i = 0; i < matchingSplitApkPathCount; i++) {
             if (matchingSplitPaths[i] != baseApkPath) {
-                fprintf(stdout, "%s\n", matchingSplitPaths[i].string());
+                fprintf(stdout, "%s\n", matchingSplitPaths[i].c_str());
             }
         }
     } else {
diff --git a/tools/split-select/Rule_test.cpp b/tools/split-select/Rule_test.cpp
index c6cff0d0220e..c78533fd1907 100644
--- a/tools/split-select/Rule_test.cpp
+++ b/tools/split-select/Rule_test.cpp
@@ -68,7 +68,7 @@ TEST(RuleTest, generatesValidJson) {
     expected.erase(std::remove_if(expected.begin(), expected.end(), ::isspace), expected.end());
 
     // Result
-    std::string result(rule.toJson().string());
+    std::string result(rule.toJson().c_str());
     result.erase(std::remove_if(result.begin(), result.end(), ::isspace), result.end());
 
     ASSERT_EQ(expected, result);
diff --git a/tools/split-select/SplitDescription.cpp b/tools/split-select/SplitDescription.cpp
index 99bc23d819fb..4e2b48e1f450 100644
--- a/tools/split-select/SplitDescription.cpp
+++ b/tools/split-select/SplitDescription.cpp
@@ -134,8 +134,8 @@ bool SplitDescription::parse(const String8& str, SplitDescription* outSplit) {
     String8 configStr;
     String8 extensionStr;
     if (index >= 0) {
-        configStr.setTo(str.string(), index);
-        extensionStr.setTo(str.string() + index + 1);
+        configStr.setTo(str.c_str(), index);
+        extensionStr.setTo(str.c_str() + index + 1);
     } else {
         configStr.setTo(str);
     }
diff --git a/tools/split-select/TestRules.cpp b/tools/split-select/TestRules.cpp
index 86ccd6a25c18..ca3c56fe861c 100644
--- a/tools/split-select/TestRules.cpp
+++ b/tools/split-select/TestRules.cpp
@@ -78,9 +78,8 @@ const Rule AlwaysTrue() {
     const String8 actualStr(actual != NULL ? actual->toJson() : String8());
 
     if (expectedStr != actualStr) {
-        return ::testing::AssertionFailure()
-                << "Expected: " << expectedStr.string() << "\n"
-                << "  Actual: " << actualStr.string();
+        return ::testing::AssertionFailure() << "Expected: " << expectedStr.c_str() << "\n"
+                                             << "  Actual: " << actualStr.c_str();
     }
     return ::testing::AssertionSuccess();
 }
-- 
2.39.5

